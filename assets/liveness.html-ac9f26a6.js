const e=JSON.parse('{"key":"v-64e3a386","path":"/java/concurrency/liveness.html","title":"并发Liveness问题","lang":"en-US","frontmatter":{"title":"并发Liveness问题","date":"2023-08-09T00:00:00.000Z","category":"java","tag":["Concurrency-Toolkit","Concurrency"]},"headers":[{"level":2,"title":"死锁Deadlock","slug":"死锁deadlock","link":"#死锁deadlock","children":[{"level":3,"title":"死锁的排查","slug":"死锁的排查","link":"#死锁的排查","children":[]}]},{"level":2,"title":"饥饿Starvation","slug":"饥饿starvation","link":"#饥饿starvation","children":[]},{"level":2,"title":"活锁Livelock","slug":"活锁livelock","link":"#活锁livelock","children":[]},{"level":2,"title":"FAQ","slug":"faq","link":"#faq","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1694501966000,"updatedTime":1694501966000},"readingTime":{"minutes":3.2,"words":961},"filePathRelative":"java/concurrency/liveness.md","localizedDate":"August 9, 2023","excerpt":"<p>多个线程协同工作，总是会遇到一些莫名其妙的情况。有可能出现多个线程敌不动我不动的情形，都在等待对方线程做些什么。有的线程不积极抢不过其他线程，可能一直没机会得到调度。也有可能多个线程抢占某个资源，势均力敌互不相让，结果一直在拉扯不休。这些问题统称为并发的<code>Liveness</code>问题，下面我们就无情揭开它们的面纱。</p>\\n<h2> 死锁Deadlock</h2>\\n<p>死锁是多线程中最差的一种情况，多个线程相互占用对方的资源的锁，而又相互等对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁。</p>\\n<p>举个例子：<br>\\nA同学抢了B同学的钢笔，B同学抢了A同学的书，两个人都相互占用对方的东西，都在让对方先还给自己自己再还，这样一直争执下去等待对方还而又得不到解决。</p>","copyright":{"author":"huhx","license":"MIT"}}');export{e as data};
