import{_ as p,r as l,o as d,c as i,e as r,w as s,b as a,d as e,a as n}from"./app-57542e83.js";const u="/assets/202308160942573388946-528588b3.png",k={},m=e(`<p>正则基本上算是每个开发语言的标配，其重要性不言而谕。之所以正则经久不衰，主要在于它在文字处理方面展现出恐怖而全面的能力。今天我们就来了解下这个文字处理神器：正则表达式。</p><h2 id="什么是正则表达式" tabindex="-1"><a class="header-anchor" href="#什么是正则表达式" aria-hidden="true">#</a> 什么是正则表达式</h2><p>正则表达式是用字符串描述的一个匹配规则，它们可用于搜索、编辑或操作文本和数据。正则的实现百家争鸣，各个语言实现的版本具有差异化，常见的有grep、Perl、Tcl、Python、PHP和awk，但是不用过于担心基本上是大同小异。</p><p>我们今天主要说的是java中的正则，它的风格算是跟<code>Perl</code>走得最为接近。java是面向对象的，表达正则肯定是用对象了。那么会有那些对象呢？</p><p>关于正则，java是有一个叫<code>java.util.regex</code>包的。它里面涵盖了正则的所有要求，其中最为重要的莫过于：<code>Pattern</code>、<code>Matcher</code>和<code>PatternSyntaxException</code></p><ul><li><code>Pattern</code>: 正则表达式的编译表示，无构造函数。由带参数的静态函数创建</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Pattern</span> <span class="token function">compile</span><span class="token punctuation">(</span><span class="token class-name">String</span> regex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Pattern</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Pattern</span> <span class="token function">compile</span><span class="token punctuation">(</span><span class="token class-name">String</span> regex<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Pattern</span><span class="token punctuation">(</span>regex<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>构造函数有两个参数，<code>regex</code>表示要编译的表达式，<code>flag</code>表示匹配规则中的标志位(这个在后面会讲到)。</p><ul><li><code>Matcher</code>: 是解释模式并对输入字符串执行匹配操作的引擎，也是无构造函数，由Pattern对象中的<code>matcher</code>方法生成</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">var</span> pattern <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;ab.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> matcher <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>matcher<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>PatternSyntaxException</code>: 是unchecked的异常，表示正则表达式模式中存在语法错误</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">var</span> pattern <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;[]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// java.util.regex.PatternSyntaxException: Unclosed character class near index 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为了展开后面的学习，这里写一个正则表达式的程序用于测试：接收控制台的正则表达式和字符串输入，然后打印出匹配的字符串以及相应的index</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>huhx<span class="token punctuation">.</span>regex</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>regex<span class="token punctuation">.</span></span><span class="token class-name">Pattern</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RegexTestHarness</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> console <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">console</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>console <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;No console.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token keyword">var</span> pattern <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token string">&quot;%nEnter your regex: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">var</span> string <span class="token operator">=</span> console<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token string">&quot;Enter input string to search: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> matcher <span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">boolean</span> found <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>matcher<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;I found the text&quot;</span> <span class="token operator">+</span>
                        <span class="token string">&quot; \\&quot;%s\\&quot; starting at &quot;</span> <span class="token operator">+</span>
                        <span class="token string">&quot;index %d and ending at index %d.%n&quot;</span><span class="token punctuation">,</span>
                    matcher<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    matcher<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    matcher<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                found <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>found<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;No match found.%n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>src</code>目录下面，使用以下命令行编译和运行</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>javac com<span class="token operator">/</span>huhx<span class="token operator">/</span>regex<span class="token operator">/</span><span class="token class-name">RegexTestHarness</span><span class="token punctuation">.</span>java

java <span class="token class-name"><span class="token namespace">com<span class="token punctuation">.</span>huhx<span class="token punctuation">.</span>regex<span class="token punctuation">.</span></span>RegexTestHarness</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+u+`" alt="regex harness" tabindex="0" loading="lazy"><figcaption>regex harness</figcaption></figure><h2 id="字符串文字" tabindex="-1"><a class="header-anchor" href="#字符串文字" aria-hidden="true">#</a> 字符串文字</h2><p>正则最基本形式是字符串文字的匹配，比如说正则表达式为foo并且输入字符串为foo，那就是匹配了。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Enter</span> your regex<span class="token operator">:</span> abc   
<span class="token class-name">Enter</span> input string <span class="token keyword">to</span> <span class="token namespace">search</span><span class="token operator">:</span> abcabcabc
<span class="token class-name">I</span> found the text <span class="token string">&quot;abc&quot;</span> starting at index <span class="token number">0</span> and ending at index <span class="token number">3.</span>
<span class="token class-name">I</span> found the text <span class="token string">&quot;abc&quot;</span> starting at index <span class="token number">3</span> and ending at index <span class="token number">6.</span>
<span class="token class-name">I</span> found the text <span class="token string">&quot;abc&quot;</span> starting at index <span class="token number">6</span> and ending at index <span class="token number">9.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按照约定，范围包含起始索引但不包含结束索引。所以第一个abc的匹配index为<code>[0,3)</code>。</p><p>其中需要注意的是，正则表达式中定义了一些元字符。这些字符有着特殊的含义，比如说<code>.</code>表示任意字符</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Enter</span> your regex<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">ab<span class="token punctuation">.</span></span>
Enter</span> input string <span class="token keyword">to</span> <span class="token namespace">search</span><span class="token operator">:</span> abd
<span class="token class-name">I</span> found the text <span class="token string">&quot;abd&quot;</span> starting at index <span class="token number">0</span> and ending at index <span class="token number">3.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么java中都有哪些类似的元字符呢？而如果我就是想把元字符当成普通字符来匹配又该如何是好呢？</p><p>元字符有<code>&lt;([{\\^-=$!|]})?*+.&gt;</code>，而强制将元字符视为普通字符的方法有以下两种：</p><ul><li>元字符之前加一个反斜杠<code>\\</code></li><li>将元字符括在<code>\\Q</code>(开始引用)和<code>\\E</code>(结束引用)内</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Enter</span> your regex<span class="token operator">:</span> ab\\<span class="token punctuation">.</span>
<span class="token class-name">Enter</span> input string <span class="token keyword">to</span> <span class="token namespace">search</span><span class="token operator">:</span> abd
<span class="token class-name">No</span> match <span class="token class-name"><span class="token namespace">found<span class="token punctuation">.</span></span>

Enter</span> your regex<span class="token operator">:</span> ab\\<span class="token punctuation">.</span>
<span class="token class-name">Enter</span> input string <span class="token keyword">to</span> <span class="token namespace">search</span><span class="token operator">:</span> <span class="token class-name"><span class="token namespace">ab<span class="token punctuation">.</span></span>
I</span> found the text <span class="token string">&quot;ab.&quot;</span> starting at index <span class="token number">0</span> and ending at index <span class="token number">3.</span>

<span class="token class-name">Enter</span> your regex<span class="token operator">:</span> ab\\<span class="token class-name">Q</span><span class="token punctuation">.</span>\\<span class="token class-name">E</span>
<span class="token class-name">Enter</span> input string <span class="token keyword">to</span> <span class="token namespace">search</span><span class="token operator">:</span> abd
<span class="token class-name">No</span> match <span class="token class-name"><span class="token namespace">found<span class="token punctuation">.</span></span>

Enter</span> your regex<span class="token operator">:</span> ab\\<span class="token class-name">Q</span><span class="token punctuation">.</span>\\<span class="token class-name">E</span>
<span class="token class-name">Enter</span> input string <span class="token keyword">to</span> <span class="token namespace">search</span><span class="token operator">:</span> <span class="token class-name"><span class="token namespace">ab<span class="token punctuation">.</span></span>
I</span> found the text <span class="token string">&quot;ab.&quot;</span> starting at index <span class="token number">0</span> and ending at index <span class="token number">3.</span>

<span class="token class-name">Enter</span> your regex<span class="token operator">:</span> \\<span class="token class-name">Qab</span><span class="token punctuation">.</span>\\<span class="token class-name">E</span>
<span class="token class-name">Enter</span> input string <span class="token keyword">to</span> <span class="token namespace">search</span><span class="token operator">:</span> <span class="token class-name"><span class="token namespace">ab<span class="token punctuation">.</span></span>
I</span> found the text <span class="token string">&quot;ab.&quot;</span> starting at index <span class="token number">0</span> and ending at index <span class="token number">3.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">Tips</p><p><code>\\Q</code>和<code>\\E</code>可以放置在表达式内的任何位置，前提是<code>\\Q</code>在前面。</p></div><h2 id="方括号内字符" tabindex="-1"><a class="header-anchor" href="#方括号内字符" aria-hidden="true">#</a> 方括号内字符</h2><table><thead><tr><th>正则表达式构造</th><th>描述说明</th></tr></thead><tbody><tr><td><code>[abc]</code></td><td>a, b, or c (simple class)</td></tr><tr><td><code>[^abc]</code></td><td>Any character except a, b, or c (negation)</td></tr><tr><td><code>[a-zA-Z]</code></td><td>a through z, or A through Z, inclusive (range)</td></tr><tr><td><code>[a-d[m-p]]</code></td><td>a through d, or m through p: [a-dm-p] (union)</td></tr><tr><td><code>[a-z&amp;&amp;[def]]</code></td><td>d, e, or f (intersection)</td></tr><tr><td><code>[a-z&amp;&amp;[^bc]]</code></td><td>a through z, except for b and c: [ad-z] (subtraction)</td></tr><tr><td><code>[a-z&amp;&amp;[^m-p]]</code></td><td>a through z, and not m through p: [a-lq-z] (subtraction)</td></tr></tbody></table><p>方括号里面的字符是<code>或</code>关系的，比如说[ab]就是<code>a</code>或<code>b</code>都可以匹配。<code>-</code>表示范围(包含首尾字符)，比如[1-9]就是匹配的数字在1到9(包含1和9这两个字符)之间。而<code>^</code>表示否定关系的，比如[^ab]就是除了a和b之外所有的字符。而<code>&amp;&amp;</code>表示且的关系，[ab&amp;&amp;bc]就是<code>ab</code>和<code>bc</code>的交集，也就是<code>b</code>。</p><p>下面给出一些例子：</p><ul><li><code>[0-4[6-8]]</code>: 0, 1, 2, 3, 4, 6, 7 and 8</li><li><code>[0-9&amp;&amp;[345]]</code>: 3, 4, and 5</li><li><code>[2-8&amp;&amp;[4-6]]</code>: 4, 5, and 6</li><li><code>[0-9&amp;&amp;[^345]]</code>: 3, 4, and 5</li></ul><h2 id="预定义字符" tabindex="-1"><a class="header-anchor" href="#预定义字符" aria-hidden="true">#</a> 预定义字符</h2><table><thead><tr><th>正则表达式构造</th><th>描述说明</th></tr></thead><tbody><tr><td><code>.</code></td><td>Any character (may or may not match line terminators)</td></tr><tr><td><code>\\d</code></td><td>A digit: <code>[0-9]</code></td></tr><tr><td><code>\\D</code></td><td>A non-digit: <code>[^0-9]</code></td></tr><tr><td><code>\\s</code></td><td>A whitespace character: <code>[ \\t\\n\\x0B\\f\\r]</code></td></tr><tr><td><code>\\S</code></td><td>A non-whitespace character: <code>[^\\s]</code></td></tr><tr><td><code>\\w</code></td><td>A word character: <code>[a-zA-Z_0-9]</code></td></tr><tr><td><code>\\W</code></td><td>A non-word character: <code>[^\\w]</code></td></tr></tbody></table><p>预定义字符比较简洁，尽可能使用它，可以使您的代码更易于阅读并消除格式错误的字符类引入的错误。</p><p>以反斜杠<code>\\</code>开头的结构称为转义结构。当我们使用<code>\\d</code>之类的，在字符串文字中使用转义构造，则必须在反斜杠前面加上另一个反斜杠才能编译字符串。至于原因，参考：<a href="#string%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8A%A0%E5%8F%8D%E6%96%9C%E6%9D%A0">String正则加反斜杠</a></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 编译报错：Illegal escape character in string literal</span>
<span class="token keyword">var</span> pattern <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;\\d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 正常编译：表示匹配一个数字</span>
<span class="token keyword">var</span> pattern <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;\\\\d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="匹配次数量词" tabindex="-1"><a class="header-anchor" href="#匹配次数量词" aria-hidden="true">#</a> 匹配次数量词</h2><p>很多情况下，我们会有对某些字符多次匹配的需求，比方说<code>1212</code>或者<code>大大方方</code>这类的叠词。这根本就难不倒正则，它提供了丰富的功能去满足这些字符多次匹配的需求。</p><table><thead><tr><th>Greedy</th><th>Reluctant</th><th>Possessive</th><th>Meaning</th></tr></thead><tbody><tr><td><code>X?</code></td><td><code>X??</code></td><td><code>X?+</code></td><td><code>X</code>, once or not at all</td></tr><tr><td><code>X*</code></td><td><code>X*?</code></td><td><code>X*+</code></td><td><code>X</code>, zero or more times</td></tr><tr><td><code>X+</code></td><td><code>X+?</code></td><td><code>X++</code></td><td><code>X</code>, one or more times</td></tr><tr><td><code>X{n}</code></td><td><code>X{n}?</code></td><td><code>X{n}+</code></td><td><code>X</code>, exactly <em><code>n</code></em> times</td></tr><tr><td><code>X{n,}</code></td><td><code>X{n,}?</code></td><td><code>X{n,}+</code></td><td><code>X</code>, at least <em><code>n</code></em> times</td></tr><tr><td><code>X{n,m}</code></td><td><code>X{n,m}?</code></td><td><code>X{n,m}+</code></td><td><code>X</code>, at least <em><code>n</code></em> but not more than <em><code>m</code></em> times</td></tr></tbody></table><p>乍一看，<code>X?</code>, <code>X??</code>和<code>X?+</code>做完全相同的事情，因为它们都表示匹配<code>X一次或根本不匹配</code>。然而事实却没那么简单。</p>`,42),v=n("div",{class:"language-java line-numbers-mode","data-ext":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token class-name"},"Enter"),a(" your regex"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token punctuation"},"."),a(`*foo
`),n("span",{class:"token class-name"},"Enter"),a(" input string "),n("span",{class:"token keyword"},"to"),a(),n("span",{class:"token namespace"},"search"),n("span",{class:"token operator"},":"),a(` xfooxxxxxxfoo
`),n("span",{class:"token class-name"},"I"),a(" found the text "),n("span",{class:"token string"},'"xfooxxxxxxfoo"'),a(" starting at index "),n("span",{class:"token number"},"0"),a(" and ending at index "),n("span",{class:"token number"},"13."),a(`

`),n("span",{class:"token class-name"},"Enter"),a(" your regex"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token punctuation"},"."),a("*"),n("span",{class:"token operator"},"?"),a(`foo
`),n("span",{class:"token class-name"},"Enter"),a(" input string "),n("span",{class:"token keyword"},"to"),a(),n("span",{class:"token namespace"},"search"),n("span",{class:"token operator"},":"),a(` xfooxxxxxxfoo
`),n("span",{class:"token class-name"},"I"),a(" found the text "),n("span",{class:"token string"},'"xfoo"'),a(" starting at index "),n("span",{class:"token number"},"0"),a(" and ending at index "),n("span",{class:"token number"},"4."),a(`
`),n("span",{class:"token class-name"},"I"),a(" found the text "),n("span",{class:"token string"},'"xxxxxxfoo"'),a(" starting at index "),n("span",{class:"token number"},"4"),a(" and ending at index "),n("span",{class:"token number"},"13."),a(`

`),n("span",{class:"token class-name"},"Enter"),a(" your regex"),n("span",{class:"token operator"},":"),a(),n("span",{class:"token punctuation"},"."),a("*"),n("span",{class:"token operator"},"+"),a(`foo
`),n("span",{class:"token class-name"},"Enter"),a(" input string "),n("span",{class:"token keyword"},"to"),a(),n("span",{class:"token namespace"},"search"),n("span",{class:"token operator"},":"),a(` xfooxxxxxxfoo
`),n("span",{class:"token class-name"},"No"),a(" match found"),n("span",{class:"token punctuation"},"."),a(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),b=e(`<h2 id="捕获组" tabindex="-1"><a class="header-anchor" href="#捕获组" aria-hidden="true">#</a> 捕获组</h2><p>捕获组是将多个字符视为一个单元的一种方法。它们是通过将要分组的字符放在一组括号内来创建的。</p><h3 id="组的编号" tabindex="-1"><a class="header-anchor" href="#组的编号" aria-hidden="true">#</a> 组的编号</h3><p>在java中，捕获组通过从左到右计算其左括号来进行编号。</p><p>例如，在表达式 ((A)(B(C)))中，有四个这样的组：</p><ul><li><code>((A)(B(C)))</code></li><li><code>(A)</code></li><li><code>(B(C))</code></li><li><code>(C)</code></li></ul><p>Jdk还提供了组数的查询，调用Matcher对象的<code>groupCount</code>方法就可以。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">var</span> matcher <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;((A)(B(C)))&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span><span class="token string">&quot;aaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>matcher<span class="token punctuation">.</span><span class="token function">groupCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>还有一个特殊的组，是<code>group 0</code>。因为它始终代表整个表达式，所以没有包含在<code>groupCount</code>方法的返回当中。以下是<code>groupCount</code>的源码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">groupCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> parentPattern<span class="token punctuation">.</span>capturingGroupCount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>了解组的编号至关重要，后续就可以根据此编号来取某个组的匹配内容。<code>Matcher</code>类提供了一些以下有用的方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> group<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token keyword">int</span> group<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">group</span><span class="token punctuation">(</span><span class="token keyword">int</span> group<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="反向引用" tabindex="-1"><a class="header-anchor" href="#反向引用" aria-hidden="true">#</a> 反向引用</h3><p>与捕获组匹配的输入字符串部分保存在内存中，以便以后通过反向引用调用。反向引用在正则表达式中指定为反斜杠<code>\\</code>，后跟一个指示要调用的组编号的数字<code>n</code>。例如表达式 <code>(\\d\\d)</code>定义一个与一行中的两个数字匹配的捕获组，稍后可以通过反向引用<code>\\1</code>在表达式中调用该捕获组。</p><p>如果想匹配类似于<code>2323</code>这种两个数字，后面跟相同的两个数字。正则表达式可以写成：<code>(\\d\\d)\\1</code></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Enter</span> your regex<span class="token operator">:</span> <span class="token punctuation">(</span>\\d\\d<span class="token punctuation">)</span>\\<span class="token number">1</span>
<span class="token class-name">Enter</span> input string <span class="token keyword">to</span> <span class="token namespace">search</span><span class="token operator">:</span> <span class="token number">2323</span>
<span class="token class-name">I</span> found the text <span class="token string">&quot;2323&quot;</span> starting at index <span class="token number">0</span> and ending at index <span class="token number">4.</span>

<span class="token class-name">Enter</span> your regex<span class="token operator">:</span> <span class="token punctuation">(</span>\\d\\d<span class="token punctuation">)</span>\\<span class="token number">1</span>
<span class="token class-name">Enter</span> input string <span class="token keyword">to</span> <span class="token namespace">search</span><span class="token operator">:</span> <span class="token number">2324</span>
<span class="token class-name">No</span> match found<span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="边界匹配" tabindex="-1"><a class="header-anchor" href="#边界匹配" aria-hidden="true">#</a> 边界匹配</h2><p>到目前为止，我们只关心是否在特定输入字符串中的某个位置找到匹配项。我们从不关心比赛发生在字符串的哪个位置。</p><p>您可以通过使用边界匹配器指定此类信息来使模式匹配更加精确。例如，也许您有兴趣查找某个特定单词，但前提是该单词出现在行首或行尾。或者您可能想知道匹配是否发生在单词边界上，或者发生在上一个匹配的末尾。</p><table><thead><tr><th>Boundary Construct</th><th>Description</th></tr></thead><tbody><tr><td><code>^</code></td><td>The beginning of a line</td></tr><tr><td><code>$</code></td><td>The end of a line</td></tr><tr><td><code>\\b</code></td><td>A word boundary</td></tr><tr><td><code>\\B</code></td><td>A non-word boundary</td></tr><tr><td><code>\\A</code></td><td>The beginning of the input</td></tr><tr><td><code>\\G</code></td><td>The end of the previous match</td></tr><tr><td><code>\\Z</code></td><td>The end of the input but for the final terminator, if any</td></tr><tr><td><code>\\z</code></td><td>The end of the input</td></tr></tbody></table><h2 id="前瞻后顾" tabindex="-1"><a class="header-anchor" href="#前瞻后顾" aria-hidden="true">#</a> 前瞻后顾</h2><p>Lookahead and Lookbehind Zero-Length Assertions，它匹配一些字符，但是并不包含匹配模式，只是确定是否匹配，也就是所谓的零宽。</p><ul><li><code>Lookahead</code>: 使用<code>?=</code>，q(?=u)表示q后面必须是u，但匹配结果中不包含u(零宽)，同样的有负前瞻，使用<code>?!</code>，比如q(?!u)则表示q后面必须不是u。</li><li><code>Lookbehind</code>: 使用<code>?&lt;</code>，<code>(?&lt;q)u</code>表示u前面为q，但匹配结果不包含q(零宽)，同样的有负后顾，使用<code>?&lt;!</code>，比如(?&lt;!q)u则表示u前面必须不是q。</li></ul><p>下面是一些例子：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token function">abc</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">)</span>      abc123      匹配，abc
                <span class="token number">123</span>abc      不匹配

<span class="token function">abc</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">!</span><span class="token number">123</span><span class="token punctuation">)</span>      abc123      不匹配
                abc444      匹配，abc

<span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">&lt;</span>abc<span class="token punctuation">)</span><span class="token number">123</span>      abc123      匹配，<span class="token number">123</span>
                xyz123      不匹配

<span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">&lt;</span><span class="token operator">!</span>abc<span class="token punctuation">)</span><span class="token number">123</span>     abc123      不匹配
                xyz123      匹配，<span class="token number">123</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="匹配标志位" tabindex="-1"><a class="header-anchor" href="#匹配标志位" aria-hidden="true">#</a> 匹配标志位</h2><h2 id="faq" tabindex="-1"><a class="header-anchor" href="#faq" aria-hidden="true">#</a> FAQ</h2><h3 id="string表达式加反斜杠" tabindex="-1"><a class="header-anchor" href="#string表达式加反斜杠" aria-hidden="true">#</a> String表达式加反斜杠？</h3><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>`,30);function h(g,x){const t=l("CodeTabs");return d(),i("div",null,[m,r(t,{id:"385",data:[{id:"xfooxxxxxxfoo"}],"tab-id":"java"},{title0:s(({value:o,isActive:c})=>[a("xfooxxxxxxfoo")]),tab0:s(({value:o,isActive:c})=>[v]),_:1}),b])}const y=p(k,[["render",h],["__file","regex-pattern.html.vue"]]);export{y as default};
