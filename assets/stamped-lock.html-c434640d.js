const e=JSON.parse('{"key":"v-5eec1833","path":"/java/concurrency/stamped-lock.html","title":"StampedLock","lang":"en-US","frontmatter":{"title":"StampedLock","date":"2023-09-07T00:00:00.000Z","category":"java","tag":["Concurrency-Toolkit","Concurrency"]},"headers":[{"level":2,"title":"使用","slug":"使用","link":"#使用","children":[]},{"level":2,"title":"分析","slug":"分析","link":"#分析","children":[]},{"level":2,"title":"FAQ","slug":"faq","link":"#faq","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1694501966000,"updatedTime":1694501966000},"readingTime":{"minutes":1.22,"words":367},"filePathRelative":"java/concurrency/stamped-lock.md","localizedDate":"September 7, 2023","excerpt":"<p>我们知道ReadWriteLock可以实现读写分离，但是读写之间仍旧是需要同步的。当有大量的读线程，那么也会造成写线程的长时间阻塞引发饥饿的问题。有没有一种锁可以针对这种场景做些优化呢？今天我们就来看下这个作为读写锁的升级版：StampedLock</p>\\n<h2> 使用</h2>\\n<p><code>StampedLock</code>提供了一种乐观的读策略。这种乐观的锁非常类似无锁的操作，使得乐观锁完全不会阻塞写线程。</p>\\n<h2> 分析</h2>\\n<p><code>StampedLock</code>的内部实现是基于CLH锁的。CLH锁是一种自旋锁，它保证没有饥饿发生，并且可以保证FIFO的服务顺序。</p>","copyright":{"author":"huhx","license":"MIT"}}');export{e as data};
