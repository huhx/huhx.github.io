import{_ as a,o as e,c as d,d as n}from"./app-57542e83.js";const c={},s=n(`<p>我们知道ReadWriteLock可以实现读写分离，但是读写之间仍旧是需要同步的。当有大量的读线程，那么也会造成写线程的长时间阻塞引发饥饿的问题。有没有一种锁可以针对这种场景做些优化呢？今天我们就来看下这个作为读写锁的升级版：StampedLock</p><h2 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h2><p><code>StampedLock</code>提供了一种乐观的读策略。这种乐观的锁非常类似无锁的操作，使得乐观锁完全不会阻塞写线程。</p><h2 id="分析" tabindex="-1"><a class="header-anchor" href="#分析" aria-hidden="true">#</a> 分析</h2><p><code>StampedLock</code>的内部实现是基于CLH锁的。CLH锁是一种自旋锁，它保证没有饥饿发生，并且可以保证FIFO的服务顺序。</p><p>CLH锁的基本思想如下：锁维护一个等待线程队列，所有申请锁但是没有成功的线程都记录在这个队列中。每一个节点(一个节点代表一个线程)，保存一个标记位(locked)用于判断当前线程是否已经持有锁。</p><p>当一个线程试图获得锁时，取得当前等待队列的尾部节点作为其前序节点，并使用类似如下代码判断前序节点是杏已经成功释放锁</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>locked<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="faq" tabindex="-1"><a class="header-anchor" href="#faq" aria-hidden="true">#</a> FAQ</h2><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li><code>StampedLock</code>提供了乐观读锁，可取代<code>ReadWriteLock</code>以进一步提升并发性能</li><li><code>StampedLock</code>是不可重入锁</li></ul><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>`,12),t=[s];function o(i,r){return e(),d("div",null,t)}const l=a(c,[["render",o],["__file","stamped-lock.html.vue"]]);export{l as default};
