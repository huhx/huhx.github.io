const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}W(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f==null||f.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":471,\"nextId\":471,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-184f4da6#hello-i-am-huhx\",\"2\":\"v-5c45d747\",\"3\":\"v-774baee0\",\"4\":\"v-0bcbca48\",\"5\":\"v-5cf0a2da\",\"6\":\"v-5c27e3e4\",\"7\":\"v-3c08b801\",\"8\":\"v-2f0551e6\",\"9\":\"v-17b75712\",\"10\":\"v-790c9e32\",\"11\":\"v-acf6dca6\",\"12\":\"v-acf6dca6#cobra\",\"13\":\"v-acf6dca6#cobra-cli\",\"14\":\"v-acf6dca6#flags\",\"15\":\"v-acf6dca6#auto-completion\",\"16\":\"v-acf6dca6#inside-cobra\",\"17\":\"v-acf6dca6#viper\",\"18\":\"v-acf6dca6#inside-viper\",\"19\":\"v-acf6dca6#faq\",\"20\":\"v-acf6dca6#总结\",\"21\":\"v-acf6dca6#参考\",\"22\":\"v-597983fa\",\"23\":\"v-597983fa#aliyun-oss-sdk\",\"24\":\"v-597983fa#viper-config\",\"25\":\"v-597983fa#cobra\",\"26\":\"v-30436b2d\",\"27\":\"v-f1fd1624\",\"28\":\"v-a82d8b9e\",\"29\":\"v-a82d8b9e#幸福的婚姻\",\"30\":\"v-a82d8b9e#顺利的工作\",\"31\":\"v-a82d8b9e#未来的展望\",\"32\":\"v-20f04276\",\"33\":\"v-6c2ec6ed\",\"34\":\"v-06e6a2ac\",\"35\":\"v-06568ca3\",\"36\":\"v-ea20d680\",\"37\":\"v-ea20d680#注解\",\"38\":\"v-ea20d680#faq\",\"39\":\"v-ea20d680#总结\",\"40\":\"v-ea20d680#参考\",\"41\":\"v-45eda174\",\"42\":\"v-45eda174#异常的介绍\",\"43\":\"v-4ddbba80\",\"44\":\"v-4ddbba80#函数式编程\",\"45\":\"v-4ddbba80#什么是函数接口\",\"46\":\"v-4ddbba80#函数接口的创建\",\"47\":\"v-4ddbba80#lambda表达式\",\"48\":\"v-4ddbba80#方法引用\",\"49\":\"v-4ddbba80#构造函数引用\",\"50\":\"v-4ddbba80#java函数式接口\",\"51\":\"v-4ddbba80#function-接受参数-有返回参数\",\"52\":\"v-4ddbba80#consumer-接受参数-没有返回\",\"53\":\"v-4ddbba80#predicate-接受参数-返回boolean\",\"54\":\"v-4ddbba80#supplier-不接受参数-有返回值\",\"55\":\"v-4ddbba80#faq\",\"56\":\"v-4ddbba80#lambda为什么不能抛出异常\",\"57\":\"v-4ddbba80#总结\",\"58\":\"v-4ddbba80#参考\",\"59\":\"v-f5270e8e\",\"60\":\"v-f5270e8e#概念介绍\",\"61\":\"v-f5270e8e#什么是原码\",\"62\":\"v-f5270e8e#什么是反码\",\"63\":\"v-f5270e8e#什么是补码\",\"64\":\"v-f5270e8e#整数的表示\",\"65\":\"v-f5270e8e#浮点数的表示\",\"66\":\"v-f5270e8e#faq\",\"67\":\"v-f5270e8e#使用补码-怎么乘除法\",\"68\":\"v-f5270e8e#字节序的大端模式与小端模式\",\"69\":\"v-f5270e8e#浮点数正无穷与负无穷\",\"70\":\"v-f5270e8e#浮点数为什么要加偏移量\",\"71\":\"v-f5270e8e#总结\",\"72\":\"v-f5270e8e#参考资料\",\"73\":\"v-0837ebc8\",\"74\":\"v-28aad9b4\",\"75\":\"v-28aad9b4#arraylist与aslist\",\"76\":\"v-28aad9b4#list-of的强不可变性\",\"77\":\"v-28aad9b4#copyof与unmodifiablelist\",\"78\":\"v-28aad9b4#stream中的list\",\"79\":\"v-28aad9b4#faq\",\"80\":\"v-28aad9b4#总结\",\"81\":\"v-28aad9b4#参考\",\"82\":\"v-2ecb7a15\",\"83\":\"v-63615b80\",\"84\":\"v-63615b80#springboot\",\"85\":\"v-63615b80#ignore-null-fields-with-jackson\",\"86\":\"v-63615b80#java-record类不能用作jpa实体\",\"87\":\"v-63615b80#docker\",\"88\":\"v-63615b80#docker远程debug\",\"89\":\"v-63615b80#standard\",\"90\":\"v-63615b80#boolean的短路评估\",\"91\":\"v-63615b80#静态方法的调用\",\"92\":\"v-63615b80#枚举类的比较\",\"93\":\"v-63615b80#map的get方法为null的情况\",\"94\":\"v-63615b80#stream中检查存在性\",\"95\":\"v-63615b80#null的instanceof操作符\",\"96\":\"v-63615b80#谨慎使用bigdecimal-double-构造\",\"97\":\"v-2a72d296\",\"98\":\"v-77f74d00\",\"99\":\"v-77f74d00#基础使用\",\"100\":\"v-77f74d00#enable-mocktio的注解\",\"101\":\"v-77f74d00#常见的mocktio用法\",\"102\":\"v-77f74d00#mocktio之capture\",\"103\":\"v-77f74d00#mocktio之静态mock\",\"104\":\"v-77f74d00#方法分析\",\"105\":\"v-77f74d00#常见问题\",\"106\":\"v-77f74d00#doreturn和thenreturn的区别\",\"107\":\"v-77f74d00#thenthrow和dothrow\",\"108\":\"v-42ece4bb\",\"109\":\"v-e9ce9cce\",\"110\":\"v-e9ce9cce#什么是正则表达式\",\"111\":\"v-e9ce9cce#字符串文字\",\"112\":\"v-e9ce9cce#方括号内字符\",\"113\":\"v-e9ce9cce#预定义字符\",\"114\":\"v-e9ce9cce#匹配次数量词\",\"115\":\"v-e9ce9cce#捕获组\",\"116\":\"v-e9ce9cce#组的编号\",\"117\":\"v-e9ce9cce#反向引用\",\"118\":\"v-e9ce9cce#边界匹配\",\"119\":\"v-e9ce9cce#前瞻后顾\",\"120\":\"v-e9ce9cce#匹配标志位\",\"121\":\"v-e9ce9cce#faq\",\"122\":\"v-e9ce9cce#string表达式加反斜杠\",\"123\":\"v-e9ce9cce#总结\",\"124\":\"v-e9ce9cce#参考\",\"125\":\"v-137e23fb\",\"126\":\"v-137e23fb#一文看懂timezone\",\"127\":\"v-0d6f22a2\",\"128\":\"v-3ce0b866\",\"129\":\"v-3ce0b866#varhandle\",\"130\":\"v-3ce0b866#分析\",\"131\":\"v-3ce0b866#faq\",\"132\":\"v-3ce0b866#总结\",\"133\":\"v-3ce0b866#参考\",\"134\":\"v-fd832666\",\"135\":\"v-fd832666#使用\",\"136\":\"v-fd832666#分析\",\"137\":\"v-fd832666#unsafe类\",\"138\":\"v-fd832666#faq\",\"139\":\"v-fd832666#总结\",\"140\":\"v-fd832666#参考\",\"141\":\"v-4984dde0\",\"142\":\"v-4984dde0#使用\",\"143\":\"v-4984dde0#分析\",\"144\":\"v-4984dde0#faq\",\"145\":\"v-4984dde0#总结\",\"146\":\"v-4984dde0#blockingqueue方法的总结\",\"147\":\"v-4984dde0#blockingqueue的使用场景\",\"148\":\"v-4984dde0#参考\",\"149\":\"v-838143d8\",\"150\":\"v-838143d8#cas\",\"151\":\"v-838143d8#原子操作\",\"152\":\"v-838143d8#工作原理\",\"153\":\"v-838143d8#优缺点\",\"154\":\"v-838143d8#aba问题\",\"155\":\"v-838143d8#循环长开销大\",\"156\":\"v-838143d8#单个共享变量\",\"157\":\"v-838143d8#faq\",\"158\":\"v-838143d8#总结\",\"159\":\"v-838143d8#参考\",\"160\":\"v-0f033d70\",\"161\":\"v-41135136\",\"162\":\"v-41135136#使用\",\"163\":\"v-41135136#分析\",\"164\":\"v-41135136#faq\",\"165\":\"v-41135136#总结\",\"166\":\"v-41135136#参考\",\"167\":\"v-7d93188e\",\"168\":\"v-7d93188e#使用\",\"169\":\"v-7d93188e#分析\",\"170\":\"v-7d93188e#faq\",\"171\":\"v-7d93188e#总结\",\"172\":\"v-7d93188e#参考\",\"173\":\"v-11139e93\",\"174\":\"v-11139e93#使用\",\"175\":\"v-11139e93#分析\",\"176\":\"v-11139e93#faq\",\"177\":\"v-11139e93#总结\",\"178\":\"v-11139e93#参考\",\"179\":\"v-b1b51f1c\",\"180\":\"v-b1b51f1c#countdownlatch的使用\",\"181\":\"v-b1b51f1c#countdownlatch的分析\",\"182\":\"v-b1b51f1c#faq\",\"183\":\"v-b1b51f1c#总结\",\"184\":\"v-b1b51f1c#参考\",\"185\":\"v-19d653b4\",\"186\":\"v-19d653b4#cyclicbarrier的使用\",\"187\":\"v-19d653b4#分析\",\"188\":\"v-19d653b4#faq\",\"189\":\"v-19d653b4#guava里面的ratelimiter\",\"190\":\"v-19d653b4#总结\",\"191\":\"v-19d653b4#参考\",\"192\":\"v-a5f1a90c\",\"193\":\"v-a5f1a90c#使用\",\"194\":\"v-a5f1a90c#分析\",\"195\":\"v-a5f1a90c#faq\",\"196\":\"v-a5f1a90c#总结\",\"197\":\"v-a5f1a90c#参考\",\"198\":\"v-7a32be94\",\"199\":\"v-7a32be94#使用\",\"200\":\"v-7a32be94#分析\",\"201\":\"v-7a32be94#faq\",\"202\":\"v-7a32be94#总结\",\"203\":\"v-7a32be94#参考\",\"204\":\"v-55e40098\",\"205\":\"v-55e40098#测试用例\",\"206\":\"v-55e40098#分析\",\"207\":\"v-55e40098#总结\",\"208\":\"v-55e40098#faq\",\"209\":\"v-55e40098#参考\",\"210\":\"v-64e3a386\",\"211\":\"v-64e3a386#死锁deadlock\",\"212\":\"v-64e3a386#死锁的排查\",\"213\":\"v-64e3a386#饥饿starvation\",\"214\":\"v-64e3a386#活锁livelock\",\"215\":\"v-64e3a386#faq\",\"216\":\"v-64e3a386#总结\",\"217\":\"v-64e3a386#参考\",\"218\":\"v-5338d14c\",\"219\":\"v-5338d14c#jvm中锁的实现与优化\",\"220\":\"v-5338d14c#偏向锁\",\"221\":\"v-5338d14c#轻量级锁\",\"222\":\"v-5338d14c#锁膨胀\",\"223\":\"v-5338d14c#自旋锁\",\"224\":\"v-5338d14c#锁消除\",\"225\":\"v-5338d14c#锁的优化思路\",\"226\":\"v-5338d14c#减少锁持有时间\",\"227\":\"v-5338d14c#减少锁粒度\",\"228\":\"v-5338d14c#锁分离\",\"229\":\"v-5338d14c#锁粗化\",\"230\":\"v-5338d14c#faq\",\"231\":\"v-5338d14c#总结\",\"232\":\"v-5338d14c#参考\",\"233\":\"v-03aed448\",\"234\":\"v-03aed448#使用\",\"235\":\"v-03aed448#分析\",\"236\":\"v-03aed448#faq\",\"237\":\"v-03aed448#总结\",\"238\":\"v-03aed448#参考\",\"239\":\"v-04e1fc9e\",\"240\":\"v-9d59984e\",\"241\":\"v-9d59984e#使用\",\"242\":\"v-9d59984e#分析\",\"243\":\"v-9d59984e#faq\",\"244\":\"v-9d59984e#总结\",\"245\":\"v-9d59984e#参考\",\"246\":\"v-b4c8ae44\",\"247\":\"v-b4c8ae44#重入锁的使用\",\"248\":\"v-b4c8ae44#为什么叫重入锁\",\"249\":\"v-b4c8ae44#中断响应lockinterruptibly\",\"250\":\"v-b4c8ae44#限时等待锁申请\",\"251\":\"v-b4c8ae44#公平锁和非公平锁\",\"252\":\"v-b4c8ae44#faq\",\"253\":\"v-b4c8ae44#synchronized和reentrantlock如何选择\",\"254\":\"v-b4c8ae44#总结\",\"255\":\"v-b4c8ae44#参考\",\"256\":\"v-3d5cb905\",\"257\":\"v-3d5cb905#semaphore使用\",\"258\":\"v-3d5cb905#semaphore分析\",\"259\":\"v-3d5cb905#faq\",\"260\":\"v-3d5cb905#总结\",\"261\":\"v-3d5cb905#参考\",\"262\":\"v-5eec1833\",\"263\":\"v-5eec1833#使用\",\"264\":\"v-5eec1833#分析\",\"265\":\"v-5eec1833#faq\",\"266\":\"v-5eec1833#总结\",\"267\":\"v-5eec1833#参考\",\"268\":\"v-015bd62a\",\"269\":\"v-015bd62a#什么是线程池\",\"270\":\"v-015bd62a#计时任务\",\"271\":\"v-015bd62a#jdk的线程池\",\"272\":\"v-015bd62a#线程池的原理\",\"273\":\"v-015bd62a#线程池的拓展\",\"274\":\"v-015bd62a#threadfactory\",\"275\":\"v-015bd62a#faq\",\"276\":\"v-015bd62a#总结\",\"277\":\"v-015bd62a#参考资料\",\"278\":\"v-7e84085d\",\"279\":\"v-7e84085d#assertj\",\"280\":\"v-7e84085d#hamcrest\",\"281\":\"v-1f8cedb4\",\"282\":\"v-1f8cedb4#日志门面\",\"283\":\"v-1f8cedb4#common-logging\",\"284\":\"v-1f8cedb4#slf4j\",\"285\":\"v-1f8cedb4#日志框架\",\"286\":\"v-1f8cedb4#java-util-logging\",\"287\":\"v-1f8cedb4#log4j\",\"288\":\"v-1f8cedb4#logback\",\"289\":\"v-1f8cedb4#log4j2\",\"290\":\"v-1f8cedb4#faq\",\"291\":\"v-1f8cedb4#总结\",\"292\":\"v-1f8cedb4#参考\",\"293\":\"v-4bbbb868\",\"294\":\"v-4bbbb868#faq\",\"295\":\"v-4bbbb868#record降临lombok还有必要吗\",\"296\":\"v-b3f64b22\",\"297\":\"v-f149fbe4\",\"298\":\"v-f149fbe4#原子性\",\"299\":\"v-f149fbe4#有序性\",\"300\":\"v-f149fbe4#可见性\",\"301\":\"v-f149fbe4#hapens-before原则\",\"302\":\"v-f149fbe4#faq\",\"303\":\"v-f149fbe4#总结\",\"304\":\"v-f149fbe4#参考\",\"305\":\"v-b56b3f84\",\"306\":\"v-b56b3f84#强引用\",\"307\":\"v-b56b3f84#软引用\",\"308\":\"v-b56b3f84#弱引用\",\"309\":\"v-b56b3f84#虚引用\",\"310\":\"v-b56b3f84#faq\",\"311\":\"v-b56b3f84#总结\",\"312\":\"v-b56b3f84#参考\",\"313\":\"v-c04dccd0\",\"314\":\"v-5acdfbdf\",\"315\":\"v-5acdfbdf#单例模式\",\"316\":\"v-5acdfbdf#饿汉模式\",\"317\":\"v-5acdfbdf#懒汉模式\",\"318\":\"v-5acdfbdf#延迟加载解决方案之声明synchronized\",\"319\":\"v-5acdfbdf#延迟加载解决方案之同步代码块\",\"320\":\"v-5acdfbdf#延迟加载解决方案之同步部分代码块\",\"321\":\"v-5acdfbdf#延迟加载解决方案之dcl双检查锁机制\",\"322\":\"v-5acdfbdf#总结\",\"323\":\"v-5acdfbdf#faq\",\"324\":\"v-5acdfbdf#参考\",\"325\":\"v-c908ab18\",\"326\":\"v-c908ab18#简单使用\",\"327\":\"v-c908ab18#可重入性\",\"328\":\"v-c908ab18#可重入原理\",\"329\":\"v-c908ab18#异常会释放锁\",\"330\":\"v-c908ab18#锁升级\",\"331\":\"v-c908ab18#faq\",\"332\":\"v-c908ab18#总结\",\"333\":\"v-c908ab18#参考\",\"334\":\"v-3e374220\",\"335\":\"v-3e374220#threadlocal的使用\",\"336\":\"v-3e374220#threadlocal的分析\",\"337\":\"v-3e374220#faq\",\"338\":\"v-3e374220#总结\",\"339\":\"v-3e374220#参考\",\"340\":\"v-f0e1d4ac\",\"341\":\"v-f0e1d4ac#线程的创建\",\"342\":\"v-f0e1d4ac#继承thread类\",\"343\":\"v-f0e1d4ac#实现runnable接口\",\"344\":\"v-f0e1d4ac#线程的暂停\",\"345\":\"v-f0e1d4ac#线程的终止\",\"346\":\"v-f0e1d4ac#线程的中断\",\"347\":\"v-f0e1d4ac#线程wait和notify\",\"348\":\"v-f0e1d4ac#线程优先级\",\"349\":\"v-f0e1d4ac#线程join和yield\",\"350\":\"v-f0e1d4ac#join方法\",\"351\":\"v-f0e1d4ac#yield方法\",\"352\":\"v-f0e1d4ac#守护线程\",\"353\":\"v-f0e1d4ac#faq\",\"354\":\"v-f0e1d4ac#在构建方法里面启动线程\",\"355\":\"v-f0e1d4ac#notify与notifyall的区别\",\"356\":\"v-f0e1d4ac#总结\",\"357\":\"v-f0e1d4ac#参考\",\"358\":\"v-54c6b66c\",\"359\":\"v-54c6b66c#可见性\",\"360\":\"v-54c6b66c#非原子性\",\"361\":\"v-54c6b66c#禁止指令重排序\",\"362\":\"v-54c6b66c#指令重排序\",\"363\":\"v-54c6b66c#faq\",\"364\":\"v-54c6b66c#lamda表达式里面的异常不能throw\",\"365\":\"v-54c6b66c#总结\",\"366\":\"v-54c6b66c#参考\",\"367\":\"v-7d09cd84\",\"368\":\"v-7d09cd84#什么是线程\",\"369\":\"v-7d09cd84#跟线程相关的概念\",\"370\":\"v-7d09cd84#同步-synchronous-和异步-asynchronous\",\"371\":\"v-7d09cd84#并发-concurrency-和并行-parallelism\",\"372\":\"v-7d09cd84#临界区\",\"373\":\"v-7d09cd84#阻塞-blocking-和非阻塞-non-blocking\",\"374\":\"v-7d09cd84#线程生命周期\",\"375\":\"v-7d09cd84#初始-new\",\"376\":\"v-7d09cd84#可运行-runnable\",\"377\":\"v-7d09cd84#阻塞-blocked\",\"378\":\"v-7d09cd84#等待-waiting\",\"379\":\"v-7d09cd84#超时等待-timed-waiting\",\"380\":\"v-7d09cd84#终止-terminated\",\"381\":\"v-7d09cd84#faq\",\"382\":\"v-7d09cd84#多线程在单核处理上会提升性能吗\",\"383\":\"v-7d09cd84#总结\",\"384\":\"v-7d09cd84#参考资料\",\"385\":\"v-25ee4b3e\",\"386\":\"v-25ee4b3e#开启caching\",\"387\":\"v-25ee4b3e#使用cache注解\",\"388\":\"v-25ee4b3e#cacheable\",\"389\":\"v-25ee4b3e#cacheevict\",\"390\":\"v-25ee4b3e#cacheput\",\"391\":\"v-25ee4b3e#caching\",\"392\":\"v-25ee4b3e#cacheconfig\",\"393\":\"v-25ee4b3e#使用条件cache\",\"394\":\"v-25ee4b3e#condition-parameter\",\"395\":\"v-25ee4b3e#unless-parameter\",\"396\":\"v-25ee4b3e#spring-cache原理\",\"397\":\"v-4cf24d6c\",\"398\":\"v-d282b1da\",\"399\":\"v-d282b1da#spring事务与applicationeventpublisher\",\"400\":\"v-026b3da0\",\"401\":\"v-026b3da0#什么是事务\",\"402\":\"v-026b3da0#原子性\",\"403\":\"v-026b3da0#一致性\",\"404\":\"v-026b3da0#隔离性\",\"405\":\"v-026b3da0#持久性\",\"406\":\"v-026b3da0#事务引发的问题\",\"407\":\"v-026b3da0#脏读\",\"408\":\"v-026b3da0#不可重复读\",\"409\":\"v-026b3da0#幻读\",\"410\":\"v-026b3da0#事务的传播级别\",\"411\":\"v-026b3da0#事务的隔离级别\",\"412\":\"v-026b3da0#读未提交\",\"413\":\"v-026b3da0#读已提交\",\"414\":\"v-026b3da0#可重复读\",\"415\":\"v-026b3da0#串行化\",\"416\":\"v-4e482859\",\"417\":\"v-32464859\",\"418\":\"v-2102bf12\",\"419\":\"v-2102bf12#打开当前项目的github\",\"420\":\"v-3074123e\",\"421\":\"v-2faff468\",\"422\":\"v-2faff468#为什么有依赖版本冲突\",\"423\":\"v-1beb0c26\",\"424\":\"v-f51616a6\",\"425\":\"v-f51616a6#macos\",\"426\":\"v-f51616a6#自带的快捷键\",\"427\":\"v-f51616a6#免密登录centos\",\"428\":\"v-c33d77a4\",\"429\":\"v-c33d77a4#aliyun服务器配置\",\"430\":\"v-c33d77a4#在oss中创建bucket\",\"431\":\"v-c33d77a4#创建用户用于访问bucket\",\"432\":\"v-c33d77a4#aliyun客户端配置\",\"433\":\"v-c33d77a4#配置upic\",\"434\":\"v-4d74d2d2\",\"435\":\"v-c1f0fcce\",\"436\":\"v-43f5a42c\",\"437\":\"v-28833795\",\"438\":\"v-1fc52da1\",\"439\":\"v-2d0a81d8\",\"440\":\"v-04ff77d5\",\"441\":\"v-2bee89ec\",\"442\":\"v-0b8ed43a\",\"443\":\"v-72582dd0\",\"444\":\"v-84ec5092\",\"445\":\"v-5ca7d302\",\"446\":\"v-bbca7094\",\"447\":\"v-71fde78e\",\"448\":\"v-4147e1c0\",\"449\":\"v-0aefcbc2\",\"450\":\"v-4578e4d4\",\"451\":\"v-07b657f0\",\"452\":\"v-7c80db8b\",\"453\":\"v-e39fab2c\",\"454\":\"v-067a82da\",\"455\":\"v-673af10a\",\"456\":\"v-14c69af4\",\"457\":\"v-2ba22020\",\"458\":\"v-780e7036\",\"459\":\"v-6cec0ebc\",\"460\":\"v-48579df1\",\"461\":\"v-d2e73b16\",\"462\":\"v-19ee9aae\",\"463\":\"v-097c815a\",\"464\":\"v-04df15dd\",\"465\":\"v-3a3ff2d5\",\"466\":\"v-24d7ac66\",\"467\":\"v-3a02344a\",\"468\":\"v-1559ca3e\",\"469\":\"v-69afbe6c\",\"470\":\"v-28a276da\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[4],\"2\":[1,1],\"3\":[2,2],\"4\":[1,1],\"5\":[2,2],\"6\":[1,1],\"7\":[1,1],\"8\":[1,1],\"9\":[1,1],\"10\":[1,1],\"11\":[1],\"12\":[1],\"13\":[2,40],\"14\":[1,68],\"15\":[2,15],\"16\":[2],\"17\":[1],\"18\":[2],\"19\":[1],\"20\":[1],\"21\":[1],\"22\":[1],\"23\":[3],\"24\":[2,10],\"25\":[1,7],\"26\":[1,1],\"27\":[1,1],\"28\":[1],\"29\":[1],\"30\":[1],\"31\":[1],\"32\":[1],\"33\":[1],\"34\":[1],\"35\":[1],\"36\":[1,6],\"37\":[1,35],\"38\":[1],\"39\":[1],\"40\":[1],\"41\":[1,3],\"42\":[1],\"43\":[1,8],\"44\":[1,9],\"45\":[1,52],\"46\":[1],\"47\":[1,31],\"48\":[1,31],\"49\":[1,18],\"50\":[1,9],\"51\":[3,43],\"52\":[3,31],\"53\":[3,36],\"54\":[3,35],\"55\":[1],\"56\":[2,8],\"57\":[1],\"58\":[1],\"59\":[1,8],\"60\":[1,8],\"61\":[1,40],\"62\":[1,35],\"63\":[1,51],\"64\":[1,39],\"65\":[1,146],\"66\":[1],\"67\":[3],\"68\":[2],\"69\":[2],\"70\":[2],\"71\":[1],\"72\":[1,6],\"73\":[1,1],\"74\":[1,12],\"75\":[1,33],\"76\":[2,96],\"77\":[1,108],\"78\":[1,72],\"79\":[1],\"80\":[1],\"81\":[1],\"82\":[1,1],\"83\":[1,4],\"84\":[1],\"85\":[5,19],\"86\":[2,23],\"87\":[1],\"88\":[1,55],\"89\":[1],\"90\":[1,20],\"91\":[1,27],\"92\":[1,30],\"93\":[1,25],\"94\":[1,33],\"95\":[1,12],\"96\":[3,33],\"97\":[1,1],\"98\":[1,10],\"99\":[1,30],\"100\":[2,61],\"101\":[1,56],\"102\":[1,75],\"103\":[1,60],\"104\":[1],\"105\":[1],\"106\":[1,1],\"107\":[1,1],\"108\":[2,4],\"109\":[1,7],\"110\":[1,118],\"111\":[1,61],\"112\":[1,69],\"113\":[1,59],\"114\":[1,34],\"115\":[1,3],\"116\":[1,41],\"117\":[1,36],\"118\":[1,39],\"119\":[1,40],\"120\":[1],\"121\":[1],\"122\":[2],\"123\":[1],\"124\":[1],\"125\":[1],\"126\":[1,4],\"127\":[1,11],\"128\":[1,1],\"129\":[1],\"130\":[1,3],\"131\":[1],\"132\":[1],\"133\":[1],\"134\":[1,7],\"135\":[1,9],\"136\":[1,38],\"137\":[1,50],\"138\":[1],\"139\":[1],\"140\":[1],\"141\":[1],\"142\":[1,86],\"143\":[1,89],\"144\":[1],\"145\":[1],\"146\":[1,33],\"147\":[1,1],\"148\":[1],\"149\":[1,11],\"150\":[1,43],\"151\":[1,4],\"152\":[1,1],\"153\":[1],\"154\":[1],\"155\":[1,2],\"156\":[1],\"157\":[1],\"158\":[1],\"159\":[1],\"160\":[1,6],\"161\":[1],\"162\":[1,10],\"163\":[1],\"164\":[1],\"165\":[1],\"166\":[1],\"167\":[1,12],\"168\":[1,44],\"169\":[1],\"170\":[1],\"171\":[1,11],\"172\":[1],\"173\":[1,8],\"174\":[1,33],\"175\":[1,59],\"176\":[1],\"177\":[1,3],\"178\":[1],\"179\":[1,5],\"180\":[1,155],\"181\":[1],\"182\":[1],\"183\":[1],\"184\":[1],\"185\":[1,5],\"186\":[1,157],\"187\":[1],\"188\":[1],\"189\":[2],\"190\":[1],\"191\":[1],\"192\":[1,9],\"193\":[1,6],\"194\":[1,75],\"195\":[1],\"196\":[1],\"197\":[1],\"198\":[2,2],\"199\":[1],\"200\":[1],\"201\":[1],\"202\":[1,9],\"203\":[1],\"204\":[1],\"205\":[1,32],\"206\":[1],\"207\":[1],\"208\":[1],\"209\":[1],\"210\":[1,12],\"211\":[1,55],\"212\":[1,67],\"213\":[1,43],\"214\":[1,17],\"215\":[1],\"216\":[1],\"217\":[1],\"218\":[1],\"219\":[1],\"220\":[1],\"221\":[1],\"222\":[1],\"223\":[1],\"224\":[1],\"225\":[1,5],\"226\":[1,88],\"227\":[1],\"228\":[1],\"229\":[1],\"230\":[1],\"231\":[1],\"232\":[1],\"233\":[1],\"234\":[1,78],\"235\":[1],\"236\":[1],\"237\":[1],\"238\":[1],\"239\":[1,1],\"240\":[1],\"241\":[1,88],\"242\":[1],\"243\":[1],\"244\":[1,9],\"245\":[1],\"246\":[1,6],\"247\":[1,62],\"248\":[1,77],\"249\":[1,10],\"250\":[1,2],\"251\":[1,5],\"252\":[1],\"253\":[2],\"254\":[1],\"255\":[1],\"256\":[1,4],\"257\":[1,123],\"258\":[1],\"259\":[1],\"260\":[1],\"261\":[1],\"262\":[1,7],\"263\":[1,4],\"264\":[1,18],\"265\":[1],\"266\":[1,3],\"267\":[1],\"268\":[1,6],\"269\":[1,198],\"270\":[1,91],\"271\":[1],\"272\":[1],\"273\":[1],\"274\":[1],\"275\":[1],\"276\":[1],\"277\":[1],\"278\":[1],\"279\":[1],\"280\":[1],\"281\":[1],\"282\":[1],\"283\":[2],\"284\":[1],\"285\":[1],\"286\":[3],\"287\":[1],\"288\":[1],\"289\":[1],\"290\":[1],\"291\":[1],\"292\":[1],\"293\":[1],\"294\":[1],\"295\":[2],\"296\":[1,1],\"297\":[1,1],\"298\":[1],\"299\":[1],\"300\":[1],\"301\":[2],\"302\":[1],\"303\":[1],\"304\":[1],\"305\":[1,9],\"306\":[1,14],\"307\":[1,8],\"308\":[1,16],\"309\":[1,16],\"310\":[1],\"311\":[1],\"312\":[1],\"313\":[1,13],\"314\":[1,9],\"315\":[1],\"316\":[1,15],\"317\":[1,26],\"318\":[1,25],\"319\":[1,26],\"320\":[1,22],\"321\":[1,42],\"322\":[1],\"323\":[1],\"324\":[1],\"325\":[1],\"326\":[1,6],\"327\":[1,26],\"328\":[1,18],\"329\":[1,59],\"330\":[1],\"331\":[1],\"332\":[1],\"333\":[1],\"334\":[1,2],\"335\":[1,44],\"336\":[1,78],\"337\":[1],\"338\":[1],\"339\":[1],\"340\":[1,3],\"341\":[1,11],\"342\":[1,46],\"343\":[1,59],\"344\":[1,44],\"345\":[1,72],\"346\":[1,82],\"347\":[1,140],\"348\":[1,33],\"349\":[1],\"350\":[1,54],\"351\":[1,91],\"352\":[1,69],\"353\":[1],\"354\":[2,7],\"355\":[2],\"356\":[1],\"357\":[1],\"358\":[1],\"359\":[1,49],\"360\":[1,46],\"361\":[1,1],\"362\":[1],\"363\":[1],\"364\":[2],\"365\":[1],\"366\":[1],\"367\":[1,3],\"368\":[1],\"369\":[1,6],\"370\":[5,10],\"371\":[5,5],\"372\":[1,12],\"373\":[5,11],\"374\":[1,39],\"375\":[3,16],\"376\":[3,30],\"377\":[3,47],\"378\":[3,61],\"379\":[4,55],\"380\":[3,44],\"381\":[1],\"382\":[2],\"383\":[1],\"384\":[1],\"385\":[1,7],\"386\":[1,18],\"387\":[1],\"388\":[2],\"389\":[2],\"390\":[2],\"391\":[2],\"392\":[2],\"393\":[1],\"394\":[2],\"395\":[2],\"396\":[2],\"397\":[1,1],\"398\":[1],\"399\":[1,73],\"400\":[1,1],\"401\":[1,2],\"402\":[1],\"403\":[1],\"404\":[1],\"405\":[1],\"406\":[1],\"407\":[1],\"408\":[1],\"409\":[1],\"410\":[1],\"411\":[1],\"412\":[1],\"413\":[1],\"414\":[1],\"415\":[1],\"416\":[1,1],\"417\":[1,1],\"418\":[1],\"419\":[1,39],\"420\":[1,1],\"421\":[1,5],\"422\":[1],\"423\":[1,1],\"424\":[1,3],\"425\":[1],\"426\":[1,15],\"427\":[1,30],\"428\":[1,8],\"429\":[1,3],\"430\":[1,5],\"431\":[1,12],\"432\":[1,4],\"433\":[1,42],\"434\":[1],\"435\":[1],\"436\":[1],\"437\":[1],\"438\":[1],\"439\":[1],\"440\":[1],\"441\":[1],\"442\":[1],\"443\":[1],\"444\":[1],\"445\":[1],\"446\":[1],\"447\":[1],\"448\":[1],\"449\":[1],\"450\":[1],\"451\":[1],\"452\":[1],\"453\":[1],\"454\":[1],\"455\":[1],\"456\":[1],\"457\":[1],\"458\":[1],\"459\":[1],\"460\":[1],\"461\":[1],\"462\":[1],\"463\":[1],\"464\":[1],\"465\":[1],\"466\":[1],\"467\":[1],\"468\":[1],\"469\":[1],\"470\":[1]},\"averageFieldLength\":[1.1740976645435244,25.731254623988455],\"storedFields\":{\"0\":{\"h\":\"\"},\"1\":{\"h\":\"Hello I am huhx\"},\"2\":{\"h\":\"Dart中的新特性\",\"t\":[\"dart中的新特性\"]},\"3\":{\"h\":\"如何编写Flutter plugins\",\"t\":[\"关于如何编写Flutter plugins\"]},\"4\":{\"h\":\"Flutter中的新特性\",\"t\":[\"dart中的新特性\"]},\"5\":{\"h\":\"kotlin中的scope function\",\"t\":[\"In kotlin\"]},\"6\":{\"h\":\"初探Kafka的世界\",\"t\":[\"kafka简介\"]},\"7\":{\"h\":\"DDD在spring项目的实战\",\"t\":[\"DDD在spring项目的实战\"]},\"8\":{\"h\":\"深入了解CQRS\",\"t\":[\"一文了解CQRS\"]},\"9\":{\"h\":\"浅尝辄止DDD\",\"t\":[\"一文了解DDD\"]},\"10\":{\"h\":\"什么是设计模式\",\"t\":[\"什么是设计模式\"]},\"11\":{\"h\":\"命令行之神Cobra\"},\"12\":{\"h\":\"cobra\"},\"13\":{\"h\":\"cobra-cli\",\"t\":[\"# install go install github.com/spf13/cobra-cli@latest # 如果执行安装了，cobra-cli command not found，对么参考：https://github.com/spf13/cobra/issues/1964 # create repo mkdir demo && cd demo # download dependencies go mod init demo go mod tidy # more cobra-cli init --author \\\"huhx\\\" --viper --license apache touch $HOME/.demo.yaml # add command cobra-cli add team cobra-cli add create -p 'teamCmd' \"]},\"14\":{\"h\":\"flags\",\"t\":[\"// 1. Working with Flags Persistent Flags: rootCmd.PersistentFlags().BoolVarP(&Verbose, \\\"verbose\\\", \\\"v\\\", false, \\\"verbose output\\\") Local Flags: localCmd.Flags().StringVarP(&Source, \\\"source\\\", \\\"s\\\", \\\"\\\", \\\"Source directory to read from\\\") // 2. Required flags rootCmd.Flags().StringVarP(&Region, \\\"region\\\", \\\"r\\\", \\\"\\\", \\\"description\\\") rootCmd.MarkFlagRequired(\\\"region\\\") // 3. groups // must be provided together or none of them rootCmd.Flags().StringVarP(&u, \\\"username\\\", \\\"u\\\", \\\"\\\", \\\"Username (required if password is set)\\\") rootCmd.Flags().StringVarP(&pw, \\\"password\\\", \\\"p\\\", \\\"\\\", \\\"Password (required if username is set)\\\") rootCmd.MarkFlagsRequiredTogether(\\\"username\\\", \\\"password\\\") // either --json or --yaml but never both rootCmd.Flags().BoolVar(&ofJson, \\\"json\\\", false, \\\"Output in JSON\\\") rootCmd.Flags().BoolVar(&ofYaml, \\\"yaml\\\", false, \\\"Output in YAML\\\") rootCmd.MarkFlagsMutuallyExclusive(\\\"json\\\", \\\"yaml\\\") \"]},\"15\":{\"h\":\"auto completion\",\"t\":[\"zsh\",\"echo \\\"autoload -U compinit; compinit\\\" >> ~/.zshrc ./rbctl completion zsh > \\\"${fpath[1]}/_rbctl\\\" \"]},\"16\":{\"h\":\"inside cobra\"},\"17\":{\"h\":\"viper\"},\"18\":{\"h\":\"inside viper\"},\"19\":{\"h\":\"FAQ\"},\"20\":{\"h\":\"总结\"},\"21\":{\"h\":\"参考\"},\"22\":{\"h\":\"oss图片迁移实战\"},\"23\":{\"h\":\"aliyun-oss sdk\"},\"24\":{\"h\":\"viper config\",\"t\":[\"current: local local: path: name: remote: bucket: key-id: key-secret: \"]},\"25\":{\"h\":\"cobra\",\"t\":[\"oss: local: list get remote: list get migrate: \"]},\"26\":{\"h\":\"liveness和readiness\",\"t\":[\"liveness和readiness\"]},\"27\":{\"h\":\"学习terraform\",\"t\":[\"学习terraform\"]},\"28\":{\"h\":\"2022回忆之旅\"},\"29\":{\"h\":\"幸福的婚姻\"},\"30\":{\"h\":\"顺利的工作\"},\"31\":{\"h\":\"未来的展望\"},\"32\":{\"h\":\"装修的心理历程\"},\"33\":{\"h\":\"在TW的这五年\"},\"34\":{\"h\":\"在科蓝的这两年\"},\"35\":{\"h\":\"我的职业生涯\"},\"36\":{\"h\":\"注解Annotation\",\"t\":[\"注解是众多引入到Java SE5中的重要的语言变化之一。它为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。今天我们就开始学习一下java中注解的知识。\"]},\"37\":{\"h\":\"注解\",\"t\":[\"java内置了三种标准注解，以及四种元注解。元注解专职负责注解其他的注解。\",\"标准注解：@Override、@Deprecated、@Suppresswarnings\",\"@Override：表示当前的方法定义将覆盖超类中的方法。如果你不小心拼写错误，或者方法签名对不上被覆盖的方法，编译器就会发出错误提示。\",\"@Deprecated：如果程序使用了注解为它的元素，那么编译器会发出警告信息。\",\"@Suppresswarnings：关闭不当的编译器警告信息。\",\"元注解：@Target、@Retention、@Documented、@Inherited。\",\"@Target：表示该注解可以用于什么地方，可选的参数有CONSTRUCTOR、FIELD、LOCAL_VARLABLE、METHOD、PACKAGE、PARAMETER、TYPE\",\"@Retention：表示需要在什么级别保存该注解信息，可选的参数有SOURCE、CLASS、RUNTIME\",\"@Documented：将此注解包含在javadoc中\",\"@Inherited：允许子类继承父类中的注解 |\"]},\"38\":{\"h\":\"FAQ\"},\"39\":{\"h\":\"总结\"},\"40\":{\"h\":\"参考\"},\"41\":{\"h\":\"让人抓狂的Exception\",\"t\":[\"现实生活中人们可能是谈虎色变，而在java的世界中能让人色变的可能就是这Exception了。\"]},\"42\":{\"h\":\"异常的介绍\"},\"43\":{\"h\":\"函数式编程\",\"t\":[\"千呼万唤始出来，Java 8终于引入了对函数式编程的支持。函数式编程是一种编程范式，它将计算视为数学函数的计算，使代码更加简洁、易于理解和维护。\"]},\"44\":{\"h\":\"函数式编程\",\"t\":[\"在java.util.function中，包含了大量的函数式的接口。其中就有我们熟悉的Function和Supplier，这些基本上满足了开发日常的需要。这些接口中的每一个都是通用且抽象的，使得它们很容易适应几乎任何lambda表达式。\"]},\"45\":{\"h\":\"什么是函数接口\",\"t\":[\"上面提到的接口有一个共性，那就是加上了@FunctionalInterface且只有一个abstract方法。比如\",\"@FunctionalInterface public interface Consumer<T> { void accept(T t); default Consumer<T> andThen(Consumer<? super T> after) { Objects.requireNonNull(after); return (T t) -> { accept(t); after.accept(t); }; } } \",\"查看jdk的文档可知，一个接口是函数式的需要满足特定的条件：该接口有且只有一个抽象方法。\",\"关于函数接口需要注意以下几点\",\"函数式接口是允许有default method的，因为default method是有实现的不是abstract的\",\"如果接口满足函数式接口的规则，那么就算没有@FunctionalInterface，它也被编译器当成函数式接口\",\"类似于@Override注解，只要你的函数符合重载的要求，无论你是否标注了@Override，编译器都会识别这个重载函数\",\"那么作为一个函数接口，它跟其他普通接口有什么优势或者区别呢？\",\"函数接口只有一个抽象方法，如果接口标注了@FunctionalInterface，且有多个抽象方法，那编译报错\",\"函数接口的实例可以通过Lambda表达式、方法引用和构造函数引用来创建\",\"好了，到了函数接口创建的环节了，正好也可以看看Lambda表达式、 方法引用和构造函数引用这些具体是什么。\"]},\"46\":{\"h\":\"函数接口的创建\"},\"47\":{\"h\":\"Lambda表达式\",\"t\":[\"Lambda表达式(lambda expressions)是Java 8最显著的函数式编程特性之一。它们允许您以更简洁的方式传递匿名函数，从而减少了冗余的代码。Lambda表达式的语法如下\",\"(parameter_list) -> { body } \",\"例如，对一个整数列表进行排序可以使用Lambda表达式如下：\",\"List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6, 5, 3); numbers.sort((a, b) -> a.compareTo(b)); \"]},\"48\":{\"h\":\"方法引用\",\"t\":[\"方法引用(method references)是Lambda表达式的一种简写形式，它允许您直接引用现有方法或构造函数作为Lambda表达式。Java 8提供了四种类型的方法引用\",\"静态方法引用: 使用类名::静态方法名的方式引用静态方法\",\"实例方法引用: 使用实例对象::实例方法名的方式引用实例方法。\",\"类的实例方法引用: 使用类名::实例方法名的方式引用类的任意对象的实例方法\",\"构造函数引用: 使用类名::new的方式引用类的构造方法\",\"例如\",\"List<String> names = Arrays.asList(\\\"Alice\\\", \\\"Bob\\\", \\\"Charlie\\\"); names.forEach(System.out::println); // 实例方法引用 \"]},\"49\":{\"h\":\"构造函数引用\",\"t\":[\"构造函数引用(constructor references)是一种简化构造函数调用的方法，它允许您将构造函数本身作为Lambda表达式传递。构造函数引用主要用于以下情况：\",\"创建新对象：您可以使用构造函数引用来创建新的对象，而无需显式地编写构造函数的调用。\",\"与函数式接口结合：构造函数引用可以与函数式接口结合使用，例如Supplier，Function等。\",\"下面是构造函数引用的示例：\",\"以上就是关于函数接口实例的创建了，既然java 8自带了些开箱即用的函数式接口，那我们就去瞅瞅呗\"]},\"50\":{\"h\":\"java函数式接口\",\"t\":[\"java.util.function包提供的函数式接口有很多，确实给开发带来了很大的便利。下面我们来讲下比较通用的几个，它们分别是Function、Consumer、Predicate和Supplier。\"]},\"51\":{\"h\":\"Function：接受参数，有返回参数\",\"t\":[\"package com.linux.huhx.function; import java.util.function.Function; public class FunctionDemo { private static int operateValue(int value, Function<Integer, Integer> function) { return function.apply(value); } private static int operateValue(int value, Function<Integer, Integer> srcFunc, Function<Integer, Integer> destFunc) { return srcFunc.andThen(destFunc).apply(value); } public static void main(String[] args) { int value = 10; int lambdaResult = operateValue(value, t -> t + 20); System.out.println(lambdaResult); // 30 int andThenResult = operateValue(value, val -> val + 20, val -> val + 30); System.out.println(andThenResult); // 60 } } \"]},\"52\":{\"h\":\"Consumer：接受参数，没有返回\",\"t\":[\"package com.linux.huhx.function; import java.util.function.Consumer; public class ConsumerDemo { private static void printValue(String value, Consumer<String> consumer) { consumer.accept(value); } public static void main(String[] args) { printValue(\\\"huhx\\\", s -> System.out.println(s.toUpperCase())); // HUHX } } \"]},\"53\":{\"h\":\"Predicate：接受参数，返回boolean\",\"t\":[\"package com.linux.huhx.function; import java.util.function.Predicate; public class PredicateDemo { private static boolean predicateValue(int value, Predicate<Integer> predicate) { return predicate.test(value); } public static void main(String[] args) { System.out.println(predicateValue(17, x -> x >= 18)); // false } } \"]},\"54\":{\"h\":\"Supplier：不接受参数，有返回值\",\"t\":[\"package com.linux.huhx.function; import java.util.function.Supplier; import org.springframework.util.StringUtils; public class SupplierDemo { private static String getOrDefault(String value, Supplier<String> supplier) { return StringUtils.isEmpty(value) ? supplier.get() : value; } public static void main(String[] args) { String name = \\\"\\\"; System.out.println(getOrDefault(name, () -> \\\"huhx\\\")); // huhx } } \"]},\"55\":{\"h\":\"FAQ\"},\"56\":{\"h\":\"Lambda为什么不能抛出异常?\",\"t\":[\"Lambda表达式在Java 中不能抛出已检查异常(checked exception)的原因与Java 8引入Lambda表达式时的设计哲学有关，主要是为了简化函数式编程的语法和提高代码的可读性。\"]},\"57\":{\"h\":\"总结\"},\"58\":{\"h\":\"参考\"},\"59\":{\"h\":\"数字是咋个存储的\",\"t\":[\"数乃万物之理，了解数字，就是掌握真理。都知道数字在计算机中是二进制存储的，但是具体到存储细节可能让很多程序员犯难了。这里我们就深耕细节，展开介绍下整数及浮点数在java虚拟机的表示。\"]},\"60\":{\"h\":\"概念介绍\",\"t\":[\"计算机的信息都是以二进制形式表示的，数值也不例外。数有正负之分，那就把最高位存放符号位呗(0为正，1为负)，这诞生了原码。\"]},\"61\":{\"h\":\"什么是原码\",\"t\":[\"所谓原码，就是符号位加上数字的二进制表示，其中符号位1表示负数，0表示正数。比如说该整数类型的位数是8，那么原码能够表示该整数类型数值的范围就是：(-27+1) ~ (27−1) => (-127 ~ 127)\",\"好了，数值有了在计算机中的表示方法，那么就可以对数值进行算术运算了。但是很快就发现原码进行乘除运算时还好，在加减运算的时候就出现了幺蛾子。\",\"假定一个数是8位，我们来看看1 - 1的计算过程：\",\"1 - 1 = 1 + (-1) 00000001(原码) + 10000001(原码) = 10000010(原码) => -2 \",\"这就尴尬了，计算机连最简单的1 - 1都能算错🙄。那让它算下 1 + 1？\",\"00000001(原码) + 00000001(原码) = 00000010(原码) => 2 \",\"好吧，没问题。事实上对于正数的加法运算中原码是完全ok的，问题就出现在带符号位的负数身上。于是，人们为了解决这个问题，就发明了....\"]},\"62\":{\"h\":\"什么是反码\",\"t\":[\"对，没错，就是反码。反码对于正数就是原码本身，对于负数则在原码的基础上，符号位不变，其余位取反。好的，那来验证下上面的两个运算：\",\"// 1 - 1 1 - 1 = 1 + (-1) 00000001(反码) + 11111110(反码) = 11111111(反码) = 10000000(原码) = -0 // 有些小问题 // 1 + 1 00000001(反码) + 00000001(反码) = 00000010(反码) = 00000010(原码) = 2 // ok \",\"这一次加减法是没啥子问题，但是有瑕疵，那就是出现在0这个特殊数值上。+0和-0虽说数值是一样的，但是给0带上符号是没意义的。而且0的编码表示还存在两种: 10000000(-0)和00000000(+0)。好了，人们还是接受不了0的这个问题，于是补码粉墨登场😎\"]},\"63\":{\"h\":\"什么是补码\",\"t\":[\"什么是补码？简单来说：负数的补码就是反码加1，整数的补码就是原码本身。那使用补码再来看看上面的1 - 1的计算\",\"// 1 - 1 1 - 1 = 1 + (-1) 00000001(补码) + 11111111(补码) = 00000000(补码) = 00000000(原码) = 0 \",\"那关于0的补码表示呢？\",\"如果0是正数，补码为原码本身：00000000\",\"如果0是负数，原码是10000000，反码为11111111，补码为反码加上则是00000000\",\"这样补码中0的表示就只有一种: 00000000，之前说的-0则不存在了，而且补码中的10000000还可以表示最低数-128，这样8位的数值范围就是：(-128 ~ 127)\",\"数值的表示总算尘埃落定，补码不负众望，成为了计算机中的数值表示。\",\"Info\",\"原码是最符合人直观的数值二进制表示，但是存在减法运算的问题\",\"反码在原码基础之上，解决了减法运算的问题，但是又存在0有两个编码的问题\",\"补码在反码基础之上，解决了0有两个编码的问题，也多出了一个编码表示最低数。同时也简化整数的加减法计算，将减法视为加法，实现加减法的统一\",\"好了，我们讲了数值二进制的几种编码，原码、反码和补码。那具体到java中，又是有哪些的不同呢？\"]},\"64\":{\"h\":\"整数的表示\",\"t\":[\"数值有大小之分，为了方便存储与计算效率，在java虚拟机中，整数分为byte,short,int和long四种，分别表示8位、16位、32位、64位有符号整数。java中是不存在无符号整数的，C语言是有的。具体如下：\",\"基本类型\",\"大小(bit)\",\"最小值\",\"最大值\",\"byte\",\"8\",\"-128\",\"127\",\"short\",\"16\",\"-215\",\"215 -1\",\"int\",\"32\",\"-231\",\"231 -1\",\"long\",\"64\",\"-263\",\"263 -1\",\"java中Integer和Long类型也提供了输出二进制补码的支持，拿Integer来说：\",\"Integer.toBinaryString(10); // 1010 Integer.toBinaryString(-10); // 11111111111111111111111111110110 \"]},\"65\":{\"h\":\"浮点数的表示\",\"t\":[\"在编程中，浮点类型数据主要用于表示小数的。对比于整数的表示，计算机表现小数的难点就在于小数点后面的数字了。浮点数在计算机中的表示是基于科学计数法的，只不过是二进制的而已。\",\"我们知道二进制表示整数的时候，最低位表示20，往高位依次是21,22,23,...,2n。那么对应的，对于二进制小数点的部分，最高位则是2−1,2−2,2−3,2−4,...,2−m。\",\"下面举几个例子：\",\"calculate\",\"十进制的7.125，用二进制表示是111.001。其实这种转换是存在些问题的，十进制不是无限循环小数的，转换成二进制就变成了无限循环小数。像上述例子中的0.6，表示成二进制之后成了循环体为1001的无限循环小数。而计算机底层无法精确存储那个无限循环二进制数的，只能存一个四舍五入的数值了，这就导致了浮点数精度不准确的问题。这种机制也直接说明了：对于金额这种对精度有要求的计算，可别用浮点数了。\",\"下面是java中的具体例子, float数值的比较和运算都有可能会出现问题：\",\"0.60000003f == 0.60000001f // true 0.1f + 0.11f // 0.21000001 \",\"下一步，将二进制表示为以2为底的科学计数法，如图：\",\"transform\",\"所以要存浮点数数，需要存储三个部分：正负号，尾数，指数。二进制的科学记数法表现形式如下\",\"value=flag∗m∗2n\",\"Info\",\"我们知道-32767这个数用科学计数法可以写成-3.2767×104，其中-表示符号，3.2767称为尾数，4称为指数。浮点数在计算机中的表示与此类似，只是它的基数是2而不是10。\",\"所以再看上面的公式：flag * m * 2n就容易得知，flag就是符号位，m就是尾数，n就是指数了，由于是二进制的科学计数法，此处的m的范围：1.0 <= m < 2.0,数值都是1点几了，1可以不存，只存小数点后面的数字了。\",\"知道了这三个是浮点数表示的重要组成部分，我们再来看下IEEE 754标准了，它是浮点数的主要存储方案。这一标准最早在1985年提出，基本上已经被用于所有计算机中。先后经历了几次更新，但浮点数的表示规则却从来没有变过。\",\"在IEEE 754的定义中，一个浮点数由3部分组成，分别是符号位、指数位和尾数位。Java中float和double两种类型的表示如下:\",\"类型\",\"符号位\",\"指数位\",\"尾数位\",\"总共\",\"float\",\"1\",\"8\",\"23\",\"32\",\"double\",\"1\",\"11\",\"52\",\"64\",\"对于指数部分，加上了编译量2n−1，所以对于8位的float类型，编译量就是127，相应的double类型就是1023。\",\"所以对于float类型的-7.5，我们来看看它的二进制存储是什么样的\",\"浮点数：-7.5f\",\"我们快速算下0.6的数值：\",\"浮点数：0.6f\",\"Java本身是平台无关的，它提供了统一的字节序视图，不受底层硬件的影响。Java虚拟机规定了所有数值类型的大端字节序。\",\"float浮点数还可以表示一些特殊的数字，如下：\",\"数值\",\"二进制表示\",\"正无穷\",\"0 11111111 00000000000000000000000\",\"负无穷\",\"1 11111111 00000000000000000000000\",\"NaN\",\"0 11111111 10000000000000000000000\",\"0\",\"0 00000000 00000000000000000000000\",\"最大正浮点数\",\"0 11111110 11111111111111111111111\",\"最小正浮点数\",\"0 00000000 00000000000000000000001\"]},\"66\":{\"h\":\"FAQ\"},\"67\":{\"h\":\"使用补码，怎么乘除法？\"},\"68\":{\"h\":\"字节序的大端模式与小端模式？\"},\"69\":{\"h\":\"浮点数正无穷与负无穷？\"},\"70\":{\"h\":\"浮点数为什么要加偏移量？\"},\"71\":{\"h\":\"总结\"},\"72\":{\"h\":\"参考资料\",\"t\":[\"ieee-standard-754-floating-point-numbers\"]},\"73\":{\"h\":\"测试你得这样写\",\"t\":[\"如何编写测试\"]},\"74\":{\"h\":\"List的不可变性\",\"t\":[\"Java提供了各种各样的方法来创建List，从简单的new ArrayList()到ArrayList.asList()，再到Collections.unmodifiableList，最后到Java 9中引入的List.copyOf方法。下面我们就List的可变性这个角度去分析以上List创建方法的特性以及区别。\"]},\"75\":{\"h\":\"ArrayList与asList\",\"t\":[\"在java中常见的创建List有两种方式，一种是new ArrayList() , 另一种是ArrayList.asList()\",\"两者返回值都是名为ArrayList的类，但是同名不同类，且两者都继承自AbstractList<E>类。可以简单看下AbstractList类的代码，可以知道它的add和remove 方法都未实现只是抛出异常。new ArrayList实现了父类AbstractList的add和remove方法，所以调用不会有异常。但是Arrays.asList却没有重写add和remove方法，因此调用会有异常！\",\"// AbstractList类中 public void add(int index, E element) { throw new UnsupportedOperationException(); } public E remove(int index) { throw new UnsupportedOperationException(); } \",\"上面提到的Arrays.asList是不允许add和remove，但是却可以调用set方法。下面我们来看看连set方法都不能调用的List.of\"]},\"76\":{\"h\":\"List.of的强不可变性\",\"t\":[\"有一个List的接口，在java9中引入了一些有用的static方法，用于创建不可变的List。\",\"static <E> List<E> of(E e1) { return new ImmutableCollections.List12<>(e1); } @SafeVarargs @SuppressWarnings(\\\"varargs\\\") static <E> List<E> of(E... elements) { switch (elements.length) { case 0: @SuppressWarnings(\\\"unchecked\\\") var list = (List<E>) ImmutableCollections.EMPTY_LIST; return list; case 1: return new ImmutableCollections.List12<>(elements[0]); case 2: return new ImmutableCollections.List12<>(elements[0], elements[1]); default: return ImmutableCollections.listFromArray(elements); } } \",\"我们直接查看ImmutableCollections.listFromArray方法的代码，如下\",\"static <E> List<E> listFromArray(E... input) { // copy and check manually to avoid TOCTOU @SuppressWarnings(\\\"unchecked\\\") E[] tmp = (E[])new Object[input.length]; // implicit nullcheck of input for (int i = 0; i < input.length; i++) { tmp[i] = Objects.requireNonNull(input[i]); } return new ListN<>(tmp, false); } \",\"最后把元素数组传递给一个名为ListN的类，这个类继承自AbstractImmutableList，因AbstractImmutableList类中add和set等方法都没有实现且抛出异常，所以由List.of创建出来的列表是不可变的，甚至于不能调用set方法。\",\"static abstract class AbstractImmutableList<E> extends AbstractImmutableCollection<E> implements List<E>, RandomAccess { // all mutating methods throw UnsupportedOperationException @Override public void add(int index, E element) { throw uoe(); } @Override public boolean addAll(int index, Collection<? extends E> c) { throw uoe(); } @Override public E remove(int index) { throw uoe(); } @Override public void replaceAll(UnaryOperator<E> operator) { throw uoe(); } @Override public E set(int index, E element) { throw uoe(); } @Override public void sort(Comparator<? super E> c) { throw uoe(); } } \",\"上面讲述的是不可变列表，它接收的参数是可变长度的元素。下面介绍如何将可变列表转换成不可变的列表\"]},\"77\":{\"h\":\"copyOf与unmodifiableList\",\"t\":[\"对比上述结果，可以看到两种方式都把可变列表转换成不可变的列表，也就是说新的列表不能使用add或者set等等可以修改列表的方法。但是有所区别的是，List.copyOf即使是原string列表做了修改，新的列表也没有影响。而对于unmodifiableList则不然，它随着旧的列表改变而改变。下面看下各自的源码，分析下原因：\",\"在unmodifiableList的方法中\",\"public static <T> List<T> unmodifiableList(List<? extends T> list) { if (list.getClass() == UnmodifiableList.class || list.getClass() == UnmodifiableRandomAccessList.class) { return (List<T>) list; } return (list instanceof RandomAccess ? new UnmodifiableRandomAccessList<>(list) : new UnmodifiableList<>(list)); } // 其中add, addAll, clear, remove, removeIf, removeAll, retainAll方法皆是抛出异常 \",\"在copyOf方法中\",\"static <E> List<E> copyOf(Collection<? extends E> coll) { return ImmutableCollections.listCopy(coll); } static <E> List<E> listCopy(Collection<? extends E> coll) { if (coll instanceof List12 || (coll instanceof ListN && ! ((ListN<?>)coll).allowNulls)) { return (List<E>)coll; } else { return (List<E>)List.of(coll.toArray()); // implicit nullcheck of coll } } \",\"通过对比可以得知：\",\"UnmodifiableRandomAccessList是继承自UnmodifiableList的，而在UnmodifiableList中维护了一个参数传递过来的List引用。 因为是引用，所以原列表的修改会反映到新的列表上面来。\",\"UnmodifiableList中的add和remove等可以修改列表的方法，皆是抛出异常，这就是新列表不可变的秘密所在\",\"从List.copyOf方法可以看到，最终的List对象还是交由List.of处理的。而在分析List.of方法时， 我们知道它是将列表参数放到一个新的数组里面传递给不可变List里面的，而不是原列表的引用。这也是上述原列表的修改没有反映到新的列表上的原因\",\"Tips\",\"虽说List.of是将列表参数放到一个新的数组而不是引用传递到不可变List，但是如果列表类型是Person对象这种的，修改Person里面的属性，还是会映射到新列表上面的。所以说List.copyOf只是浅拷贝\",\"下面给出一个示例来加以说明List.copyOf方法的特性：\",\"var books = new ArrayList<Book>(); var book = new Book(1L, \\\"Thinking in java\\\"); books.add(book); var list2 = List.copyOf(books); book.setTitle(\\\"Kotlin in action\\\"); System.out.println(books); // [Book(id=1, title=Kotlin in action)] System.out.println(list2); // [Book(id=1, title=Kotlin in action)] \"]},\"78\":{\"h\":\"Stream中的List\",\"t\":[\"Java 8开启了java函数式编程的新世界，同时也引入了Stream的流式操作，它提供了一种更便捷的方式来处理集合数据，如过滤、映射、排序等。\",\"Java 8引入的Collectors.toList()\",\"var list = List.of(\\\"a\\\", \\\"b\\\", \\\"c\\\"); var stringList = list.stream() .map(String::toUpperCase) .collect(Collectors.toList()); stringList.add(\\\"d\\\"); // 正常 System.out.println(list.size()); // 3 \",\"Collectors.toList方法其实返回的是new ArrayList()，然后这个list调用了addAll(oldList)方法把数据复制过来。返回之后的List行为和上述new ArrayList()别无二致\",\"Java 10中引入的Collectors.toUnmodifiableList()\",\"var stringList = List.of(\\\"a\\\", \\\"b\\\", \\\"c\\\").stream() .map(String::toUpperCase) .collect(Collectors.toUnmodifiableList()); stringList.add(\\\"d\\\"); // UnsupportedOperationException \",\"好吧，正如名字所言返回的是toUnmodifiableList，是不可修改的\",\"Java 16中Stream引入的toList()\",\"示例代码如下\",\"var stringList = List.of(\\\"a\\\", \\\"b\\\", \\\"c\\\").stream() .map(String::toUpperCase) .toList(); stringList.add(\\\"d\\\"); // UnsupportedOperationException \",\"这个方法是Stream接口的默认方法，实现代码如下:\",\"@SuppressWarnings(\\\"unchecked\\\") default List<T> toList() { return (List<T>) Collections.unmodifiableList(new ArrayList<>(Arrays.asList(this.toArray()))); } \",\"可以看到本质上和上面分析的Collections.unmodifiableList是一样的，具体参考: unmodifiableList\",\"Tips\",\"如果想Stream返回的是可修改的List，那么可以使用Collectors.toList()。否则如果是Java 16之后，返回不可修改的List，直接上toList方法\"]},\"79\":{\"h\":\"FAQ\"},\"80\":{\"h\":\"总结\"},\"81\":{\"h\":\"参考\"},\"82\":{\"h\":\"你心中的IO\",\"t\":[\"你心中的IO\"]},\"83\":{\"h\":\"Java小技巧\",\"t\":[\"如何编写更健壮更好的java代码？这里面整理收集一些在java开发过程中我们需要注意的一些点或者说是技巧，从而提高代码的质量以及我们的工作效率。\"]},\"84\":{\"h\":\"Springboot\"},\"85\":{\"h\":\"Ignore Null Fields with Jackson\",\"t\":[\"springboot中默认序列化Json的框架就是jackson了，这里面介绍在springboot项目中如何忽略null字段\",\"全局\",\"springboot配置和java代码都可以实现全局忽略null的功能\",\"类级别\",\"@JsonInclude(Include.NON_NULL) public class Person { ... } \",\"字段级别\",\"public class MyPersonDto { private String name; @JsonInclude(Include.NON_NULL) private String address; } \"]},\"86\":{\"h\":\"Java record类不能用作JPA实体\",\"t\":[\"A JPA entity class must:\",\"🔘 be non-final 🔘 have a no-arg constructor 🔘 have non-final fields \",\"A Record:\",\"❌ is final ❌ has one constructor with all fields ❌ has final fields \"]},\"87\":{\"h\":\"Docker\"},\"88\":{\"h\":\"docker远程Debug\",\"t\":[\"使用docker部署项目\",\"# 9094: 应用端口, 5005: 远程debug的端口，需要远程的服务器防火墙打开此接口 docker run -d -p 9094:9094 -p 5005:5005 \\\\ -e \\\"JAVA_TOOL_OPTIONS=\\\\\\\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005\\\\\\\"\\\" \\\\ --name demo_app demo_app:0.0.1-SNAPSHOT \",\"检查远程接口是否打开\",\"nc -vz 47.111.12.18 5005 \",\"输出的日志中带有Connection to .... successed就代表远程的5005接口是可以连通的。\",\"intellj配置Remote Jvm Debug\",\"# import thing is the JVM arguments -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005 \",\"debug配置\",\"本地和远程的源代码要保持一致，要不然本地的debug会不能工作。\",\"运行测试\",\"本地代码打上断点，在idea上面点击server debug以debug模式运行。访问远程的api，就会走到本地相应的断点。\"]},\"89\":{\"h\":\"Standard\"},\"90\":{\"h\":\"Boolean的短路评估\",\"t\":[\"&&: If the left operand is false, the right one isn’t called.\",\"||: If the left operand is true, the right one isn’t called.\",\"利用这个特性的话，在编写代码就可以通过变换表达式的位置或者提取方法来优化性能，比如\",\"总的原则就是把耗时的表达式滞后，如果表达式比较长的话，可以提取成函数。\"]},\"91\":{\"h\":\"静态方法的调用\",\"t\":[\"当通过 Java 中的空引用调用静态方法时，不会引发异常并且代码会运行。\",\"public class Main { public static void main(String[] args) { Greeting greeting = null; greeting.hello(); // Hello } } class Greeting { public static void hello() { System.out.println(\\\"Hello\\\"); } } \",\"静态方法属于类而不是实例，在编译时greeting.hello()变成Greeting.hello()。调用静态方法时始终使用类名，而不是实例。\"]},\"92\":{\"h\":\"枚举类的比较\",\"t\":[\"对于枚举判断相等，我们可以使用==或者equals方法\",\"使用==\",\"boolean isEnabled = accountStatus == Status.ENABLED; // true or false boolean isEnabled = \\\"string\\\" == Status.ENABLED; // compiler error \",\"如果accountStatus为null，上述可以工作。如果accountStatus不是一个枚举，那编译报错。\",\"使用equals\",\"将枚举常量放在左边，这样就可以避免空指针异常，但是没有类型的编译时检查。\",\"boolean isEnabled = Status.ENABLED.equals(accountStatus); // true or false boolean isEnabled = Status.ENABLED.equals(\\\"null\\\") // false，正常编译 \",\"Tips\",\"对于枚举判断相等，推荐使用==，因为它提供类型的编译时检查并且保证了null安全\"]},\"93\":{\"h\":\"Map的get方法为null的情况\",\"t\":[\"Map的get方法返回结果为null是有两种情况：\",\"The map does not contain the provided key\",\"The map does contain the key but its value is null\",\"所以说如果想要判断key在map中是否存在，建议使用contains(Object key)方法。另外Java 8中提供了getOrDefault(Object key, V defaultValue)，如果相应的key对应的值是null，那么返回defaultValue。\"]},\"94\":{\"h\":\"Stream中检查存在性\",\"t\":[\"Java 8中引入的Stream，方便了我们对Collection的操作。在检查Java流中是否存在时，使用anyMatch()而不是count() > 0\",\"// Stream has 10k objects // 2ms result = employees.stream().anyMatch(e -> e.isActive()); // 20ms result = employees.stream().fliter(e -> e.isActive()).count() > 0; \",\"Tips\",\"对比于count() > 0，使用anyMatch()更安全，性能也更好。因为anyMatch在检索过程中，如果发现有一个满足条件，就直接返回true了。而count() > 0撘配filter会检索整个Stream。\"]},\"95\":{\"h\":\"null的instanceof操作符\",\"t\":[\"如果对象为 null，instanceof运算符将返回false。\",\"// before if (object != null && object instanceof MyClass) {} // after: better if (object instanceof MyClass) {} \"]},\"96\":{\"h\":\"谨慎使用BigDecimal(double)构造\",\"t\":[\"BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。比如下面实际存储的值就是：0.100000001490116119384765625\",\"BigDecimal value = new BigDecimal (0.1f) \",\"优先推荐BigDecimal(String)的构造方法或使用BigDecimal.valueOf方法，此方法内部其实执行了Double的toString方法，而Double的toString按double的实际能表达的精度对尾数进行了截断。\",\"BigDecimal recommend1 = new BigDecimal(\\\"0.1\\\"); BigDecimal recommend2 = BigDecimal.valueOf(0.1); \",\"当涉及到金钱、对精度有要求的计算时，最好是使用BigDecimal，而不是使用Double或者Float。当然对比于运算速度，Bigdecimal是要慢些的。\",\"0.1d * 0.2d; // 0.020000000000000004 BigDecimal.valueOf(0.1d).multiply(BigDecimal.valueOf(0.2d)); // 0.02 \"]},\"97\":{\"h\":\"Java新特性\",\"t\":[\"java\"]},\"98\":{\"h\":\"Mocktio的使用\",\"t\":[\"在编写java代码，特别是spring web项目的时候，层级之间可能存在依赖，例如service可能依赖repository等等。所以当我们编写service测试时，就可能需要mock或者verify repository的行为，这个时候Mocktio库就派上用场了。\"]},\"99\":{\"h\":\"基础使用\",\"t\":[\"首先如果在项目中使用mocktio，需要引入相关依赖，以gradle构建工具为例，在build.gradle中\",\"testImplementation 'org.mockito:mockito-core:{version}' \",\"当然如果是使用springboot，默认引入的starter-test中就已经包含了mocktio-core，就不需要再显示的添加mocktio-core依赖了。\",\"testImplementation 'org.springframework.boot:spring-boot-starter-test' \",\"Mocktio有很多的注解可供我们使用，常见的有@Mock、@Spy和@InjectMocks。这些注解可以帮助我们在测试中创建模拟对象、注入模拟对象和捕获方法参数等，在一定程度上提高测试的可读性和可维护性，并简化测试代码的编写。\"]},\"100\":{\"h\":\"Enable Mocktio的注解\",\"t\":[\"一般在测试项目中，我们在需要用到mocktio测试的class上面添加以下注解，它的作用是在测试中启用Mockito注解的支持。\",\"@ExtendWith(MockitoExtension.class) \",\"如果是Junit4，那么使用@RunWith(MockitoJUnitRunner.class)注解。如果是JUnit5，则选择@ExtendWith(MockitoExtension.class)\",\"这样在测试中我们就可以使用mocktio的注解了，例如\",\"@ExtendWith(MockitoExtension.class) class TeamAppServiceTest { @Mock private TeamRepository teamRepository; @Mock private TeamProperties properties; @InjectMocks private TeamAppService teamAppService; @Test void should_return_response_with_id_given_requested_team_not_existed() { var createTeamRequest = buildCreateTeamRequest(); when(teamRepository.findByName(TEAM_NAME)).thenReturn(Optional.empty()); when(teamRepository.save(any(Team.class))).thenReturn(buildTeam()); when(properties.environment()).thenReturn(ENVIRONMENT); var result = teamAppService.create(createTeamRequest); assertThat(result.getId()).isEqualTo(ID); } } \"]},\"101\":{\"h\":\"常见的mocktio用法\",\"t\":[\"我们创建一个名为MyList的类作为示例来说明mocktio的用法\",\"public class MyList extends AbstractList<String> { @Override public String get(final int index) { return null; } @Override public int size() { return 1; } } \",\"mock对象方法的返回\",\"var listMock = mock(MyList.class); when(listMock.add(anyString())).thenReturn(false); boolean added = listMock.add(\\\"any string\\\"); assertThat(added).isFalse(); \",\"mock对象方法返回的另一种写法\",\"var listMock = mock(MyList.class); doReturn(false).when(listMock).add(anyString()); boolean added = listMock.add(randomAlphabetic(6)); assertThat(added).isFalse(); \",\"至于doReturn和thenReturn的区别，可以参考引用\",\"mock对象方法抛出异常\",\"var listMock = mock(MyList.class); when(listMock.add(anyString())).thenThrow(IllegalStateException.class); assertThrows(IllegalStateException.class, () -> listMock.add(\\\"any string\\\")); \",\"mock对象void方法抛出异常\",\"var listMock = mock(MyList.class); doThrow(NullPointerException.class).when(listMock).clear(); assertThrows(NullPointerException.class, () -> listMock.clear()); \",\"至于thenThrow和doThrow的区别，可以参考引用\",\"mock对象方法多次调用\",\"var listMock = mock(MyList.class); when(listMock.add(anyString())) .thenReturn(false) .thenThrow(IllegalStateException.class); assertThrows(IllegalStateException.class, () -> { listMock.add(\\\"any string 1\\\"); listMock.add(\\\"any string 2\\\"); }); \",\"mock对象call真实的方法\",\"var listMock = mock(MyList.class); when(listMock.size()).thenCallRealMethod(); assertThat(listMock).hasSize(1); // MyList定义的size()方法的返回值是1 \"]},\"102\":{\"h\":\"Mocktio之capture\",\"t\":[\"当我们在想要测试某个方法被调用，而且想要verify方法参数内容的时候，ArgumentCaptor就派上用场了。它用于捕获和验证方法调用时传递的参数值，使用步骤如下\",\"创建ArgumentCaptor对象\",\"使用ArgumentCaptor.forClass方法创建ArgumentCaptor对象，并指定要捕获的参数类型。\",\"ArgumentCaptor<User> captor = ArgumentCaptor.forClass(User.class); \",\"Mocktio还提供了一种使用注解的方式来创建ArgumentCaptor，所以上述的captor的创建可以使用\",\"@Captor private ArgumentCaptor<User> captor; \",\"上述将创建一个用于捕获User对象的ArgumentCaptor\",\"设置方法调用和捕获参数\",\"使用Mockito的when方法设置方法调用，并通过captor.capture()方法捕获参数值\",\"userService.create(captor.capture()); \",\"上述将调用add方法并将传递的参数值捕获到captor对象中。\",\"验证参数值\",\"使用ArgumentCaptor的getValue方法获取捕获的参数值，并进行相应的验证\",\"assertThat(captor.getValue().getName()).isEqual(\\\"huhx\\\"); \",\"下面是一个完整的例子，演示了ArgumentCaptor的使用。测试例子中，用的是junit5和assertj框架\",\"我们已经演示了如何在Mocktio中使用captor了，接下来我们给出一个比较复杂的例子：multiple captor\",\"@PostMapping(\\\"/users\\\") public void createUsers() { userService.create(new User(\\\"huhx\\\")); userService.create(new User(\\\"linux\\\")); } \",\"在controller中会多次调用userService的create方法，并且每次参数还不一样。这个时候我们就可以使用captor的getAllValues方法。该方法用于获取捕获的所有参数值，返回值是List，其中包含了所有捕获的参数值的顺序。具体使用如下\",\"@Test void should_create_users() { userController.createUsers(); verify(userService, times(2)).create(captor.capture()); assertThat(captor.getAllValues().get(0).getName()) .isEqualTo(\\\"huhx\\\"); assertThat(captor.getAllValues().get(1).getName()) .isEqualTo(\\\"linux\\\"); } \",\"上述测试首先验证userService的create方法被调用两次，并且分别verify了两次调用参数的值。\",\"Tips\",\"getValue()返回的是参数列表中的最后一个值，getAllValues()返回的是整个参数列表。\"]},\"103\":{\"h\":\"Mocktio之静态mock\",\"t\":[\"在编写测试时，我们经常会遇到需要模拟静态方法的情况。在Mockito 3.4.0 版本之前，无法直接模拟静态方法，只能借助于PowerMockito库。在稍后的版本，mocktio推出了支持静态方法mock的mocktio-inline库，让mock变得从未如此简单。\",\"首先使用mocktio-inline替换之前的mocktio-core依赖，因为mocktio-inline已经依赖了mocktio-core\",\"testImplementation 'org.mockito:mockito-inline:{version}' \",\"关于如何使用，这边给出一个简单的示例\",\"public Instant save() { return Instant.now(); } @Test void should_test_save() { try (MockedStatic<Instant> instantMockedStatic = mockStatic(Instant.class)) { instantMockedStatic.when(Instant::now).thenReturn(TIMESTAMP); var instant = userService.save(); assertThat(instant).isEqualTo(TIMESTAMP); } } \",\"在上述示例中，我们使用mockStatic方法创建了一个MockedStatic对象，并通过when和thenReturn方法模拟了静态方法的返回值。\",\"Tips\",\"之所以使用try是因为只想静态的mock在try块中生效，在这之外Instant.now()的行为不再是mock的。MockedStatic实现了AutoCloseable接口，在try块的结束处，MockedStatic会有自动关闭的机制来清理静态mock。\"]},\"104\":{\"h\":\"方法分析\"},\"105\":{\"h\":\"常见问题\"},\"106\":{\"h\":\"doReturn和thenReturn的区别\",\"t\":[\"doReturn和thenReturn的区别\"]},\"107\":{\"h\":\"thenThrow和doThrow\",\"t\":[\"thenThrow和doThrow的区别\"]},\"108\":{\"h\":\"新版IO，NIO\",\"t\":[\"你心中的nio\",\"通道、缓冲区\\n网络IO\"]},\"109\":{\"h\":\"无所不能的正则\",\"t\":[\"正则基本上算是每个开发语言的标配，其重要性不言而谕。之所以正则经久不衰，主要在于它在文字处理方面展现出恐怖而全面的能力。今天我们就来了解下这个文字处理神器：正则表达式。\"]},\"110\":{\"h\":\"什么是正则表达式\",\"t\":[\"正则表达式是用字符串描述的一个匹配规则，它们可用于搜索、编辑或操作文本和数据。正则的实现百家争鸣，各个语言实现的版本具有差异化，常见的有grep、Perl、Tcl、Python、PHP和awk，但是不用过于担心基本上是大同小异。\",\"我们今天主要说的是java中的正则，它的风格算是跟Perl走得最为接近。java是面向对象的，表达正则肯定是用对象了。那么会有那些对象呢？\",\"关于正则，java是有一个叫java.util.regex包的。它里面涵盖了正则的所有要求，其中最为重要的莫过于：Pattern、Matcher和PatternSyntaxException\",\"Pattern: 正则表达式的编译表示，无构造函数。由带参数的静态函数创建\",\"public static Pattern compile(String regex) { return new Pattern(regex, 0); } public static Pattern compile(String regex, int flags) { return new Pattern(regex, flags); } \",\"构造函数有两个参数，regex表示要编译的表达式，flag表示匹配规则中的标志位(这个在后面会讲到)。\",\"Matcher: 是解释模式并对输入字符串执行匹配操作的引擎，也是无构造函数，由Pattern对象中的matcher方法生成\",\"var pattern = Pattern.compile(\\\"ab.\\\"); var matcher = pattern.matcher(\\\"abc\\\"); System.out.println(matcher.matches()); // true \",\"PatternSyntaxException: 是unchecked的异常，表示正则表达式模式中存在语法错误\",\"var pattern = Pattern.compile(\\\"[]\\\"); // java.util.regex.PatternSyntaxException: Unclosed character class near index 1 \",\"为了展开后面的学习，这里写一个正则表达式的程序用于测试：接收控制台的正则表达式和字符串输入，然后打印出匹配的字符串以及相应的index\",\"package com.huhx.regex; import java.util.regex.Pattern; public class RegexTestHarness { public static void main(String[] args) { var console = System.console(); if (console == null) { System.err.println(\\\"No console.\\\"); System.exit(1); } while (true) { var pattern = Pattern.compile(console.readLine(\\\"%nEnter your regex: \\\")); var string = console.readLine(\\\"Enter input string to search: \\\"); var matcher = pattern.matcher(string); boolean found = false; while (matcher.find()) { console.format(\\\"I found the text\\\" + \\\" \\\\\\\"%s\\\\\\\" starting at \\\" + \\\"index %d and ending at index %d.%n\\\", matcher.group(), matcher.start(), matcher.end()); found = true; } if (!found) { console.format(\\\"No match found.%n\\\"); } } } } \",\"在src目录下面，使用以下命令行编译和运行\",\"javac com/huhx/regex/RegexTestHarness.java java com.huhx.regex.RegexTestHarness \",\"regex harness\"]},\"111\":{\"h\":\"字符串文字\",\"t\":[\"正则最基本形式是字符串文字的匹配，比如说正则表达式为foo并且输入字符串为foo，那就是匹配了。\",\"Enter your regex: abc Enter input string to search: abcabcabc I found the text \\\"abc\\\" starting at index 0 and ending at index 3. I found the text \\\"abc\\\" starting at index 3 and ending at index 6. I found the text \\\"abc\\\" starting at index 6 and ending at index 9. \",\"按照约定，范围包含起始索引但不包含结束索引。所以第一个abc的匹配index为[0,3)。\",\"其中需要注意的是，正则表达式中定义了一些元字符。这些字符有着特殊的含义，比如说.表示任意字符\",\"Enter your regex: ab. Enter input string to search: abd I found the text \\\"abd\\\" starting at index 0 and ending at index 3. \",\"那么java中都有哪些类似的元字符呢？而如果我就是想把元字符当成普通字符来匹配又该如何是好呢？\",\"元字符有<([{\\\\^-=$!|]})?*+.>，而强制将元字符视为普通字符的方法有以下两种：\",\"元字符之前加一个反斜杠\\\\\",\"将元字符括在\\\\Q(开始引用)和\\\\E(结束引用)内\",\"Enter your regex: ab\\\\. Enter input string to search: abd No match found. Enter your regex: ab\\\\. Enter input string to search: ab. I found the text \\\"ab.\\\" starting at index 0 and ending at index 3. Enter your regex: ab\\\\Q.\\\\E Enter input string to search: abd No match found. Enter your regex: ab\\\\Q.\\\\E Enter input string to search: ab. I found the text \\\"ab.\\\" starting at index 0 and ending at index 3. Enter your regex: \\\\Qab.\\\\E Enter input string to search: ab. I found the text \\\"ab.\\\" starting at index 0 and ending at index 3. \",\"Tips\",\"\\\\Q和\\\\E可以放置在表达式内的任何位置，前提是\\\\Q在前面。\"]},\"112\":{\"h\":\"方括号内字符\",\"t\":[\"正则表达式构造\",\"描述说明\",\"[abc]\",\"a, b, or c (simple class)\",\"[^abc]\",\"Any character except a, b, or c (negation)\",\"[a-zA-Z]\",\"a through z, or A through Z, inclusive (range)\",\"[a-d[m-p]]\",\"a through d, or m through p: [a-dm-p] (union)\",\"[a-z&&[def]]\",\"d, e, or f (intersection)\",\"[a-z&&[^bc]]\",\"a through z, except for b and c: [ad-z] (subtraction)\",\"[a-z&&[^m-p]]\",\"a through z, and not m through p: [a-lq-z] (subtraction)\",\"方括号里面的字符是或关系的，比如说[ab]就是a或b都可以匹配。-表示范围(包含首尾字符)，比如[1-9]就是匹配的数字在1到9(包含1和9这两个字符)之间。而^表示否定关系的，比如[^ab]就是除了a和b之外所有的字符。而&&表示且的关系，[ab&&bc]就是ab和bc的交集，也就是b。\",\"下面给出一些例子：\",\"[0-4[6-8]]: 0, 1, 2, 3, 4, 6, 7 and 8\",\"[0-9&&[345]]: 3, 4, and 5\",\"[2-8&&[4-6]]: 4, 5, and 6\",\"[0-9&&[^345]]: 3, 4, and 5\"]},\"113\":{\"h\":\"预定义字符\",\"t\":[\"正则表达式构造\",\"描述说明\",\".\",\"Any character (may or may not match line terminators)\",\"\\\\d\",\"A digit: [0-9]\",\"\\\\D\",\"A non-digit: [^0-9]\",\"\\\\s\",\"A whitespace character: [ \\\\t\\\\n\\\\x0B\\\\f\\\\r]\",\"\\\\S\",\"A non-whitespace character: [^\\\\s]\",\"\\\\w\",\"A word character: [a-zA-Z_0-9]\",\"\\\\W\",\"A non-word character: [^\\\\w]\",\"预定义字符比较简洁，尽可能使用它，可以使您的代码更易于阅读并消除格式错误的字符类引入的错误。\",\"以反斜杠\\\\开头的结构称为转义结构。当我们使用\\\\d之类的，在字符串文字中使用转义构造，则必须在反斜杠前面加上另一个反斜杠才能编译字符串。至于原因，参考：String正则加反斜杠\",\"// 编译报错：Illegal escape character in string literal var pattern = Pattern.compile(\\\"\\\\d\\\"); // 正常编译：表示匹配一个数字 var pattern = Pattern.compile(\\\"\\\\\\\\d\\\"); \"]},\"114\":{\"h\":\"匹配次数量词\",\"t\":[\"很多情况下，我们会有对某些字符多次匹配的需求，比方说1212或者大大方方这类的叠词。这根本就难不倒正则，它提供了丰富的功能去满足这些字符多次匹配的需求。\",\"Greedy\",\"Reluctant\",\"Possessive\",\"Meaning\",\"X?\",\"X??\",\"X?+\",\"X, once or not at all\",\"X*\",\"X*?\",\"X*+\",\"X, zero or more times\",\"X+\",\"X+?\",\"X++\",\"X, one or more times\",\"X{n}\",\"X{n}?\",\"X{n}+\",\"X, exactly n times\",\"X{n,}\",\"X{n,}?\",\"X{n,}+\",\"X, at least n times\",\"X{n,m}\",\"X{n,m}?\",\"X{n,m}+\",\"X, at least n but not more than m times\",\"乍一看，X?, X??和X?+做完全相同的事情，因为它们都表示匹配X一次或根本不匹配。然而事实却没那么简单。\"]},\"115\":{\"h\":\"捕获组\",\"t\":[\"捕获组是将多个字符视为一个单元的一种方法。它们是通过将要分组的字符放在一组括号内来创建的。\"]},\"116\":{\"h\":\"组的编号\",\"t\":[\"在java中，捕获组通过从左到右计算其左括号来进行编号。\",\"例如，在表达式 ((A)(B(C)))中，有四个这样的组：\",\"((A)(B(C)))\",\"(A)\",\"(B(C))\",\"(C)\",\"Jdk还提供了组数的查询，调用Matcher对象的groupCount方法就可以。\",\"var matcher = Pattern.compile(\\\"((A)(B(C)))\\\").matcher(\\\"aaa\\\"); System.out.println(matcher.groupCount()); \",\"还有一个特殊的组，是group 0。因为它始终代表整个表达式，所以没有包含在groupCount方法的返回当中。以下是groupCount的源码：\",\"public int groupCount() { return parentPattern.capturingGroupCount - 1; } \",\"了解组的编号至关重要，后续就可以根据此编号来取某个组的匹配内容。Matcher类提供了一些以下有用的方法：\",\"public int start(int group) public int end(int group) public String group(int group) \"]},\"117\":{\"h\":\"反向引用\",\"t\":[\"与捕获组匹配的输入字符串部分保存在内存中，以便以后通过反向引用调用。反向引用在正则表达式中指定为反斜杠\\\\，后跟一个指示要调用的组编号的数字n。例如表达式 (\\\\d\\\\d)定义一个与一行中的两个数字匹配的捕获组，稍后可以通过反向引用\\\\1在表达式中调用该捕获组。\",\"如果想匹配类似于2323这种两个数字，后面跟相同的两个数字。正则表达式可以写成：(\\\\d\\\\d)\\\\1\",\"Enter your regex: (\\\\d\\\\d)\\\\1 Enter input string to search: 2323 I found the text \\\"2323\\\" starting at index 0 and ending at index 4. Enter your regex: (\\\\d\\\\d)\\\\1 Enter input string to search: 2324 No match found. \"]},\"118\":{\"h\":\"边界匹配\",\"t\":[\"到目前为止，我们只关心是否在特定输入字符串中的某个位置找到匹配项。我们从不关心比赛发生在字符串的哪个位置。\",\"您可以通过使用边界匹配器指定此类信息来使模式匹配更加精确。例如，也许您有兴趣查找某个特定单词，但前提是该单词出现在行首或行尾。或者您可能想知道匹配是否发生在单词边界上，或者发生在上一个匹配的末尾。\",\"Boundary Construct\",\"Description\",\"^\",\"The beginning of a line\",\"$\",\"The end of a line\",\"\\\\b\",\"A word boundary\",\"\\\\B\",\"A non-word boundary\",\"\\\\A\",\"The beginning of the input\",\"\\\\G\",\"The end of the previous match\",\"\\\\Z\",\"The end of the input but for the final terminator, if any\",\"\\\\z\",\"The end of the input\"]},\"119\":{\"h\":\"前瞻后顾\",\"t\":[\"Lookahead and Lookbehind Zero-Length Assertions，它匹配一些字符，但是并不包含匹配模式，只是确定是否匹配，也就是所谓的零宽。\",\"Lookahead: 使用?=，q(?=u)表示q后面必须是u，但匹配结果中不包含u(零宽)，同样的有负前瞻，使用?!，比如q(?!u)则表示q后面必须不是u。\",\"Lookbehind: 使用?<，(?<q)u表示u前面为q，但匹配结果不包含q(零宽)，同样的有负后顾，使用?<!，比如(?<!q)u则表示u前面必须不是q。\",\"下面是一些例子：\",\"abc(?=123) abc123 匹配，abc 123abc 不匹配 abc(?!123) abc123 不匹配 abc444 匹配，abc (?<abc)123 abc123 匹配，123 xyz123 不匹配 (?<!abc)123 abc123 不匹配 xyz123 匹配，123 \"]},\"120\":{\"h\":\"匹配标志位\"},\"121\":{\"h\":\"FAQ\"},\"122\":{\"h\":\"String表达式加反斜杠？\"},\"123\":{\"h\":\"总结\"},\"124\":{\"h\":\"参考\"},\"125\":{\"h\":\"理解Timezone\"},\"126\":{\"h\":\"一文看懂Timezone\",\"t\":[\"什么是timezone\",\"timezone的由来\",\"java中的timezone\",\"如何解决夏令时的问题\"]},\"127\":{\"h\":\"掌握junit5\",\"t\":[\"掌握junit5\",\"parameterized test: https://www.baeldung.com/parameterized-tests-junit-5\",\"junit-5-parallel: https://www.baeldung.com/junit-5-parallel-tests\"]},\"128\":{\"h\":\"AQS是何方神圣\",\"t\":[\"AbstractQueuedSynchronizer\"]},\"129\":{\"h\":\"VarHandle\"},\"130\":{\"h\":\"分析\",\"t\":[\"volatile + CAS原理\"]},\"131\":{\"h\":\"FAQ\"},\"132\":{\"h\":\"总结\"},\"133\":{\"h\":\"参考\"},\"134\":{\"h\":\"Atomic原子类\",\"t\":[\"Atomic翻译成中文是原子的意思，是指一个操作是不可中断的。在多个线程一起执行的时候，能够保证一个操作一旦开始，就不会被其他线程干扰。今天我们就来学习下java中自带的一些原子类。\"]},\"135\":{\"h\":\"使用\",\"t\":[\"原子类都存放在java.util.concurrent.atomic下，这里以 AtomicInteger 为例子来介绍\",\"AtomicInteger 类常用方法\",\" \"]},\"136\":{\"h\":\"分析\",\"t\":[\"AtomicInteger 类的部分源码：\",\"private static final Unsafe U = Unsafe.getUnsafe(); private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, \\\"value\\\"); private volatile int value; \",\"AtomicInteger类主要利用CAS (compare and swap) + volatile和native方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升\",\"CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的objectFieldOffset方法是一个本地方法，这个方法是用来拿到变量的内存地址。另外value是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。\"]},\"137\":{\"h\":\"Unsafe类\",\"t\":[\"Unsafe类似于C中的指针，compareAndSetInt方法是一个native方法：\",\"public class UnsafeMain { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException { // 通过反射的方式获取Unsafe var unsafeField = Unsafe.class.getDeclaredField(\\\"theUnsafe\\\"); unsafeField.setAccessible(true); var unsafe = (Unsafe) unsafeField.get(null); // 分配1024 bytes的直接内存，并把整数42写入此内存地址中 long memoryAddress = unsafe.allocateMemory(1024); unsafe.putInt(memoryAddress, 42); System.out.println(\\\"address = \\\" + Long.toHexString(memoryAddress)); // 从内存地址中读取整数 int value = unsafe.getInt(memoryAddress); System.out.println(\\\"value = \\\" + value); // 释放直接内存 unsafe.freeMemory(memoryAddress); } } \",\"输出结果如下：\",\"address = 7f7b4c844000 value = 42 \"]},\"138\":{\"h\":\"FAQ\"},\"139\":{\"h\":\"总结\"},\"140\":{\"h\":\"参考\"},\"141\":{\"h\":\"BlockingQueue\"},\"142\":{\"h\":\"使用\",\"t\":[\"如果BlockQueue是空的，从BlockingQueue取东西的操作将会被阻断进入等待状态，直到BlockingQueue进了东西才会被唤醒。同样如果BlockingQueue是满的，任何试图往里存东西的操作也会被阻断进入等待状态，直到BlockingQueue里有空间才会被唤醒继续操作。\",\"block-queue\",\"下面列举一个例子：\",\"public class BlockingQueueMain { static BlockingQueue<String> queue = new LinkedBlockingDeque<>(); public static void main(String[] args) throws InterruptedException { new Thread(new Producer()).start(); new Thread(new Consumer()).start(); new Thread(new Consumer()).start(); } static class Producer implements Runnable { @Override public void run() { for (int i = 0; i < 4; i++) { try { System.out.println(Thread.currentThread().getName() + \\\" start to put, time: \\\" + LocalDateTime.now()); var value = \\\"producer\\\" + i; queue.put(value); System.out.println(Thread.currentThread().getName() + \\\" put the value \\\" + value + \\\", time: \\\" + LocalDateTime.now()); } catch (InterruptedException e) { e.printStackTrace(); } } } } static class Consumer implements Runnable { @Override public void run() { for (int i = 0; i < 2; i++) { try { System.out.println(Thread.currentThread().getName() + \\\" start to take, time: \\\" + LocalDateTime.now()); System.out.println(Thread.currentThread().getName() + \\\" take the value \\\" + queue.take() + \\\", time: \\\" + LocalDateTime.now()); } catch (InterruptedException e) { e.printStackTrace(); } } } } } \",\"输出结果如下：\",\"Thread-1 start to take, time: 2023-09-08T15:22:09.366806 Thread-0 start to put, time: 2023-09-08T15:22:09.366780 Thread-2 start to take, time: 2023-09-08T15:22:09.366770 Thread-0 put the value producer0, time: 2023-09-08T15:22:09.384014 Thread-1 take the value producer0, time: 2023-09-08T15:22:09.384057 Thread-0 start to put, time: 2023-09-08T15:22:09.390801 Thread-1 start to take, time: 2023-09-08T15:22:09.390858 Thread-0 put the value producer1, time: 2023-09-08T15:22:09.390923 Thread-1 take the value producer1, time: 2023-09-08T15:22:09.390930 Thread-0 start to put, time: 2023-09-08T15:22:09.390977 Thread-0 put the value producer2, time: 2023-09-08T15:22:09.391050 Thread-2 take the value producer2, time: 2023-09-08T15:22:09.391060 Thread-0 start to put, time: 2023-09-08T15:22:09.391116 Thread-2 start to take, time: 2023-09-08T15:22:09.391151 Thread-0 put the value producer3, time: 2023-09-08T15:22:09.391177 Thread-2 take the value producer3, time: 2023-09-08T15:22:09.391239 \"]},\"143\":{\"h\":\"分析\",\"t\":[\"BlockingQueue是一个接口，它的实现有如下这几种：\",\"BlockingQueue\",\"其中比较常用的就是ArrayBlockingQueue和LinkedBiockingQueue。\",\"ArrayBlockingQueue是基于数组实现的，适合做有界队列。因为是数组，效率查询优于修改\",\"LinkedBlockingQueue是基于链表实现的，适合做无界队列或者比较大的队列。因为是链表，效率修改优于查询\",\"我们分析就使用ArrayBlockingQueue。\",\"final Object[] items; final ReentrantLock lock; private final Condition notEmpty; private final Condition notFull; \",\"ArrayBlockingQueue的初始化：\",\"public ArrayBlockingQueue(int capacity, boolean fair) { if (capacity <= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition(); } \",\"ArrayBlockingQueue的元素由items数组来维护。\",\"在put方法中\",\"public void put(E e) throws InterruptedException { Objects.requireNonNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == items.length) notFull.await(); enqueue(e); } finally { lock.unlock(); } } private void enqueue(E e) { final Object[] items = this.items; items[putIndex] = e; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal(); } \",\"与put相似的方法offer不会阻塞，如果当前队列己经满了，它就会立即返回false。如果没有满，则执行正常的入队操作。\",\"public boolean offer(E e) { Objects.requireNonNull(e); final ReentrantLock lock = this.lock; lock.lock(); try { if (count == items.length) return false; else { enqueue(e); return true; } } finally { lock.unlock(); } } \",\"而在take方法中\",\"public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == 0) notEmpty.await(); return dequeue(); } finally { lock.unlock(); } } private E dequeue() { final Object[] items = this.items; @SuppressWarnings(\\\"unchecked\\\") E e = (E) items[takeIndex]; items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; count--; if (itrs != null) itrs.elementDequeued(); notFull.signal(); return e; } \",\"与take相似的方法poll不会阻塞，如果当前队列为空，它就会立即返回null。如果不是空，则执行正常的出队操作。\",\"public E poll() { final ReentrantLock lock = this.lock; lock.lock(); try { return (count == 0) ? null : dequeue(); } finally { lock.unlock(); } } \"]},\"144\":{\"h\":\"FAQ\"},\"145\":{\"h\":\"总结\"},\"146\":{\"h\":\"BlockingQueue方法的总结\",\"t\":[\"操作\",\"异常\",\"返回值\",\"阻塞\",\"超时\",\"插入\",\"add(e)\",\"offer(e)\",\"put(e)\",\"offer(e, time, unit)\",\"删除\",\"remove()\",\"poll()\",\"take()\",\"poll(time, unit)\",\"检查\",\"element()\",\"peek()\",\"\\\\\",\"\\\\\",\"贴出add的方法\",\"public boolean add(E e) { if (offer(e)) return true; else throw new IllegalStateException(\\\"Queue full\\\"); } \"]},\"147\":{\"h\":\"BlockingQueue的使用场景\",\"t\":[\"BlockingQueue的使用场景\"]},\"148\":{\"h\":\"参考\"},\"149\":{\"h\":\"无锁宗师CAS\",\"t\":[\"为了线程间共享数据的安全性，我们引入了锁的机制。不管是synchronized内置锁还是重入锁，在高并发时，对锁的激烈竞争导致的线程等待很大程度上会影响性能。为此，人们想到了一种称为非阻塞同步的方法，这种方式不需要锁。它，就是我们今天要讲的CAS。\"]},\"150\":{\"h\":\"CAS\",\"t\":[\"CAS全称Compare And Swape，是一种比较并交换的算法。在硬件层面上，大多数处理器架构中，是已经支持原子化的CAS指令的。在JDK 1.5之后，虚拟机就可以使用这个指令了。\",\"CAS包含了3个操作数，它的形式为CAS(V, E, N)。其中V表示要更新的地址，E表示要比较的值，N表示新值。\",\"当V的值等于E时，V的值更新为N，返回的结果为V原有的值E\",\"当V的值不等于E时，说明有其它的线程做了更新，则当前线程就不做V值的更新。返回的结果是V的值\",\"CAS的操作是乐观的，因为它总是希望自己能够成功的执行更新操作。\",\"当多个线程尝试使用CAS更新同一个变量时，只有一个线程能够更新成功，其他线程都将更新失败。而且这些更新失败的线程并不会等待被挂起，而是被告知失败的结果。对于失败后的处理，线程可以自行处理。\",\"线程在竞争CAS失败时不会阻塞，它可以决定是否重试，或者执行一些恢复操作，或者啥都不干直接退出。把这种竞争失败的处理交由给开发人员，这种灵活性就大大减少了与锁相关的活跃性问题了(死锁和优先级反转等等)。\"]},\"151\":{\"h\":\"原子操作\",\"t\":[\"内存屏障？原子性是由硬件指令支持的，那内存的可见性呢？\"]},\"152\":{\"h\":\"工作原理\",\"t\":[\"Unsafe\"]},\"153\":{\"h\":\"优缺点\"},\"154\":{\"h\":\"ABA问题\"},\"155\":{\"h\":\"循环长开销大\",\"t\":[\"CAS的原子操作只能针对一个共享变量。\"]},\"156\":{\"h\":\"单个共享变量\"},\"157\":{\"h\":\"FAQ\"},\"158\":{\"h\":\"总结\"},\"159\":{\"h\":\"参考\"},\"160\":{\"h\":\"CLH锁\",\"t\":[\"https://www.infoq.cn/article/bvpvyvxjkm8zstspti0l\"]},\"161\":{\"h\":\"ConcurrentHashMap\"},\"162\":{\"h\":\"使用\",\"t\":[\"https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/\"]},\"163\":{\"h\":\"分析\"},\"164\":{\"h\":\"FAQ\"},\"165\":{\"h\":\"总结\"},\"166\":{\"h\":\"参考\"},\"167\":{\"h\":\"条件Condition\",\"t\":[\"Condition将Object监视器方法(wait、notify和notifyAll)分解成截然不同的对象，以便通过将这些对象与任意Lock实现组合使用，为每个对象提供多个等待set(wait-set)。其中，Lock替代了synchronized方法和语句的使用，Condition替代了Object监视器方法的使用。今天我们就通过实例来学习一个Condition的用法。\"]},\"168\":{\"h\":\"使用\",\"t\":[\"这里列举一个关于装水取水的例子:\",\"运行的结果如下：不固定\",\"p0 t0 t1 p1 p2 p3 p4 t2 t3 p5 p6 p7 t4 t5 p8 t6 p9 p10 t7 p11 t8 p12 t9 t10 t11 t12 t13 p13 p14 p15 t14 p16 t15 p17 t16 p18 t17 p19 t18 t19 \"]},\"169\":{\"h\":\"分析\"},\"170\":{\"h\":\"FAQ\"},\"171\":{\"h\":\"总结\",\"t\":[\"Condition可以替代wait和notify，Condition通过Lock对象获取\",\"Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); \"]},\"172\":{\"h\":\"参考\"},\"173\":{\"h\":\"CopyOnWriteArrayList\",\"t\":[\"ReadWriteLock这个锁是读写不能同时进行，java中提供的CopyOnWriteArrayList做的更狠，读与写可以同步进行，只是写与写之间会阻塞，这样就进一步的提高读取的性能了。而关于CopyOnWriteArrayList是怎么做到如此的，正是我们这里需要解答的。\"]},\"174\":{\"h\":\"使用\",\"t\":[\"当我们为CopyOnWriteArrayList创建迭代器时，我们会在调用iterator()时获得列表中数据的不可变快照。\",\"public class CopyOnWriteArrayListMain { public static void main(String[] args) throws InterruptedException { var list = new CopyOnWriteArrayList<>(List.of(\\\"0\\\")); var iterator = list.iterator(); list.add(\\\"1\\\"); iterator.forEachRemaining(System.out::println); System.out.println(Arrays.toString(list.toArray())); } } \",\"输出结果如下：\",\"0 [0, 1] \"]},\"175\":{\"h\":\"分析\",\"t\":[\"对于CopyOnWriteArrayList来说，读取是完全不用加锁的，并且更好的消息是：写入也不会阻塞读取操作，只有写入和写入之间需要进行同步等待。\",\"从这个类名字CopyOnWrite我们知道，所谓CopyOnWrite就是在写入操作时会进行一次自我复制。也就是说当这个List需要修改时，并不修改原有的内容，而是对原有的数据进行 一次复制，将修改的内容写入副本中。写完之后，再将修改完的副本替换原来的数据。这样就可以保证写操作不会影响读了\",\"有关读取的代码实现：\",\"private transient volatile Object[] array; final Object[] getArray() { return array; } static <E> E elementAt(Object[] a, int index) { return (E) a[index]; } public E get(int index) { return elementAt(getArray(), index); } \",\"读取代码没有任何同步控制和锁操作，就是普通的根据index取数组里面的元素。相对而言，对于写而言则较之复杂些：\",\"final transient Object lock = new Object(); public boolean add(E e) { synchronized (lock) { Object[] es = getArray(); int len = es.length; es = Arrays.copyOf(es, len + 1); es[len] = e; setArray(es); return true; } } \",\"写入操作首先得获取对象锁，然后对现有的列表A进行一次复制。对复制后的列表B进行相应的写入的操作，写入完成之后，再把列表B覆盖列表A。\"]},\"176\":{\"h\":\"FAQ\"},\"177\":{\"h\":\"总结\",\"t\":[\"CopyOnWriteArrayList合适读多写少的场景\",\"CopyOnWriteArrayList列表不应太大，因为每次写入会进行一次复制\"]},\"178\":{\"h\":\"参考\"},\"179\":{\"h\":\"倒计时器CountDownLatch\",\"t\":[\"CountDownLatch是JDK 5+里面闭锁的一个实现，允许一个或者多个线程等待某个事件的发生。今天我们通过一些实例来学习一下它的用法。\"]},\"180\":{\"h\":\"CountDownLatch的使用\",\"t\":[\"CountDownLatch被用来同步一个或多个线程，强制它们等待由其他线程执行的一组操作完成。你可以向CountDownLatch对象设置一个初始计数值，任何在这个对象上调用await()方法都将阻塞，直至这个计数值达到0。其他线程在结束工作时，可以在该对象上调用countDown()方法来减小这个计数值。\",\"CountDownLatch被设计为只触发一次，计数值不能被重置。如果你需要能够重置计数值的版本，则可以使用CyclicBarrier。\",\"count-down-latch\",\"只有等线程1、线程2和线程3中都运行结束后，才可以运行线程4。即一定数量的线程都完成工作后，才可以共同触发后续的一个或多个线程的开始工作。\",\"CountDownLatch的构建函数接收一个整数为参数，即当前这个计数器的计数个数。\",\"public CountDownLatch(int count) { if (count < 0) throw new IllegalArgumentException(\\\"count < 0\\\"); this.sync = new Sync(count); } \",\"其中的count其实就是: 线程可以通过等待之前必须调用countDown的次数。\",\"CountDownLatch中的方法：\",\"public void await() throws InterruptedException public boolean await(long timeout, TimeUnit unit) throws InterruptedException public void countDown() public long getCount() \",\"await: 导致当前线程等待，直到锁存器倒数为零或者线程被中断。带有参数的await方法多一种方式结束等待：指定的等待时间已过\",\"countDown: 递减锁存器的计数，如果计数达到零，则释放所有等待线程\",\"getCount: 返回当前计数，一般用于调度或者测试\",\"下面我们给出一个例子：阻止任何工人开始工作，直到司机准备好\",\"public class CountDownLatchTest { final static CountDownLatch startSignal = new CountDownLatch(1); final static CountDownLatch doneSignal = new CountDownLatch(5); public static void main(String[] args) throws Exception { for (int i = 0; i < 5; ++i) new Thread(new TaskWorker()).start(); startSignal.countDown(); System.out.println(\\\"Diver is ready, workers can start to work: \\\" + LocalDateTime.now()); TimeUnit.SECONDS.sleep(1); System.out.println(\\\"Diver is waiting for the workers done their works \\\" + LocalDateTime.now()); doneSignal.await(); System.out.println(\\\"Workers has done their works, Diver start the car. \\\" + LocalDateTime.now()); } private static class TaskWorker implements Runnable { @Override public void run() { try { startSignal.await(); System.out.println(\\\"Worker: \\\" + Thread.currentThread().getName() + \\\" done the work, time: \\\" + LocalDateTime.now()); doneSignal.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } } } } \",\"输出结果为：\",\"Diver is ready, workers can start to work: 2023-08-15T20:40:59.137129 Worker: Thread-0 done the work, time: 2023-08-15T20:40:59.137085 Worker: Thread-1 done the work, time: 2023-08-15T20:40:59.137092 Worker: Thread-3 done the work, time: 2023-08-15T20:40:59.137106 Worker: Thread-2 done the work, time: 2023-08-15T20:40:59.137088 Worker: Thread-4 done the work, time: 2023-08-15T20:40:59.137113 Diver is waiting for the workers done their works 2023-08-15T20:41:00.144588 Workers has done their works, Diver starts the car. 2023-08-15T20:41:00.145089 \",\"这里我们创建两个CountDownLatch：\",\"startSignal的计数量为1，可以当成是启动信号，阻止任何工人开始工作，直到驾驶员准备好让他们继续操作\",\"doneSignal的计数量为5，可以当成是完成信号，让驾驶员等待直到所有工作人员完成任务\",\"代码里面我们创建五个线程TaskWorker模拟五个工人，他们需要一直等待startSignal.await()直到驾驶员发送开始的信号。在main线程中startSignal.countDown()表示驾驶员发送了开始的信号。于是五个工人开始了工作(done the work...)，于此同时驾驶员在等待所有工人完成工作doneSignal.await()。\",\"工人完成自己的工作时，会告知驾驶员自己工作已完成的信号doneSignal.countDown()。当驾驶员收到所有工人完成工作的信号后，便开始启动了车辆扬长而去(Diver start the car)....\"]},\"181\":{\"h\":\"CountDownLatch的分析\"},\"182\":{\"h\":\"FAQ\"},\"183\":{\"h\":\"总结\"},\"184\":{\"h\":\"参考\"},\"185\":{\"h\":\"循环栅栓CyclicBarrier\",\"t\":[\"CyclicBarrier是另外一种多线程并发控制实用工具。和CountDownLatch非常类似，它也可以实现线程间的计数等待，但它的功能比CountDownLatch更加复杂且强大。\"]},\"186\":{\"h\":\"CyclicBarrier的使用\",\"t\":[\"CyclicBarrier适用于这样的情况：你希望创建一组任务，它们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成。类似于电商中的拼团、拼购，先准备购买的人必须等待，直到要购买的人数达到一定值时才开团。\",\"cyclic barrier\",\"只有4个线程都到达栅栏时，所有的线程才会被放行。先到的线程得等待后来的线程，直到最后一个线程到达。\",\"CyclicBarrier类有两个构造方法：\",\"public CyclicBarrier(int parties) { this(parties, null); } public CyclicBarrier(int parties, Runnable barrierAction) { if (parties <= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction; } \",\"parties：必须在栅栏处凑齐parties数目的线程后，才会将这些线程放行\",\"barrierAction: 凑齐parties数目的最后一个线程会在放行前运行一次barrierAction操作\",\"CyclicBarrier中主要的方法：\",\"public int await() throws InterruptedException, BrokenBarrierException public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException public int getNumberWaiting() \",\"await: 当线程到达栅栏时，需要调用该函数告知自己已经到达栅栏并开始等待。它的返回值是线程的到达顺序，最先到达的返回值parties - 1，最后到达的返回0。一旦返回0，则表示栅栏要放行了。\",\"getNumberWaiting: 返回当前在栅栏处等待的线程数量，主要用于调试和断言。\",\"下面我们举个例子来说明：只有运动员在跑道上面都准备好之后，才能起跑\",\"public class CyclicBarrierTest { final static CyclicBarrier barrier = new CyclicBarrier(3, () -> { System.out.println(Thread.currentThread().getName() + \\\": 大家都好了! \\\" + LocalDateTime.now()); }); public static void main(String[] args) throws IOException, InterruptedException { var executor = Executors.newFixedThreadPool(3); executor.submit(new Thread(new Runner(\\\"1号选手\\\"))); executor.submit(new Thread(new Runner(\\\"2号选手\\\"))); executor.submit(new Thread(new Runner(\\\"3号选手\\\"))); executor.shutdown(); } public static class Runner implements Runnable { private final String name; public Runner(String name) { super(); this.name = name; } @Override public void run() { try { Thread.sleep(new Random().nextInt(10000)); System.out.println(Thread.currentThread().getName() + \\\": \\\" + name + \\\" 准备好了! \\\" + LocalDateTime.now()); System.out.println(Thread.currentThread().getName() + \\\": \\\" + \\\"还有\\\" + barrier.await() + \\\"位没到达!\\\"); } catch (InterruptedException e) { e.printStackTrace(); } catch (BrokenBarrierException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \\\": \\\" + name + \\\" 起跑! \\\" + LocalDateTime.now()); } } } \",\"输出结果：\",\"pool-1-thread-2: 2号选手 准备好了! 2023-08-16T17:55:27.020934 pool-1-thread-3: 3号选手 准备好了! 2023-08-16T17:55:29.598635 pool-1-thread-1: 1号选手 准备好了! 2023-08-16T17:55:31.402894 pool-1-thread-1: 大家都好了! 2023-08-16T17:55:31.403166 pool-1-thread-1: 还有0位没到达! pool-1-thread-3: 还有1位没到达! pool-1-thread-2: 还有2位没到达! pool-1-thread-1: 1号选手 起跑! 2023-08-16T17:55:31.414811 pool-1-thread-3: 3号选手 起跑! 2023-08-16T17:55:31.414909 pool-1-thread-2: 2号选手 起跑! 2023-08-16T17:55:31.414989 \",\"上述例子模拟3名运动员(3个线程)，他们都需要花些时间热身做准备。当他们准备好后，会在赛道上面等待barrier.await()其他运动员，裁判员会统计赛道(栅栏)上面等待的人数。在裁判员统计到在场的所有3位运动员还未到齐之前，已经在赛道前的运动员都还只能在等待(线程状态WAITING)。\",\"最后一个运动员准备好之后，会执行CyclicBarrier第二个参数的逻辑(如果为null，就不用执行)。然后裁判员知道所有的运动员到齐之后，他一声枪响(线程放行)，运动员们便不再等待开始起跑(线程状态RUNNABLE)。\",\"从上述打印结果来看，3位运动员准备就绪的顺序是: 231，而起跑的顺序是: 132。\"]},\"187\":{\"h\":\"分析\"},\"188\":{\"h\":\"FAQ\"},\"189\":{\"h\":\"Guava里面的RateLimiter?\"},\"190\":{\"h\":\"总结\"},\"191\":{\"h\":\"参考\"},\"192\":{\"h\":\"交换器Exchanger\",\"t\":[\"线程之间的协作姿势千姿百态，如果两个线程之间的数据想要互换这该如何实现？对头，Exchanger就是为此而生的。它可以在两个线程之间交换数据，而且只能是2个线程，线程多了还不行。今天我们就通过实例来学习一下Exchanger的用法。\"]},\"193\":{\"h\":\"使用\",\"t\":[\"Exchanger是在两个任务之间交换对象的栅栏，当任务进入栅栏时，它们各自拥有一个对象。当他们离开时，它们都拥有之前由对方线程持有的对象。\",\"Exchanger\"]},\"194\":{\"h\":\"分析\",\"t\":[\"下面我们举个例子：两个人完成一笔交易，一手交钱，一手交货\",\"public class ExchangerTest { final static Exchanger<String> exchanger = new Exchanger<>(); public static void main(String[] args) { var executor = Executors.newCachedThreadPool(); executor.execute(() -> doExchangeWork(\\\"金钱\\\")); executor.execute(() -> doExchangeWork(\\\"货物\\\")); executor.shutdown(); } private static void doExchangeWork(String product) { try { System.out.println(Thread.currentThread().getName() + \\\" 正在把 \\\" + product + \\\" 给出去, time: \\\" + LocalDateTime.now()); Thread.sleep(new Random().nextInt(1000)); var receivedData = exchanger.exchange(product); System.out.println(Thread.currentThread().getName() + \\\" 得到 \\\" + receivedData + \\\", time: \\\" + LocalDateTime.now()); } catch (InterruptedException e) { e.printStackTrace(); } } } \",\"输出结果:\",\"pool-1-thread-1 正在把 金钱 给出去, time: 2023-08-16T21:16:30.403456 pool-1-thread-2 正在把 货物 给出去, time: 2023-08-16T21:16:30.403454 pool-1-thread-1 得到 货物, time: 2023-08-16T21:16:30.952205 pool-1-thread-2 得到 金钱, time: 2023-08-16T21:16:30.952462 \",\"当线程1调用Exchange对象的exchange()方法后，它会进入阻塞状态直到线程2也调用了exchange()方法，然后两线程以安全的方式交换彼此的数据，之后线程1和2继续运行。\"]},\"195\":{\"h\":\"FAQ\"},\"196\":{\"h\":\"总结\"},\"197\":{\"h\":\"参考\"},\"198\":{\"h\":\"分而治之Fork/Join\",\"t\":[\"在多核处理器时代，\"]},\"199\":{\"h\":\"使用\"},\"200\":{\"h\":\"分析\"},\"201\":{\"h\":\"FAQ\"},\"202\":{\"h\":\"总结\",\"t\":[\"Fork/Join是一种基于分治的算法：通过分解任务，并行执行，最后合并结果得到最终结果\",\"ForkJoinPool线程池可以把一个大任务分拆成小任务并行执行，任务类必须继承自RecursiveTask或RecursiveAction\",\"使用Fork/Join模式可以进行并行计算以提高效率\"]},\"203\":{\"h\":\"参考\"},\"204\":{\"h\":\"从数字递增看锁与无锁\"},\"205\":{\"h\":\"测试用例\",\"t\":[\"输出结果如下：\",\"并发量\",\"循环次数\",\"细粒度synchronized\",\"粗粒度synchronized\",\"AtomicInteger\",\"LongAdder\",\"10\",\"100000000\",\"66260\",\"6152\",\"21264\",\"1374\",\"100\",\"100000000\",\"52281\",\"5561\",\"22562\",\"1211\",\"1000\",\"100000\",\"3484\",\"514\",\"1827\",\"147\",\"10000\",\"100\",\"663\",\"497\",\"488\",\"511\",\"关于synchronized与ReentrantLock的比较，可以参考：\"]},\"206\":{\"h\":\"分析\"},\"207\":{\"h\":\"总结\"},\"208\":{\"h\":\"FAQ\"},\"209\":{\"h\":\"参考\"},\"210\":{\"h\":\"并发Liveness问题\",\"t\":[\"多个线程协同工作，总是会遇到一些莫名其妙的情况。有可能出现多个线程敌不动我不动的情形，都在等待对方线程做些什么。有的线程不积极抢不过其他线程，可能一直没机会得到调度。也有可能多个线程抢占某个资源，势均力敌互不相让，结果一直在拉扯不休。这些问题统称为并发的Liveness问题，下面我们就无情揭开它们的面纱。\"]},\"211\":{\"h\":\"死锁Deadlock\",\"t\":[\"死锁是多线程中最差的一种情况，多个线程相互占用对方的资源的锁，而又相互等对方释放锁，此时若无外力干预，这些线程则一直处理阻塞的假死状态，形成死锁。\",\"举个例子： A同学抢了B同学的钢笔，B同学抢了A同学的书，两个人都相互占用对方的东西，都在让对方先还给自己自己再还，这样一直争执下去等待对方还而又得不到解决。\",\"public class DeadLock { private static final Object lock1 = new Object(); private static final Object lock2 = new Object(); public static void main(String[] args) { var thread1 = new Thread(() -> { synchronized (lock1) { System.out.println(Thread.currentThread().getName() + \\\" get lock1\\\"); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(Thread.currentThread().getName() + \\\" need lock2\\\"); synchronized (lock2) { System.out.println(Thread.currentThread().getName() + \\\" get lock2\\\"); } } }); var thread2 = new Thread(() -> { synchronized (lock2) { System.out.println(Thread.currentThread().getName() + \\\" get lock2\\\"); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(Thread.currentThread().getName() + \\\" need lock1\\\"); synchronized (lock1) { System.out.println(Thread.currentThread().getName() + \\\" get lock1\\\"); } } }); thread1.start(); thread2.start(); } } \",\"输出结果：\",\"Thread-1 get lock2 Thread-0 get lock1 Thread-0 need lock2 Thread-1 need lock1 \"]},\"212\":{\"h\":\"死锁的排查\",\"t\":[\"执行上述的程序，然后使用jps -l\",\"64016 com.huhx.thread.liveness.DeadLock 64017 org.jetbrains.jps.cmdline.Launcher 2392 64460 jdk.jcmd/sun.tools.jps.Jps 88127 \",\"然后使用jstack 64016，然后可以看到包含如下的输出信息\",\"Java stack information for the threads listed above: =================================================== \\\"Thread-0\\\": at com.huhx.thread.liveness.DeadLock.lambda$main$0(DeadLock.java:20) - waiting to lock <0x000000070ffed740> (a java.lang.Object) - locked <0x000000070ffed730> (a java.lang.Object) at com.huhx.thread.liveness.DeadLock$$Lambda$14/0x0000000800c031f0.run(Unknown Source) at java.lang.Thread.run(java.base@18.0.2.1/Thread.java:833) \\\"Thread-1\\\": at com.huhx.thread.liveness.DeadLock.lambda$main$1(DeadLock.java:35) - waiting to lock <0x000000070ffed730> (a java.lang.Object) - locked <0x000000070ffed740> (a java.lang.Object) at com.huhx.thread.liveness.DeadLock$$Lambda$15/0x0000000800c033f8.run(Unknown Source) at java.lang.Thread.run(java.base@18.0.2.1/Thread.java:833) Found 1 deadlock. \",\"从上述打印信息我们知道：\",\"dead-lock\"]},\"213\":{\"h\":\"饥饿Starvation\",\"t\":[\"我们知道多线程执行中有线程优先级这个东西，优先级高的线程能够插队并优先执行，这样如果优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。当然还有一种饥饿的情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源\",\"public class StarvationLock { private static final Object lock = new Object(); public static void main(String[] args) { var thread1 = new Thread(() -> { synchronized (lock) { System.out.println(Thread.currentThread().getName() + \\\" owned lock\\\"); while (true) { } } }); var thread2 = new Thread(() -> { synchronized (lock) { System.out.println(Thread.currentThread().getName() + \\\" get lock\\\"); } }); thread1.start(); thread2.start(); } } \",\"输出结果：\",\"Thread-0 owned lock \"]},\"214\":{\"h\":\"活锁Livelock\",\"t\":[\"活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁\",\"两个迎面走来的两个绅士互相礼让，A想让B通过往右边礼让，同时B想让A通过也往右礼让。此时AB都在右边，然后两人又同时开始礼让对方，于是两人又都在左边。于是两开始了无限次的礼让，但是仍旧没有一个人能够通过。这就是活锁\",\"LiveLock\",\" \"]},\"215\":{\"h\":\"FAQ\"},\"216\":{\"h\":\"总结\"},\"217\":{\"h\":\"参考\"},\"218\":{\"h\":\"不为人知的锁优化\"},\"219\":{\"h\":\"Jvm中锁的实现与优化\"},\"220\":{\"h\":\"偏向锁\"},\"221\":{\"h\":\"轻量级锁\"},\"222\":{\"h\":\"锁膨胀\"},\"223\":{\"h\":\"自旋锁\"},\"224\":{\"h\":\"锁消除\"},\"225\":{\"h\":\"锁的优化思路\",\"t\":[\"在实际的应用中，如果能够在代码的应用层面上进行合理的锁优化，也是会提升系统性能的。这里我们就展开讲讲锁的优化思路。\"]},\"226\":{\"h\":\"减少锁持有时间\",\"t\":[\"减少锁的持有时间，其实就是移出没有必要加锁的操作。想想看如果每个人(线程)占了餐馆的位置，并在上面吃饭、打游戏(费时操作)，如果是就餐高峰期。每个人占着位置1个多小时，那么就会造成其他很多人没办法就餐。模拟程序如下\",\"每个人占着位子，需要完成吃饭和打完游戏才离开：用时55秒\",\"Start: 2023-09-09T09:13:12.010155 Thread-0 finish eating, time: 2023-09-09T09:13:13.015756 Thread-0 finish gaming, time: 2023-09-09T09:13:23.030496 Thread-4 finish eating, time: 2023-09-09T09:13:24.034547 Thread-4 finish gaming, time: 2023-09-09T09:13:34.034642 Thread-3 finish eating, time: 2023-09-09T09:13:35.037233 Thread-3 finish gaming, time: 2023-09-09T09:13:45.040466 Thread-1 finish eating, time: 2023-09-09T09:13:46.044608 Thread-1 finish gaming, time: 2023-09-09T09:13:56.045113 Thread-2 finish eating, time: 2023-09-09T09:13:57.046996 Thread-2 finish gaming, time: 2023-09-09T09:14:07.051744 End: 2023-09-09T09:14:07.052087 \",\"如果修改上述Person类的action方法如下：\",\"void action() throws InterruptedException { synchronized (Person.class) { eat(); } playGame(); } \",\"真实的业务场景，就是你吃完饭就快些离开释放位子，打游戏不用占着位子: 用时15秒\",\"Start: 2023-09-09T09:12:44.551386 Thread-3 finish eating, time: 2023-09-09T09:12:45.558119 Thread-1 finish eating, time: 2023-09-09T09:12:46.569063 Thread-2 finish eating, time: 2023-09-09T09:12:47.569294 Thread-4 finish eating, time: 2023-09-09T09:12:48.569583 Thread-0 finish eating, time: 2023-09-09T09:12:49.574430 Thread-3 finish gaming, time: 2023-09-09T09:12:55.567889 Thread-1 finish gaming, time: 2023-09-09T09:12:56.569007 Thread-2 finish gaming, time: 2023-09-09T09:12:57.569301 Thread-4 finish gaming, time: 2023-09-09T09:12:58.574313 Thread-0 finish gaming, time: 2023-09-09T09:12:59.575102 End: 2023-09-09T09:12:59.575345 \"]},\"227\":{\"h\":\"减少锁粒度\"},\"228\":{\"h\":\"锁分离\"},\"229\":{\"h\":\"锁粗化\"},\"230\":{\"h\":\"FAQ\"},\"231\":{\"h\":\"总结\"},\"232\":{\"h\":\"参考\"},\"233\":{\"h\":\"锁工具类LockSupport\"},\"234\":{\"h\":\"使用\",\"t\":[\"public class LockSupportMain { public static void main(String[] args) { var thread = new Thread(() -> { for (int i = 0; i < 3; i++) { System.out.printf(\\\"i = %d, time = %s\\\\n\\\", i, LocalDateTime.now()); secondsSleep(1); if (i == 1) { LockSupport.park(); } } }); thread.start(); secondsSleep(4); System.out.println(\\\"After 4 seconds\\\"); LockSupport.unpark(thread); } private static void secondsSleep(int seconds) { try { TimeUnit.SECONDS.sleep(seconds); } catch (InterruptedException e) { throw new RuntimeException(e); } } } \",\"输出结果\",\"i = 0, time = 2023-09-07T08:25:32.929474 i = 1, time = 2023-09-07T08:25:33.944046 After 4 seconds i = 2, time = 2023-09-07T08:25:36.917732 \",\"unpark可以在park之前调用，去掉上述的secondsSleep(9)代码，也就是：\",\"thread.start(); LockSupport.unpark(thread); \",\"输出\",\"i = 0, time = 2023-09-07T08:26:06.781756 i = 1, time = 2023-09-07T08:26:07.800623 i = 2, time = 2023-09-07T08:26:08.805705 \"]},\"235\":{\"h\":\"分析\"},\"236\":{\"h\":\"FAQ\"},\"237\":{\"h\":\"总结\"},\"238\":{\"h\":\"参考\"},\"239\":{\"h\":\"你是我心上的一把锁\",\"t\":[\"线程请上锁\"]},\"240\":{\"h\":\"读写锁ReadWriteLock\"},\"241\":{\"h\":\"使用\",\"t\":[\"public class ReadWriteLockMain { private static int value = 0; static void read(Lock lock) { try { lock.lock(); TimeUnit.SECONDS.sleep(1); System.out.printf(\\\"Finish read %d, time: %s\\\\n\\\", value, LocalDateTime.now()); } catch (InterruptedException e) { throw new RuntimeException(e); } finally { lock.unlock(); } } static void write(Lock lock, int newVal) { try { lock.lock(); TimeUnit.SECONDS.sleep(1); value = newVal; System.out.printf(\\\"Finish write %d, time: %s\\\\n\\\", newVal, LocalDateTime.now()); } catch (InterruptedException e) { throw new RuntimeException(e); } finally { lock.unlock(); } } public static void main(String[] args) { var lock = new ReentrantReadWriteLock(); for (int i = 0; i < 3; i++) new Thread(() -> read(lock.readLock())).start(); for (int i = 0; i < 2; i++) new Thread(() -> write(lock.writeLock(), new Random().nextInt(12))).start(); } } \",\"输出结果是：\",\"Finish read 0, time: 2023-09-07T10:42:19.531316 Finish read 0, time: 2023-09-07T10:42:19.531389 Finish read 0, time: 2023-09-07T10:42:19.531318 Finish write 8, time: 2023-09-07T10:42:20.549605 Finish write 9, time: 2023-09-07T10:42:21.553636 \",\"如果修改上述的main方法如下：\",\"public static void main(String[] args) { var lock = new ReentrantLock(); for (int i = 0; i < 3; i++) new Thread(() -> read(lock)).start(); for (int i = 0; i < 2; i++) new Thread(() -> write(lock, new Random().nextInt(12))).start(); } \",\"那么此次的输出结果:\",\"Finish read 0, time: 2023-09-07T10:43:06.426840 Finish read 0, time: 2023-09-07T10:43:07.442590 Finish read 0, time: 2023-09-07T10:43:08.448698 Finish write 6, time: 2023-09-07T10:43:09.453418 Finish write 7, time: 2023-09-07T10:43:10.457287 \"]},\"242\":{\"h\":\"分析\"},\"243\":{\"h\":\"FAQ\"},\"244\":{\"h\":\"总结\",\"t\":[\"ReadWriteLock可以提高读取效率，适合于读多写少的场景\",\"ReadWriteLock只允许一个线程写入，在写入时线程不能读取(线程安全)\",\"ReadWriteLock在没有写入的时候，多个线程是可以同时读取(提高性能)\"]},\"245\":{\"h\":\"参考\"},\"246\":{\"h\":\"重入锁ReentrantLock\",\"t\":[\"之前介绍的synchronized关键字就是一种最简单的同步控制方法，而在JDK 5引入了重入锁与使用synchronized具有相同的基本行为，但具有扩展功能。现在我们来学习下重入锁。\"]},\"247\":{\"h\":\"重入锁的使用\",\"t\":[\"重入锁使用java.util.concurent.locks.ReentrantLock类来实现。下面是一段最简单的重入锁使用案例：\",\"public class Reenterlock implements Runnable { public static final Lock LOCK = new ReentrantLock(); public static int i = 0; @Override public void run() { for (int j = 0; j < 1000_000; j++) { LOCK.lock(); try { i++; } finally { LOCK.unlock(); } } } public static void main(String[] args) throws InterruptedException { var reenterlock = new Reenterlock(); var t1 = new Thread(reenterlock); var t2 = new Thread(reenterlock); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); // 2000000 } } \",\"上述代码8~12行，使用重入锁保护临界区资源i，确保多线程对i操作的安全性。与synchronized略有不同，我们需要手动的加锁和释放锁，这提供了更好的灵活性。\",\"Note\",\"在退出临界区时，必须记得释放锁unlock()，否则其他线程就没有机会再访问临界区了。\"]},\"248\":{\"h\":\"为什么叫重入锁\",\"t\":[\"之所以叫重入锁，是因为同一个线程是可以连续获得同一把锁。试想一下场景：同步代码直接或间接调用包含同步代码的方法，并且两组代码使用相同的锁。如果没有可重入同步，同步代码将必须采取许多额外的预防措施，以避免线程导致自身阻塞。\",\"LOCK.lock(); LOCK.lock(); try { i++; } finally { LOCK.unlock(); LOCK.unlock(); } \",\"在这种情況下，一个线程连续两次获得同一把锁。如果说一个线程多次获得了锁，那么也必须释放相同次数的锁。假如线程获得锁m次，释放锁n次\",\"m > n: 此线程仍旧持有这个锁，其他线程想进入临界区需要等待\",\"m = n: 此线程不再持有这个锁，其他线程想进入临界区无需等待\",\"m < n: 这里会有抛出IllegalMonitorStateException的异常\",\"对于判断当前线程是否持有锁，或者说持有多少次锁，JDK提供了相应的方法：isHeldByCurrentThread()和getHoldCount，下面给一个简单的例子:\",\"public class Reenterlock implements Runnable { public static final ReentrantLock LOCK = new ReentrantLock(); @Override public void run() { LOCK.lock(); LOCK.lock(); System.out.printf(\\\"HoldCount %d and isHeld %s.\\\\n\\\", LOCK.getHoldCount(), LOCK.isHeldByCurrentThread()); LOCK.unlock(); System.out.printf(\\\"HoldCount %d and isHeld %s.\\\\n\\\", LOCK.getHoldCount(), LOCK.isHeldByCurrentThread()); } public static void main(String[] args) throws InterruptedException { var reenterlock = new Reenterlock(); var t1 = new Thread(reenterlock); t1.start(); System.out.printf(\\\"In main thread: HoldCount %d and isHeld %s.\\\\n\\\", LOCK.getHoldCount(), LOCK.isHeldByCurrentThread()); t1.join(); } } \",\"输出结果为：\",\"In main thread: HoldCount 0 and isHeld false. HoldCount 2 and isHeld true. HoldCount 1 and isHeld true. \"]},\"249\":{\"h\":\"中断响应lockInterruptibly\",\"t\":[\"对于synchronized来说，如果一个线程在等待锁，要么它获得这把锁继续执行，要么它就保持等待。而重入锁提供另外一种可能，那就是在获取锁的过程中线程可以被中断，从而取消对锁的请求。这主要得益于方法lockInterruptibly。\",\"下面给出一个使用lockInterruptibly解决死锁的例子：\"]},\"250\":{\"h\":\"限时等待锁申请\",\"t\":[\"tryLock()方法\"]},\"251\":{\"h\":\"公平锁和非公平锁\",\"t\":[\"public ReentrantLock (boolean fair) \"]},\"252\":{\"h\":\"FAQ\"},\"253\":{\"h\":\"synchronized和ReentrantLock如何选择？\"},\"254\":{\"h\":\"总结\"},\"255\":{\"h\":\"参考\"},\"256\":{\"h\":\"信号量Semaphore\",\"t\":[\"正常的锁不管是内部锁synchronized还是重入锁ReentrantLock在任意时刻只允许一个线程访问临界资源，Java中有没有可以让多个任务同时这个临界资源呢？接下来就让我们来看下线程同步的辅助类Semaphore。\"]},\"257\":{\"h\":\"Semaphore使用\",\"t\":[\"信号量Semaphore为多线程协作提供了更为强大的控制方法，它可以指定多个线程同时访问某个资源。Semaphore有以下两个构造函数：\",\"public Semaphore(int permits) { sync = new NonfairSync(permits); } public Semaphore(int permits, boolean fair) { sync = fair ? new FairSync(permits) : new NonfairSync(permits); } \",\"其中需要指定许可证(permits)的大小，也就是同时可以申请多少许可证。不带fair参数的信号量是非公平的，即多个线程同时去获取许可，哪个线程会拿到是不确定的。而当fair为true时，信号量是公平的，即多个线程同时去获取许可，是按照FIFO队列的规则来选的线程。\",\"Semaphore中主要的方法有：\",\"public void acquire() public void acquireUninterruptibly() public boolean tryAcquire() public boolean tryAcquire(long timeout, TimeUnit unit) public void release() \",\"acquire: 获得一个准入的许可。若无法获得，则线程会等待直到有其它线程释放一个许可或者当前线程被中断\",\"acquireUninterruptibly: 和acquire方法类似，区别在于它不响应中断\",\"tryAcquire: 尝试获得一个许可，如果成功返回true，失败则返回false，它不会进行等待而是立即返回。带参数的tryAcquire区别在于它会等待指定的时间\",\"release: 用于资源访问结束后释放一个许可\",\"当然上述方法都有带permits额外参数的重载方法，表示一次性可以操作多个许可，这比循环去获取或者释放的方式更加的高效。\",\"public boolean acquire(int permits) ... public void release(int permits) \",\"下面我们就举个银行业务办理的例子来说明Semaphore的用法：\",\"public class SemaphoreTest { final static Semaphore availableWindow = new Semaphore(2); public static void main(String[] args) { var runnable = new Runnable() { int count = 1; @Override public void run() { int time = (int) (Math.random() * 10 + 3); int num = count++; try { availableWindow.acquire(); System.out.println(\\\"正在为第【\\\" + num + \\\"】个客户办理业务，需要时间：\\\" + time + \\\"s！\\\"); Thread.sleep(time * 1000L); if (availableWindow.hasQueuedThreads()) { System.out.println(\\\"第【\\\" + num + \\\"】个客户已办理完业务，有请下一位！\\\"); } else { System.out.println(\\\"第【\\\" + num + \\\"】个客户已办理完业务，没有客户了，休息中！\\\"); } availableWindow.release(); } catch (InterruptedException e) { e.printStackTrace(); } } }; for (int i = 1; i < 5; i++) { new Thread(runnable).start(); } } } \",\"输出不确定，某次的结果如下：\",\"正在为第【1】个客户办理业务，需要时间：3s！ 正在为第【2】个客户办理业务，需要时间：11s！ 第【1】个客户已办理完业务，有请下一位！ 正在为第【4】个客户办理业务，需要时间：7s！ 第【4】个客户已办理完业务，有请下一位！ 正在为第【3】个客户办理业务，需要时间：5s！ 第【2】个客户已办理完业务，没有客户了，休息中！ 第【3】个客户已办理完业务，没有客户了，休息中！ \",\"这里我们创建五个线程来模拟五个用户去银行办理业务，其中Semaphore的许可个数设置为2，表示银行业务办理窗口的数量，也就是说同时办理业务的人数最大是2。\",\"Semaphore的hasQueuedThreads方法查询是否有线程正在等待获取许可。\",\"从上述的输出结果得知：银行有两个窗口，一开始客户1和客户2得到了办理的机会，3秒之后客户1办理完释放了窗口。于是客户4得到机会去办理业务，由于客户4业务比较简单只花了7秒钟就完成了。于是这个窗口被释放，客户3得到了办理的机会。最后客户2和客户3办理完业务。\"]},\"258\":{\"h\":\"Semaphore分析\"},\"259\":{\"h\":\"FAQ\"},\"260\":{\"h\":\"总结\"},\"261\":{\"h\":\"参考\"},\"262\":{\"h\":\"StampedLock\",\"t\":[\"我们知道ReadWriteLock可以实现读写分离，但是读写之间仍旧是需要同步的。当有大量的读线程，那么也会造成写线程的长时间阻塞引发饥饿的问题。有没有一种锁可以针对这种场景做些优化呢？今天我们就来看下这个作为读写锁的升级版：StampedLock\"]},\"263\":{\"h\":\"使用\",\"t\":[\"StampedLock提供了一种乐观的读策略。这种乐观的锁非常类似无锁的操作，使得乐观锁完全不会阻塞写线程。\"]},\"264\":{\"h\":\"分析\",\"t\":[\"StampedLock的内部实现是基于CLH锁的。CLH锁是一种自旋锁，它保证没有饥饿发生，并且可以保证FIFO的服务顺序。\",\"CLH锁的基本思想如下：锁维护一个等待线程队列，所有申请锁但是没有成功的线程都记录在这个队列中。每一个节点(一个节点代表一个线程)，保存一个标记位(locked)用于判断当前线程是否已经持有锁。\",\"当一个线程试图获得锁时，取得当前等待队列的尾部节点作为其前序节点，并使用类似如下代码判断前序节点是杏已经成功释放锁\",\"while (pred.locked) {} \"]},\"265\":{\"h\":\"FAQ\"},\"266\":{\"h\":\"总结\",\"t\":[\"StampedLock提供了乐观读锁，可取代ReadWriteLock以进一步提升并发性能\",\"StampedLock是不可重入锁\"]},\"267\":{\"h\":\"参考\"},\"268\":{\"h\":\"一探究竟线程池\",\"t\":[\"线程是操作系统的资源，频繁的线程创建和销毁势必会影响并发的吞吐量。java 5引入了线程池实现了线程的复用，很好的解决了线程创建和销毁的问题。今天我们就来看下这个池子中究竟有什么\"]},\"269\":{\"h\":\"什么是线程池\",\"t\":[\"类似于数据库的连接池，线程池里面保存的是线程而不是数据库连接。在线程池中，会有一个或多个可用的线程。当需要使用线程时，就可以从池子中随便取一个可用的空闲线程。当你完成工作时，不必关闭线程，而是把线程归还到线程池中，方便后续的线程需要。\",\"Executor 框架\",\"Executor 框架\",\"JDK的包java.util.concurrent中涵盖了Executor的框架，其中ThreadPoolExecutor是线程池，它管理着线程以为接收提交线程的任务。\",\"public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize < 0 || maximumPoolSize <= 0 || maximumPoolSize < corePoolSize || keepAliveTime < 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; } \",\"corePoolSize: 保留在池中的线​​程数，即使它们处于空闲状态，除非是设置了allowCoreThreadTimeOut\",\"maximumPoolSize: 池中允许的最大线程数\",\"keepAliveTime: 当线程池线程数量超过corePoolSize时，多余的空闲线程的存活时间。 即超过corePoolSize的空闲线程，在多长时间内，会被销毀\",\"unit: keepAliveTime的时间单位\",\"workQueue: 用于在执行任务之前保存任务的队列。该队列将仅保存由execute方法提交的Runnable任务\",\"threadFactory: 线程工厂，用于创建线程\",\"handler: 拒绝策略。 当任务太多来不及处理，如何拒绝任务\",\"线程池一般都是由Executors这个工厂类来创建，它提供了各种类型的线程池：\",\"public static ExecutorService newFixedThreadPool(int nThreads) public static ExecutorService newSingleThreadExecutor() public static ExecutorService newCachedThreadPool() public static ScheduledExecutorService newSingleThreadScheduledExecutor() public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) \",\"newFixedThreadPool: 返回一个固定数量的线程池。当有任务提交时，池中若有空闲的线程，那么立即执行。否则会把任务存放到一个任务队列中，等待有线程空闲时，便处理在任务队列中的任务。\",\"public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()); } \",\"newSingleThreadExecutor: 返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待有线程空闲，按先入先出的顺序执行队列中的任务。\",\"public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>())); } \",\"newCachedThreadPool: 返回一个可根据实际情况调整线程数量的线程池。 线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。\",\"public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>()); } \",\"newSingleThreadScheduledExecutor: 返回一个ScheduledExecutorService对象，线程池大小是1。\",\"public static ScheduledExecutorService newSingleThreadScheduledExecutor() { return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1)); } \",\"newScheduledThreadPool: 该方法也返回一个ScheduledExecutorService对象，但该线程池可以指定线程数量。\",\"public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize); } \",\"下面我们就以简单的例子加以说明：\",\"public class FixedThreadPool { public static void main(String[] args) { var executorService = Executors.newFixedThreadPool(4); for (int i = 0; i < 8; i++) { executorService.submit(new Task(i)); } executorService.shutdown(); } static class Task implements Runnable { private final int index; public Task(int index) { this.index = index; } @Override public void run() { System.out.println(Thread.currentThread().getName() + \\\", id = %d, time = %s\\\".formatted(index, LocalDateTime.now())); try { TimeUnit.SECONDS.sleep(index + 1); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } \",\"输出结果是：\",\"pool-1-thread-3, id = 2, time = 2023-08-23T17:23:27.079117 pool-1-thread-2, id = 1, time = 2023-08-23T17:23:27.079033 pool-1-thread-4, id = 3, time = 2023-08-23T17:23:27.079035 pool-1-thread-1, id = 0, time = 2023-08-23T17:23:27.079031 pool-1-thread-1, id = 4, time = 2023-08-23T17:23:28.105052 pool-1-thread-2, id = 5, time = 2023-08-23T17:23:29.104030 pool-1-thread-3, id = 6, time = 2023-08-23T17:23:30.104577 pool-1-thread-4, id = 7, time = 2023-08-23T17:23:31.104777 \",\"程序中创建一个固定数量为4的线程池，同时创建了8个任务。任务中打印出index值，随后睡眠index + 1秒。从输出结果上看，前四个任务立马得到了执行，线程的顺序是3241，处理的id顺序是2130。根据任务中睡眠时间(也可以说是执行时间)是index递增，所以线程执行完的顺序大概率是1234，即被释放的线程陆续处理接下来的4个任务。\"]},\"270\":{\"h\":\"计时任务\",\"t\":[\"scheduleWithFixedDelay: 创建并执行一个周期性任务。任务开始于初始延时时间，period是下一人任务相对于上一个任务的结束时间来的。\",\"scheduleAtFixedRate: 创建一个周期性任务。任务开始于给定的初始延时时间，period是下一人任务相对于上一个任务的开始时间来的(要保证上一个任务完成才进行下一个任务)。\",\"由于线程池支持定时的任务，下面我们就举一个计时任务的例子：\",\"public class ScheduledThreadPool { public static void main(String[] args) throws InterruptedException { var scheduledExecutorService = Executors.newScheduledThreadPool(6); scheduledExecutorService.scheduleWithFixedDelay(new Task(), 1, 3, TimeUnit.SECONDS); System.out.println(Thread.currentThread().getName() + \\\", time: \\\" + LocalDateTime.now()); TimeUnit.SECONDS.sleep(15); scheduledExecutorService.shutdown(); System.out.println(Thread.currentThread().getName() + \\\", time: \\\" + LocalDateTime.now()); } static class Task implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName() + \\\", time: \\\" + LocalDateTime.now()); try { TimeUnit.SECONDS.sleep(4); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } \",\"输出结果是：\",\"main, time: 2023-08-25T11:25:14.281678 pool-1-thread-1, time: 2023-08-25T11:25:15.267234 pool-1-thread-1, time: 2023-08-25T11:25:22.274503 pool-1-thread-2, time: 2023-08-25T11:25:29.279348 main, time: 2023-08-25T11:25:29.296934 \",\"上述第5行代码将scheduleWithFixedDelay方法改成scheduleAtFixedRate，那么输出结果：\",\"main, time: 2023-08-25T11:25:51.540083 pool-1-thread-1, time: 2023-08-25T11:25:52.530656 pool-1-thread-1, time: 2023-08-25T11:25:56.534709 pool-1-thread-2, time: 2023-08-25T11:26:00.535428 pool-1-thread-1, time: 2023-08-25T11:26:04.538647 main, time: 2023-08-25T11:26:06.552026 \",\"Tips\",\"如果某个任务遇到异常，那么后续的所有子任务都会停止调度。\"]},\"271\":{\"h\":\"Jdk的线程池\"},\"272\":{\"h\":\"线程池的原理\"},\"273\":{\"h\":\"线程池的拓展\"},\"274\":{\"h\":\"ThreadFactory\"},\"275\":{\"h\":\"FAQ\"},\"276\":{\"h\":\"总结\"},\"277\":{\"h\":\"参考资料\"},\"278\":{\"h\":\"明辨是非断言库\"},\"279\":{\"h\":\"AssertJ\"},\"280\":{\"h\":\"Hamcrest\"},\"281\":{\"h\":\"百花争艳的Log\"},\"282\":{\"h\":\"日志门面\"},\"283\":{\"h\":\"common-logging\"},\"284\":{\"h\":\"slf4j\"},\"285\":{\"h\":\"日志框架\"},\"286\":{\"h\":\"java.util.logging\"},\"287\":{\"h\":\"Log4j\"},\"288\":{\"h\":\"Logback\"},\"289\":{\"h\":\"Log4j2\"},\"290\":{\"h\":\"FAQ\"},\"291\":{\"h\":\"总结\"},\"292\":{\"h\":\"参考\"},\"293\":{\"h\":\"Lombok一键生成代码\"},\"294\":{\"h\":\"FAQ\"},\"295\":{\"h\":\"Record降临Lombok还有必要吗？\"},\"296\":{\"h\":\"Jvm垃圾收集器\",\"t\":[\"jvm垃圾收集器\"]},\"297\":{\"h\":\"Jvm内存模型\",\"t\":[\"java中的内存模型\"]},\"298\":{\"h\":\"原子性\"},\"299\":{\"h\":\"有序性\"},\"300\":{\"h\":\"可见性\"},\"301\":{\"h\":\"Hapens-Before原则\"},\"302\":{\"h\":\"FAQ\"},\"303\":{\"h\":\"总结\"},\"304\":{\"h\":\"参考\"},\"305\":{\"h\":\"引用的类型\",\"t\":[\"在Java中提供了4个级别的引用：强引用、软引用、弱引用和虚引用。之所以整出这么多的引用类型，是因为引用也有轻重缓急，分门别类有助于GC更好的进行垃圾回收。下面我们就来具体看下这些引用类型。\"]},\"306\":{\"h\":\"强引用\",\"t\":[\"强引用就是程序中一般使用的引用类型，强引用的对象是可触及的，不会被回收。下面是一个强引用的例子\",\"Object object = new Object(); \",\"强引用具备以下特点：\",\"强引用可以直接访问目标对象\",\"强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向的对象\",\"强引用可能导致内存泄露\"]},\"307\":{\"h\":\"软引用\",\"t\":[\"如果一个对象只持有软引用，那么当堆空间不足时，就会被回收。软引用使用java.lang.ref.SoftReference类实现。\"]},\"308\":{\"h\":\"弱引用\",\"t\":[\"在系统GC时，只要发现弱引用，不管系统堆空间使用情况如何，都会将对象进行回收。但是，由于垃圾回收器的线程通常优先级很低，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。\",\"一旦一个弱引用对象被垃圾回收器回收，便会加入一个注册的引用队列。弱引用使用java.lang.ref.WeakReference类实现。\"]},\"309\":{\"h\":\"虚引用\",\"t\":[\"虚引用是所有引用类型中最弱的一个。一个持有虚引用的对象，和没有引用几乎是一样的，随时都可能被垃圾回收器回收。当试图通过虚引用的get()方法取得强引用时，总会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。\",\"当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。\"]},\"310\":{\"h\":\"FAQ\"},\"311\":{\"h\":\"总结\"},\"312\":{\"h\":\"参考\"},\"313\":{\"h\":\"伪共享问题\",\"t\":[\"https://cloud.tencent.com/developer/article/1795207\",\"https://www.cnblogs.com/cyfonly/p/5800758.html\"]},\"314\":{\"h\":\"线程安全的单例模式\",\"t\":[\"单例模式是设计模式中使用最为普遍的模式之一。它是一种对象创建模式，用于产生一个对象的具体实例，它可以确保系统中一个类只产生一个实例。单例与多线程没啥直接关系，但是保证多线程下单例模式的安全性，是件有趣且好玩的事情。今天我们就来聊聊这单例。\"]},\"315\":{\"h\":\"单例模式\"},\"316\":{\"h\":\"饿汉模式\",\"t\":[\"public class Singleton { private final static Singleton INSTANCE = new Singleton(); private Singleton() {} public static Singleton getInstance() { return INSTANCE; } } \",\"这种单例模式是线程安全的，没有加锁。但是对于变量INSTANCE会在类的首次初始化时被创建。\"]},\"317\":{\"h\":\"懒汉模式\",\"t\":[\"public class Singleton { private static Singleton INSTANCE; private Singleton() {} public static Singleton getInstance() throws InterruptedException { if (INSTANCE == null) { TimeUnit.SECONDS.sleep(2); // 模拟一些准备的耗时操作 INSTANCE = new Singleton(); } return INSTANCE; } } \",\"这种会有问题的，当多个线程同时执行到第7行，都判断INSTANCE没有被初始化，然后多个线程都进行了初始化，从而生成了多个实例。\"]},\"318\":{\"h\":\"延迟加载解决方案之声明synchronized\",\"t\":[\"public class Singleton { private static Singleton INSTANCE; private Singleton() {} public synchronized static Singleton getInstance() throws InterruptedException { if (INSTANCE == null) { TimeUnit.SECONDS.sleep(2); // 模拟一些准备的耗时操作 INSTANCE = new Singleton(); } return INSTANCE; } } \",\"这种是线程安全的，因为getInstance方法加了synchronized，所以保证了这个方法只能同时被一个线程访问。\"]},\"319\":{\"h\":\"延迟加载解决方案之同步代码块\",\"t\":[\"public class Singleton { private static Singleton INSTANCE; private Singleton() {} public static Singleton getInstance() throws InterruptedException { synchronized (Singleton.class) { if (INSTANCE == null) { TimeUnit.SECONDS.sleep(2); // 模拟一些准备的耗时操作 INSTANCE = new Singleton(); } } return INSTANCE; } } \",\"这种是线程安全的，和上面的写法很类似。synchronized加在了要保护的代码块上，保证了判断和初始化逻辑是线程安全了。\"]},\"320\":{\"h\":\"延迟加载解决方案之同步部分代码块\",\"t\":[\"public class Singleton { private static Singleton INSTANCE; private Singleton() {} public static Singleton getInstance() throws InterruptedException { if (INSTANCE == null) { TimeUnit.SECONDS.sleep(2); // 模拟一些准备的耗时操作 synchronized (Singleton.class) { INSTANCE = new Singleton(); } } return INSTANCE; } } \",\"这种是线程不安全的\"]},\"321\":{\"h\":\"延迟加载解决方案之DCL双检查锁机制\",\"t\":[\"public class Singleton { private static volatile Singleton INSTANCE; private Singleton() {} public static Singleton getInstance() throws InterruptedException { if (INSTANCE == null) { TimeUnit.SECONDS.sleep(2); // 模拟一些准备的耗时操作 synchronized (Singleton.class) { if (INSTANCE == null) { INSTANCE = new Singleton(); } } } return INSTANCE; } } \",\"这种是线程安全的，INSTANCE采用volatile关键字修饰也是很有必要的。\",\"INSTANCE = new Singleton(); \",\"这段代码其实是分为三步执行\",\"为INSTANCE分配内存空间\",\"初始化INSTANCE\",\"将INSTANCE指向分配的内存地址\",\"但是由于JVM具有指令重排的特性，执行顺序有可能变成1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程T1执行了1和3，此时T2 调用getInstance()后发现INSTANCE不为空，因此返回INSTANCE，但此时INSTANCE还未被初始化。\"]},\"322\":{\"h\":\"总结\"},\"323\":{\"h\":\"FAQ\"},\"324\":{\"h\":\"参考\"},\"325\":{\"h\":\"线程安全synchronized\"},\"326\":{\"h\":\"简单使用\",\"t\":[\"https://www.baeldung.com/java-synchronized\"]},\"327\":{\"h\":\"可重入性\",\"t\":[\"可重入锁是同一个线程重复请求由自己持有的锁对象时，可以请求成功而不会发生死锁。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。\",\"public class SynchronizedTest { static synchronized void parentMethod() { childMethod(); System.out.println(\\\"parent\\\"); } static synchronized void childMethod() { System.out.println(\\\"child method\\\"); } public static void main(String[] args) { new Thread(SynchronizedTest::parentMethod).start(); } } \",\"输出结果：\",\"child method parent \"]},\"328\":{\"h\":\"可重入原理\",\"t\":[\"synchronized通过monitor计数器实现，当执行monitorenter命令时：判断当前monitor计数器值是否为0，如果为0，则说明当前线程可直接获取当前锁对象；否则，判断当前线程是否和获取锁对象线程是同一个线程。若是同一个线程，则monitor计数器累加1，当前线程能再次获取到锁；若不是同一个线程，则只能等待其它线程释放锁资源。当执行完synchronized锁对象的代码后，就会执行monitorexit命令，此时monitor计数器就减1，直至monitor计数器为0时，说明锁被释放了。\"]},\"329\":{\"h\":\"异常会释放锁\",\"t\":[\"public class SynchronizedTest { static synchronized void method1() { while (true) { try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(\\\"Start to throw exception, time: \\\" + LocalDateTime.now()); throw new RuntimeException(); } } static synchronized void method2() { System.out.println(\\\"Method 2, time: \\\" + LocalDateTime.now()); } public static void main(String[] args) throws InterruptedException { new Thread(SynchronizedTest::method1).start(); TimeUnit.SECONDS.sleep(2); new Thread(SynchronizedTest::method2).start(); } } \",\"输出结果：\",\"Start to throw exception, time: 2023-09-01T10:06:06.560455 Method 2, time: 2023-09-01T10:06:06.561578 Exception in thread \\\"Thread-0\\\" java.lang.RuntimeException at com.huhx.thread.SynchronizedTest.method1(SynchronizedTest.java:31) at java.base/java.lang.Thread.run(Thread.java:833) \"]},\"330\":{\"h\":\"锁升级\"},\"331\":{\"h\":\"FAQ\"},\"332\":{\"h\":\"总结\"},\"333\":{\"h\":\"参考\"},\"334\":{\"h\":\"线程界的清流ThreadLocal\",\"t\":[\"如果想在线程中保存些数据，\"]},\"335\":{\"h\":\"ThreadLocal的使用\",\"t\":[\"public class ThreadLocalTest { public static void main(String[] args) throws InterruptedException { var threadLocal = new ThreadLocal<>() { @Override protected String initialValue() { return \\\"huhx\\\"; } }; System.out.println(Thread.currentThread().getName() + \\\": \\\" + threadLocal.get()); new Thread(() -> { System.out.println(Thread.currentThread().getName() + \\\": \\\" + threadLocal.get()); threadLocal.set(\\\"linux\\\"); System.out.println(Thread.currentThread().getName() + \\\": \\\" + threadLocal.get()); }).start(); TimeUnit.SECONDS.sleep(1); System.out.println(Thread.currentThread().getName() + \\\": \\\" + threadLocal.get()); } } \",\"java 8提供了withInitial的静态方法来创建和初始化ThreadLocal。所以上述ThreadLocal的创建可以修改为：\",\"var threadLocal = ThreadLocal.withInitial(() -> \\\"huhx\\\"); \",\"上述代码输出结果：\",\"main: huhx Thread-0: huhx Thread-0: linux main: huhx \"]},\"336\":{\"h\":\"ThreadLocal的分析\",\"t\":[\"第个线程存放的数据会有所差别，如何把线程的数据加以隔离？\",\"ThreadLocal的初始化，ThreadLocal.withInitial，这是从java 8才开始有的\",\"public static <S> ThreadLocal<S> withInitial(Supplier<? extends S> supplier) { return new SuppliedThreadLocal<>(supplier); } static final class SuppliedThreadLocal<T> extends ThreadLocal<T> { private final Supplier<? extends T> supplier; SuppliedThreadLocal(Supplier<? extends T> supplier) { this.supplier = Objects.requireNonNull(supplier); } @Override protected T initialValue() { return supplier.get(); } } \",\"ThreadLocal的set方法\",\"public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { map.set(this, value); } else { createMap(t, value); } } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); } \",\"在set时，首先获得当前线程对象，然后通过getMap拿到线程的ThreadLocalMap，并将值设入ThreadLocalMap中。而ThreadLocalMap可以理解为一个Map，注意ThreadLocalMap是Thread类的成员变量。ThreadLocalMap的key是ThreadLocal当前对象，value是set方法的参数。\",\"ThreadLocal的get方法\",\"public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\\\"unchecked\\\") T result = (T)e.value; return result; } } return setInitialValue(); } \",\"get方法先取得当前线程的ThreadLocalMap对象。然后通过将自己作为key取得内部的实际数据。如果找不到ThreadLocalMap，那么设置并返回ThreadLocal的初始值。\",\"private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { map.set(this, value); } else { createMap(t, value); } if (this instanceof TerminatingThreadLocal) { TerminatingThreadLocal.register((TerminatingThreadLocal<?>) this); } return value; } \",\"TerminatingThreadLocal这个特殊的ThreadLocal，能够在线程终止时收到通知。\"]},\"337\":{\"h\":\"FAQ\"},\"338\":{\"h\":\"总结\"},\"339\":{\"h\":\"参考\"},\"340\":{\"h\":\"线程的使用\",\"t\":[\"在上一篇博客我们讲到什么是线程，这里我们来简单的介绍下线程的使用。\"]},\"341\":{\"h\":\"线程的创建\",\"t\":[\"线程的创建有两种方式，一种是继承Thread类，另一种是实现Runnable接口。比较推荐的是实现Runnable接口的这种方式。\",\"Thread本身是实现了Runnable接口的，调用start()方法会新建一个线程(这个逻辑存在于native方法start0中)并让此线程调用run()方法。\"]},\"342\":{\"h\":\"继承Thread类\",\"t\":[\"创建线程直接简单的方式就是：通过继承Thread类，重写run()方法。\",\"public class HelloThread extends Thread { @Override public void run() { try { TimeUnit.SECONDS.sleep(1); System.out.println(\\\"Hello from a thread!\\\"); } catch (InterruptedException e) { e.printStackTrace(); } } public static void main(String[] args) throws InterruptedException { var helloThread = new HelloThread(); helloThread.start(); System.out.println(\\\"In main thread.\\\"); } } \",\"注意：不要用run()来启动新线程(因为没有调用native方法start0启动线程)。它只会在当前线程中串行地执行run()中的代码。\"]},\"343\":{\"h\":\"实现Runnable接口\",\"t\":[\"上面是通过继承方式来创建线程的，其实Thread类提供了Runnable的构造函数来创建线程。\",\"public Thread(Runnable target) { this(null, target, \\\"Thread-\\\" + nextThreadNum(), 0); } \",\"构造函数把Runnable参数设置成Thread的局部变量target。之所以不用重写Thread类的run()方法，原因如下：\",\"@Override public void run() { if (target != null) { target.run(); } } \",\"Thread默认的run()方法，如果target有值的话，就会调用target里面的run方法。所以我们只需实现Runnable接口，然后把这个接口作为参数传递给Thread即可。\",\"以下是一个例子：\",\"public class HelloRunnable implements Runnable { @Override public void run() { try { System.out.println(\\\"Hello from a thread!\\\"); TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } public static void main(String[] args) { var thread = new Thread(new HelloRunnable()); thread.start(); System.out.println(\\\"In main method.\\\"); } } \",\"之所以推崇使用实现Runnable接口这种方式，原因如下：\",\"Java 中的类只能单继承却可以多实现\",\"将Runnable任务与执行该任务的Thread对象分开，更加的通用灵活\"]},\"344\":{\"h\":\"线程的暂停\",\"t\":[\"Thread.sleep方法会导致当前线程暂停执行一段指定的时间。这是一种使处理器时间可用于应用程序的其他线程或可能在计算机系统上运行的其他应用程序的有效方法。\",\"当然sleep时间不能保证精确，因为它们受到底层操作系统提供的设施的限制，此外在睡眠期间还可以被中断终止。无论如何，您不能假设调用sleep会将线程暂停指定的时间段。\",\"public class SleepThread { public static void main(String[] args) throws InterruptedException { var t = new Thread(() -> { try { Thread.sleep(1000); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(\\\"In t thread, Hello\\\"); }); t.start(); System.out.println(\\\"In main thread, Hello\\\"); } } \",\"Tips\",\"调用sleep()的时候，锁并没有释放。所以t线程在睡眠期间，是没有释放锁的。\"]},\"345\":{\"h\":\"线程的终止\",\"t\":[\"一般来说，线程在执行完毕后就会结束，无须手工关闭。但是Jdk中Thread类提供了一个stop()的方法用以立即终止线程。这个方法被废弃，极不推荐使用。stop方法太过于暴力，强行把执行到一半的线程终止，可能会引起一些数据不一致的问题。\",\"以下给出一个例子来加以说明：\",\"public class StopThread { public static void main(String[] args) throws InterruptedException { var person = new Person(\\\"huhx\\\", \\\"hubei\\\"); var t = new Thread(() -> { person.setUsername(\\\"linux\\\"); try { Thread.sleep(3000); } catch (InterruptedException e) { throw new RuntimeException(e); } person.setAddress(\\\"beijing\\\"); }); t.start(); Thread.sleep(1000); t.stop(); System.out.printf(\\\"username = %s and address = %s%n\\\", person.getUsername(), person.getAddress()); } } \",\"输出结果是：\",\"username = linux and address = hubei \",\"上述例子中，我们在线程t中去修改person实例，在修改完username，我们在main线程调用t.stop()来终止线程t，这导致12行的setAddress没能执行。这就导致了person这个实例只是更新了username，而address没能得到更新。(上述流程，我们使用sleep来模拟现实中的停顿或者费时操作)\",\"在真实的场景下这个问题可能会更严重。比如说转账业务A向B转账，A的钱被扣了，这时转账的线程被终止，钱没能转到对方账户B上面。🥶\"]},\"346\":{\"h\":\"线程的中断\",\"t\":[\"上面提到stop()终止线程过于暴力而被打入冷宫，那么在JDK有更好的终止线程的方式吗？答案是有的，那就是线程中断。\",\"在Java中线程中断是一种重要的线程协作机制。它并不会使线程立即退出，而是给线程发送一个通知，告知目标线程有人希望你退出啦！至于目标线程接到通知后如何处理，则完全由目标线程自行决定。\",\"中断机制是使用称为中断状态的内部标志来实现的，与之相关的有以下三个Thread类中的方法：\",\"public void interrupt() public boolean isInterrupted() public static boolean interrupted() \",\"interrupt()方法设置目标线程的中断状态为true，并通知Jvm中断目标线程\",\"isInterrupted()方法返回目标线程的中断状态\",\"interrupted()方法返回目标线程的中断状态，并设置当前中断状态为false\",\"下面给出一个例子来说明上述几个方法的使用：\",\"public class InterruptThread { public static void main(String[] args) throws InterruptedException { var t = new Thread(() -> { try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { var interrupted = Thread.interrupted(); System.out.println(interrupted); } System.out.println(\\\"In t thread, Hello\\\"); }); t.start(); System.out.println(\\\"Before interrupt: \\\" + t.isInterrupted()); t.interrupt(); System.out.println(\\\"After interrupt: \\\" + t.isInterrupted()); System.out.println(\\\"In main thread, Hello\\\"); } } \",\"输出结果如下：\",\"Before interrupt: false false In t thread, Hello After interrupt: true In main thread, Hello \",\"我们创建了一个线程t，在t.interrupt()中断方法之前，使用isInterrupted()查询线程t的中断状态为false，而之后线程t的中断状态为true。\",\"在t.interrupt()方法被调用，中断正在睡眠当中的线程t，导致线程t抛出InterruptedException异常，我们在catch块中使用Thread.interrupted()静态方法查询当前线程也就是线程t的中断状态，结果为 false。这是因为在java中，任何通过抛出InterruptedException退出的方法(比如sleep()、wait()和join()方法)，都会清除中断标记。\",\"当一个线程被中断，我们是可以在catch语句中自行决定被中断的逻辑，是终止线程还是另做其他都是可以的。上述的例子我们只是简单的打印当前线程的中断状态。\"]},\"347\":{\"h\":\"线程wait和notify\",\"t\":[\"为了支持多线程之间的协作，JDK提供了两个非常重要的线程等待wait()方法和通知notify()方法。这两个方法并不是在Thread类中的，而是归属于Object类。\",\"public final void wait () throws InterruptedException public final native void notify () \",\"实际上，只能在synchronzied语句中调用wait()、notify()和notifyAll()方法。如果在非synchronzied语句中调用这些方法，可以编译但是运行的时候会抛出异常IllegalMonitorStateException：\",\"Exception in thread \\\"main\\\" java.lang.IllegalMonitorStateException: current thread is not owner \",\"意思是：这些方法的调用之前必须获得目标对象的一个锁。\",\"以下我们用一个事例来说明以上两个方法:\",\"public class WaitNotifyThread { public static void main(String[] args) throws Exception { var waitThread = new Thread(() -> { synchronized (WaitNotifyThread.class) { try { System.out.println(\\\"before wait: \\\" + LocalDateTime.now()); WaitNotifyThread.class.wait(); System.out.println(\\\"after wait: \\\" + LocalDateTime.now()); } catch (InterruptedException e) { throw new RuntimeException(); } } }); waitThread.start(); TimeUnit.SECONDS.sleep(2); System.out.println(\\\"waitThread state: \\\" + waitThread.getState()); var notifyThread = new Thread(() -> { synchronized (WaitNotifyThread.class) { System.out.println(\\\"before notify: \\\" + LocalDateTime.now()); WaitNotifyThread.class.notify(); try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(\\\"waitThread state: \\\" + waitThread.getState()); System.out.println(\\\"after notify: \\\" + LocalDateTime.now()); } }); notifyThread.start(); } } \",\"以上程序的输出结果：\",\"before wait: 2023-08-14T21:32:31.104650 waitThread state: WAITING before notify: 2023-08-14T21:32:33.096438 waitThread state: BLOCKED after notify: 2023-08-14T21:32:36.099898 after wait: 2023-08-14T21:32:36.100387 \",\"在main线程中，我们创建线程waitThread并启动。线程waitThread首先获得WaitNotifyThread.class的锁并进入到synchronized块中，调用了wait()方法进入了等待状态，线程被挂起，而锁被释放(这一点很重要，这样其他线程就可以拿到锁来唤醒此线程了🤪)，此时waitThread线程处于WAITING状态。\",\"在2秒之后，notifyThread线程被创建运行。由于waitThread已经释放了锁，notifyThread拿到WaitNotifyThread.class的锁并进入synchronized块中。notify()方法被调用，将尝试唤醒在WaitNotifyThread.class上面睡眠的某一个线程(在这个例子中，该线程就是waitThread)。\",\"waitThread接收到notifyThread线程的唤醒，要做的第一件事并不是执行后续的代码，而是要尝试重新获得WaitNotifyThread.class的锁。如果暂时无法获得，waitThread还必须要等待这个锁，此时waitThread处于BLOCKED状态。从上述输出来看waitThread被唤醒还等了3秒才拿到了锁(这是因为notifyThread线程sleep了3秒，后面执行完释放了锁)。\",\"当锁被成功获得后，waitThread线程接着运行，所以有输出：after wait。\",\"其实wait方法也有其可以指定超时时间的重载方法，如果修改程序如下所示：\",\"WaitNotifyThread.class.wait(); // before WaitNotifyThread.class.wait(10); // modified \",\"此时waitThread要么被其他线程通知唤醒，要么过10毫秒自行尝试醒来。而且由于notifyThread还没有创建未占据锁，锁立马被waitThread再次拿到然后继续执行。此时输出结果为：\",\"before wait: 2023-08-14T21:34:40.468331 after wait: 2023-08-14T21:34:40.481307 waitThread state: TERMINATED before notify: 2023-08-14T21:34:42.456399 waitThread state: TERMINATED after notify: 2023-08-14T21:34:45.461708 \",\"关于notify与notifyAll方法的区别，参考：notify与notifyAll\",\"Tips\",\"wait方法会释放锁，notify和notifyAll方法调用不会释放锁。\"]},\"348\":{\"h\":\"线程优先级\",\"t\":[\"线程的优先级将该线程的重要性传递给了调度器，调度器将倾向于让优先级高的线程先得到执行。但是这并不意味着低优先级的线程得不到执行，只是它的执行频率或者机会较低，高优先级线程也可能也会抢占失败。\",\"Jdk有10个优先级，但是与多数操作系统都不能很好的映射(Window上面有7个优先级且不固定，Salaris有231个优先级)。而且线程的优先级调度和底层操作系统有密切的关系，在各个平台上表现不一，并且这种优先级产生的后果也可能不容易预测，无法精准控制。\",\"优先级的数字越大则优先级越高，它的有效范国在1到10之间。以下是Thread类内置的优先级常量\",\"public final static int MNI_PRIORITY = 1; public final static int NORM PRIORITY = 5; public final static int MAX_PRIORITY = 10; \",\"Note\",\"在绝大多数时间里，所有线程都应该以默认的优先级运行，试图操纵线程优先级通常是一个错误的选择。\"]},\"349\":{\"h\":\"线程join和yield\"},\"350\":{\"h\":\"join方法\",\"t\":[\"join方法允许一个线程等待另一个线程的完成。\",\"public class JoinThread { public static void main(String[] args) throws InterruptedException { var t = new Thread(() -> { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(\\\"In t thread: \\\" + LocalDateTime.now()); }); t.start(); t.join(); System.out.println(\\\"In main thread: \\\" + LocalDateTime.now()); } } \",\"上述代码有两个线程，一个是main，另一个是我们自己创建的t。当我们调用t.join()会导致main线程暂停直到t线程结束。所以上面的输出结果是：\",\"In t thread: 2023-08-14T20:25:07.515364 In main thread: 2023-08-14T20:25:07.517288 \",\"join还有些带超时参数的重载方法，这些重载方法允许程序员指定等待时间。但是与sleep一样会依赖于操作系统的计时，因此您不应假设join将完全等待您指定的时间。\"]},\"351\":{\"h\":\"yield方法\",\"t\":[\"yield方法的作用是放弃当前的CPU资源，将它让给其它的任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。\",\"调用yield静态方法是向调度程序提示当前线程愿意让出其当前对处理器的使用，但是调度程序可以忽略这个提示。\",\"yield是一种启发式尝试，旨在改善线程之间的相对进度，否则会过度利用CPU。它的使用应该与详细的分析和基准测试相结合，以确保它确实具有预期的效果。\",\"以下我们使用一个示例来说明：\",\"public class YieldThread extends Thread { YieldThread(String string) { super(string); } @Override public void run() { for (int i = 0; i < 10; i++) { System.out.println(getName() + \\\": \\\" + i); if (i % 2 == 0) { Thread.yield(); } } } public static void main(String[] args) { var t1 = new YieldThread(\\\"t1\\\"); var t2 = new YieldThread(\\\"t2\\\"); t1.start(); t2.start(); } } \",\"这里我们创建线程t1和线程t2，两个线程运行同样的代码：遍历打印0到10的数字，并在index为偶数的时候，调用Thread.yield()放弃当前的CPU资源。\",\"输出不确定(大部分情况两个线程是交替执行)，某一次的结果为:\",\"t1: 0 t1: 1 t1: 2 t2: 0 t1: 3 t2: 1 t1: 4 t2: 2 t1: 5 t2: 3 t1: 6 t2: 4 t1: 7 t2: 5 t1: 8 t2: 6 t1: 9 t2: 7 t2: 8 t2: 9 \",\"从结果可以得知，刚开始t1线程执行了012，也就是说当线程t1执行到i=0时，打印并调用Thread.yield()让出调度。但是下一次的执行权，还是分给了t1，所以紧接着打印：t1: 1。\",\"一般来说，yield方法对于调试或测试目的可能很有用，它可能有助于重现由于竞争条件而导致的错误。在设计并发控制结构(例如java.util.concurrent.locks包中的结构)时，它也可能很有用。但是在应用程序中，使用这种方法很少是合适的。\",\"Tips\",\"调用yield()的时候，锁并没有释放。\"]},\"352\":{\"h\":\"守护线程\",\"t\":[\"所谓守护(Daemon)线程，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收器、JIT线程可以理解为守护线程。\",\"与之对应的是用户线程，它可以认为是系统的工作线程，它会完成这个程序应该要完成的业务操作。当进程中所有的用户线程结束，守护线程会自动销毁。\",\"public class DaemonThread { public static void main(String[] args) throws InterruptedException { var t = new Thread(() -> { int i = 0; try { while (true) { System.out.println(\\\"i = \\\" + i++); TimeUnit.SECONDS.sleep(1); } } catch (InterruptedException e) { throw new RuntimeException(); } }); t.setDaemon(true); t.start(); TimeUnit.SECONDS.sleep(5); System.out.println(\\\"Main thread is end.\\\"); } } \",\"上述我们创建线程t，并设置为守护线程。在线程t中，我们每隔一秒的打印递增数字。而在main线程中，我们sleep5秒之后就会退出。所以这个应用程序一共有两个线程，一个是守护线程t，另一个是用户线程main。所以在等到5秒之后main线程的正常退出，守护线程t也相应的结束了。\",\"程序的输出结果如下：\",\"i = 0 i = 1 i = 2 i = 3 i = 4 Main thread is end. \"]},\"353\":{\"h\":\"FAQ\"},\"354\":{\"h\":\"在构建方法里面启动线程？\",\"t\":[\"https://www.baeldung.com/java-thread-constructor\"]},\"355\":{\"h\":\"notify与notifyAll的区别？\"},\"356\":{\"h\":\"总结\"},\"357\":{\"h\":\"参考\"},\"358\":{\"h\":\"可见性volatile\"},\"359\":{\"h\":\"可见性\",\"t\":[\"public class VolatileTest { private static boolean running = true; public static void main(String[] args) throws InterruptedException { new Thread(() -> { System.out.println(\\\"Thread start, time: \\\" + LocalDateTime.now()); while (running) { } System.out.println(\\\"Thread end, time: \\\" + LocalDateTime.now()); }).start(); TimeUnit.SECONDS.sleep(3); running = false; } } \",\"输出结果：\",\"Thread start, time: 2023-09-04T11:01:56.216820 \",\"一直都没能结束，如果在第二行加上volatile修饰符。那么输出结果如下:\",\"Thread start, time: 2023-09-04T11:03:50.573060 Thread end, time: 2023-09-04T11:03:53.559628 \"]},\"360\":{\"h\":\"非原子性\",\"t\":[\"public class VolatileTest { volatile int count = 0; void increment() { for (int i = 0; i < 10000; i++) { count++; } } public static void main(String[] args) throws InterruptedException { var volatileTest = new VolatileTest(); var threads = new ArrayList<Thread>(); for (int i = 0; i < 10; i++) { threads.add(new Thread(volatileTest::increment)); } for (Thread thread : threads) thread.start(); for (Thread thread : threads) thread.join(); System.out.println(volatileTest.count); } } \",\"输出的结果不确定，但是一般会小于10000：\",\"38596 \",\"解决办法，可以使用提供CAS功能的AtomicInteger，它既满足原子性要求，还同时拥有可见性。\",\"AtomicInteger count = new AtomicInteger(); void increment() { for (int i = 0; i < 10000; i++) { count.incrementAndGet(); } } \"]},\"361\":{\"h\":\"禁止指令重排序\",\"t\":[\"内存读写屏障\"]},\"362\":{\"h\":\"指令重排序\"},\"363\":{\"h\":\"FAQ\"},\"364\":{\"h\":\"Lamda表达式里面的异常不能throw?\"},\"365\":{\"h\":\"总结\"},\"366\":{\"h\":\"参考\"},\"367\":{\"h\":\"什么是线程\",\"t\":[\"线程到底是个什么东西，为什么让人如此的着迷？\"]},\"368\":{\"h\":\"什么是线程\"},\"369\":{\"h\":\"跟线程相关的概念\",\"t\":[\"说服务端编程还是大量需要并行计算的，而Java也主要占领着服务端市场，那么对Java的并行计算的研究也就显得非常的必要。但首先，我想在这里先介绍几个重要的相关概念。\"]},\"370\":{\"h\":\"同步(Synchronous)和异步(Asynchronous)\",\"t\":[\"同步和异步通常用来形容一次方法调用。同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。异步方法调用更像一个消息传递，一旦开始方法调用就会立即返回，调用者就可以继续后续的操作。而异步方法通常会在另外一个线程中真实地执行。整个过程不会阻碍调用者的工作。\"]},\"371\":{\"h\":\"并发(Concurrency)和并行(Parallelism)\",\"t\":[\"并发和并行都可以表示多个任务一起执行，但是并发是多个任务交替执行，同一时刻只有一个任务在执行，而并行同一时刻可以有多个任务在同时执行。\",\"并发与并行\"]},\"372\":{\"h\":\"临界区\",\"t\":[\"临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源就必须等待。\",\"就好比卫生间是临界区，一个人先进去使用并关门上锁。其他的人如果要用此卫生间的话，就得在外等候了，直到用卫生间的人欣然走出😌，释放了卫生间这个资源。\"]},\"373\":{\"h\":\"阻塞(Blocking)和非阻塞(Non-Blocking)\",\"t\":[\"阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。此时如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。\",\"非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行，所有的线程都会尝试不断前向执行。\"]},\"374\":{\"h\":\"线程生命周期\",\"t\":[\"讲线程生命周期之前，我们需要了解线程有哪些状态。其实在Thread中的State枚举中定义了如下状态：\",\"public enum State { NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED; } \",\"NEW：线程对象被创建，但还没有调用start()方法\",\"RUNNABLE：调用start()方法后，线程处于runnable状态，但线程调度程序尚未选择它作为正在运行的线程。这个状态其实包含就绪(ready)和运行中(running)\",\"BLOCKED：线程在执行中遇到了类似于synchronized同步块，就会进入BLOCKED阻塞状态，这时线程就会暂停执行，直到获得请求的锁\",\"WAITING：进入该状态的线程需要等待其他线程做出一些特定动作(通知或中断)\",\"TIMED_WAITING：类似于WAITING，但是它可以在指定的时间过后自行返回\",\"TERMINATED：当run()方法退出时，该线程已经执行完毕，处于终止或死亡状态。\",\"Java中线程的生命周期由JVM控制，它的状态图如下：\",\"Thread Lifecycle\"]},\"375\":{\"h\":\"初始(NEW)\",\"t\":[\"线程被创建到start()被调用这期间，线程的状态是：NEW。\",\"var thread = new Thread(() -> System.out.println(\\\"run\\\")); System.out.println(thread.getState()); // NEW \"]},\"376\":{\"h\":\"可运行(RUNNABLE)\",\"t\":[\"当创建的线程调用了start()方法，线程的状态从NEW变成了RUNNABLE。处于此状态的线程要么正在运行，要么准备运行，但它们正在等待系统的资源分配。\",\"在多线程环境中，线程调度程序(JVM的一部分)为每个线程分配固定的时间片。因此线程会运行一段特定的时间，然后将控制权交给其他RUNNABLE线程。\",\"var t1 = new Thread(() -> {}); t1.start(); System.out.println(t1.getState()); \",\"上述很大可能是打印：RUNNABLE，原因是第四行的代码是在main线程中执行，而main线程和线程t1可能是并行执行，那么在第四行输出之前，线程t1没准已经执行完改变了状态。\"]},\"377\":{\"h\":\"阻塞(BLOCKED)\",\"t\":[\"当线程当前不符合运行条件时，该线程就处于BLOCKED状态。当它等待监视器锁并尝试访问被其他线程锁定的代码段时，它会进入此状态。\",\"public class ThreadLifecycle { public static void main(String[] args) throws InterruptedException { var t1 = new Thread(new BlockRunnable()); var t2 = new Thread(new BlockRunnable()); t1.start(); t2.start(); Thread.sleep(1000); System.out.println(t2.getState()); System.exit(0); } } class BlockRunnable implements Runnable { @Override public void run() { synchronized (BlockRunnable.class) { while (true) {} } } } \",\"上述创建两个线程t1和t2，当t1启动之后首先进入synchronized代码块中，拿到了BlockRunnable.class的锁。这里用while模拟t1拥有锁的时间，以便其他线程无法进入此synchronized方法。而当t2启动时尝试进入synchronized的代码块，发现锁已经被t1拥有，此时t2线程就处于BLOCKED的状态。\"]},\"378\":{\"h\":\"等待(WAITING)\",\"t\":[\"当线程等待其他线程执行特定操作时，该线程处于WAITING状态。根据JavaDocs，任何线程都可以通过调用以下三种方法之一进入此状态：\",\"object.wait()\",\"thread.join()\",\"LockSupport.park()\",\"public class WaitingState { public static void main(String[] args) throws InterruptedException { var t1 = new Thread(() -> { synchronized (WaitingState.class) { try { System.out.println(\\\"before wait.\\\"); WaitingState.class.wait(); System.out.println(\\\"after wait.\\\"); } catch (InterruptedException e) { throw new RuntimeException(); } } }); t1.start(); t1.setDaemon(true); TimeUnit.SECONDS.sleep(1); System.out.println(t1.getState()); } } \",\"我们创建线程t1，并在synchronized块中调用了wait()方法。而在main线程中睡眠了1秒钟，当我们打印线程t1状态时，保证此刻t1已经执行完了wait方法。上述的输出结果为:\",\"before wait. WAITING \",\"Info\",\"之所以调用setDaemon方法，是想让程序可以正常退出。要不然线程t1没有被唤醒，会一直wait被挂起，程序没办法退出。\",\"关于setDaemon可以参考：守护线程\"]},\"379\":{\"h\":\"超时等待(TIMED_WAITING)\",\"t\":[\"当线程A等待另一个线程B在规定的时间内执行特定操作时，那么线程A处于TIMED_WAITING状态。\",\"根据java文档，有以下五种方法可以将线程置于TIMED_WAITING状态：\",\"thread.sleep(long millis)\",\"wait(int timeout) or wait(int timeout, int nanos)\",\"thread.join(long millis)\",\"LockSupport.parkNanos(long millis)\",\"LockSupport.parkUntil(long millis)\",\"public class TimedWaitingState { public static void main(String[] args) throws InterruptedException { var t1 = new Thread(() -> { try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { Thread.currentThread().interrupt(); e.printStackTrace(); } }); t1.start(); TimeUnit.SECONDS.sleep(1); System.out.println(t1.getState()); } } \",\"我们创建并启动了一个线程t1，该线程进入睡眠状态，超时时间为5秒，输出将是：TIMED_WAITING\"]},\"380\":{\"h\":\"终止(TERMINATED)\",\"t\":[\"当线程完成执行或被异常终止时，它处于TERMINATED状态。\",\"public class TerminatedState { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -> { try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { throw new RuntimeException(e); } }); t1.start(); t1.stop(); TimeUnit.SECONDS.sleep(1); System.out.println(t1.getState()); } } \",\"我们除了可以使用getState()得到线程的状态，也可以使用isAlive()判断线程是否存活。\",\"t1.isAlive(); \",\"上述例子返回false，简而言之：当且仅当线程已启动且尚未死亡时，该线程才处于活动状态，isActive方法返回true。\"]},\"381\":{\"h\":\"FAQ\"},\"382\":{\"h\":\"多线程在单核处理上会提升性能吗?\"},\"383\":{\"h\":\"总结\"},\"384\":{\"h\":\"参考资料\"},\"385\":{\"h\":\"关于Cache的一切\",\"t\":[\"https://www.baeldung.com/spring-cache-tutorial\"]},\"386\":{\"h\":\"开启Caching\",\"t\":[\"在springboot中使用cache的话，首先要引入依赖：\",\"implementation 'org.springframework.boot:spring-boot-starter-cache' \",\"然后我们需要使用@EnableCaching显示的开启cache：\",\"@Configuration @EnableCaching public class CachingConfig { // cache config .... } \"]},\"387\":{\"h\":\"使用Cache注解\"},\"388\":{\"h\":\"@Cacheable\"},\"389\":{\"h\":\"@CacheEvict\"},\"390\":{\"h\":\"@CachePut\"},\"391\":{\"h\":\"@Caching\"},\"392\":{\"h\":\"@CacheConfig\"},\"393\":{\"h\":\"使用条件Cache\"},\"394\":{\"h\":\"Condition Parameter\"},\"395\":{\"h\":\"Unless Parameter\"},\"396\":{\"h\":\"Spring Cache原理\"},\"397\":{\"h\":\"多数据源的配置\",\"t\":[\"spring中多数据源的配置\"]},\"398\":{\"h\":\"Transaction与EventListener\"},\"399\":{\"h\":\"Spring事务与ApplicationEventPublisher\",\"t\":[\"@Transactional public void handle() { var account = Account.builder() .username(\\\"huhx\\\") .password(\\\"pass\\\") .build(); accountRepository.save(account); publisher.publishEvent(new AccountEvent(\\\"huhx\\\")); var account2 = Account.builder() .username(\\\"huhx2\\\") .password(\\\"pass2\\\") .build(); accountRepository.save(account2); } @Component @RequiredArgsConstructor public class AccountEventHandler { private final BookService bookService; @EventListener(AccountEvent.class) public void onAccountEvent(AccountEvent event) { bookService.save(new BookRequest(event.username())); throw new RuntimeException(); } } // 1. No books saved, no account saved // 2. add @Transactional on onAccountEvent, No books saved, no account saved // 3. add @Async on onAccountEvent, two accounts saved, one book saved // 4. add @Async and @Transactional on onAccountEvent, only two accounts saved // 5. execute in Thread and with @Transactional, two accounts saved, one book saved(这里加不加@Transactional，没区别) @Transactional @EventListener(AccountEvent.class) public void handle(AccountEvent event) { new Thread(() -> { bookService.save(new BookRequest(event.username())); throw new RuntimeException(); }).start(); } // 6. change the eventHandle code as following, no accounts saved, only one book saved(这里加不加@Transactional，没区别) @Transactional @EventListener(AccountEvent.class) public void handle(AccountEvent event) { new Thread(() -> bookService.save(new BookRequest(event.username()))).start(); bookService.save(new BookRequest(event.username())); throw new RuntimeException(); } \",\"默认情况下，ApplicationEventPublisher的publishEvent方法是同步的\"]},\"400\":{\"h\":\"玩转Spring事务\",\"t\":[\"一文了解Spring的事务\"]},\"401\":{\"h\":\"什么是事务\",\"t\":[\"事务的四大特性：\"]},\"402\":{\"h\":\"原子性\"},\"403\":{\"h\":\"一致性\"},\"404\":{\"h\":\"隔离性\"},\"405\":{\"h\":\"持久性\"},\"406\":{\"h\":\"事务引发的问题\"},\"407\":{\"h\":\"脏读\"},\"408\":{\"h\":\"不可重复读\"},\"409\":{\"h\":\"幻读\"},\"410\":{\"h\":\"事务的传播级别\"},\"411\":{\"h\":\"事务的隔离级别\"},\"412\":{\"h\":\"读未提交\"},\"413\":{\"h\":\"读已提交\"},\"414\":{\"h\":\"可重复读\"},\"415\":{\"h\":\"串行化\"},\"416\":{\"h\":\"SSO是个啥玩意\",\"t\":[\"SSO是个啥玩意\"]},\"417\":{\"h\":\"关于微服务\",\"t\":[\"关于微服务\"]},\"418\":{\"h\":\"Github的小妙招\"},\"419\":{\"h\":\"打开当前项目的github\",\"t\":[\"在用户的profile中添加下列函数，这样就可以在项目目录下使用gh打开所在的github\",\"function gh() { url=https://github.$(git config remote.origin.url | cut -f2 -d. | tr ':' '/') open $url } \",\"如果一个目录下面，有多个repo。想要更新所有的repo，也可以像上面一样定义\",\"function gitall() { for i in */.git; do ( echo $i | cut -d '/' -f 1; cd $i/..; gupa; ); } \",\"其中上述的gupa是设置alias: gupa=git pull --rebase --autostash\"]},\"420\":{\"h\":\"常用Gradle插件指南\",\"t\":[\"这里面列出项目中常用插件\"]},\"421\":{\"h\":\"Gradle中的依赖管理\",\"t\":[\"在java世界中，现在最流行的构建工程莫过于gradle了。在使用springboot项目时，经常会碰到会让人头大的版本冲突的问题。今天我们就来讲讲gradle是如何对依赖版本进行管理的\"]},\"422\":{\"h\":\"为什么有依赖版本冲突\"},\"423\":{\"h\":\"怎么编写Gradle的插件\",\"t\":[\"怎么编写Gradle的插件\"]},\"424\":{\"h\":\"轻松玩转macos\",\"t\":[\"这篇文章就讲如何高效的使用macos，其中包含一些可以提高生产力的工具和mac上面鲜为人知的强大功能。\"]},\"425\":{\"h\":\"Macos\"},\"426\":{\"h\":\"自带的快捷键\",\"t\":[\" 打开emoji面板：Command + Control + Space\",\" 编辑器上下分页滚动：fn + pageDown / fn + pageUp\",\" 打开文件目录位置：Command + Shift + G 可以手写路径也可以使用剪切板的内容，这样就能够很快便利的选择相应的文件或者目录。\"]},\"427\":{\"h\":\"免密登录centos\",\"t\":[\"# 1. 生成id_rsa key ssh-keygen -t rsa # 2. 将密钥推送到远程服务器 ssh-copy-id -i ~/.ssh/id_rsa root@47.105.123.222 # 3. 登录 ssh root@47.105.123.222 ssh root@47.105.123.222 uname \",\"设置了本机的免密登录，如果想要上传文件。就可以使用：\",\"scp -r build/web/* root@47.105.123.222:/root/web/tmp \"]},\"428\":{\"h\":\"upic配置aliyun上传文件\",\"t\":[\"最近花了些时间使用Vuepress搭建了自己的博客网站，然后自己博客的资源文件存放在何处呢？一个是以本地文件的形式上传到nginx，另外一个就是上传到aliyun oss以url远程访问。这里我们采用的就是第二种，在macos使用upic上传本地文件到oss，然后在markdown中使用上传完成返回文件的url\"]},\"429\":{\"h\":\"Aliyun服务器配置\",\"t\":[\"Aliyun服务器的配置项主要有两个，一个是创建bucket，另一个是创建访问bucket的权限\"]},\"430\":{\"h\":\"在oss中创建bucket\",\"t\":[\"访问aliyun oss创建bucket，注意设置bucket是公开可读。\",\"创建bucket完之后，我们需要创建用户用于对bucket的写操作\"]},\"431\":{\"h\":\"创建用户用于访问bucket\",\"t\":[\"访问用户界面，创建用户并勾选其编程访问 创建完用户之后，我们再创建AccessKey，保留好创建完的AccessKey ID和AccessKey Secret，在后面配置upic的时候会用到\",\"添加用户的role，这里我们赋予AliyunOSSFullAccess oss这边的配置完成之后，接下来就到了配置upic客户端的环节了\"]},\"432\":{\"h\":\"Aliyun客户端配置\",\"t\":[\"upic是用于上传文件到oss服务器的macos客户端，它支持多种oss的上传，当然包括aliyun。\"]},\"433\":{\"h\":\"配置upic\",\"t\":[\"下载upic\",\"brew cask install upic \",\"在upic上配置aliyun oss\",\"20230724150319578\",\"Tips\",\"Domain: https://huhx-blog.oss-cn-beijing.aliyuncs.com\",\"Save Key: blog/{year}{month}{day}{hour}{minute}{second}\",\"在macos配置upic的权限\",\"打开system preference - extensions - Finder Extensions 勾选uPic Finder Extension\",\"配置upic上传完生成markdown output\",\"在upic的Ouput format中，有四种格式可以选择：URL、HTML、 MARKDOWN和UBB。这里我们选择MARKDOWN\"]},\"434\":{\"h\":\"Dart\"},\"435\":{\"h\":\"Android\"},\"436\":{\"h\":\"Flutter\"},\"437\":{\"h\":\"Kotlin\"},\"438\":{\"h\":\"Kafka\"},\"439\":{\"h\":\"Db\"},\"440\":{\"h\":\"Mongodb\"},\"441\":{\"h\":\"Redis\"},\"442\":{\"h\":\"Ddd\"},\"443\":{\"h\":\"Design\"},\"444\":{\"h\":\"Pattern\"},\"445\":{\"h\":\"Protocol\"},\"446\":{\"h\":\"Docker\"},\"447\":{\"h\":\"Devops\"},\"448\":{\"h\":\"Golang\"},\"449\":{\"h\":\"K8s\"},\"450\":{\"h\":\"Terraform\"},\"451\":{\"h\":\"Life\"},\"452\":{\"h\":\"Essay\"},\"453\":{\"h\":\"Other\"},\"454\":{\"h\":\"Work\"},\"455\":{\"h\":\"Base\"},\"456\":{\"h\":\"Java\"},\"457\":{\"h\":\"Concurrency\"},\"458\":{\"h\":\"Framework\"},\"459\":{\"h\":\"Jvm\"},\"460\":{\"h\":\"Thread\"},\"461\":{\"h\":\"Base\"},\"462\":{\"h\":\"Spring\"},\"463\":{\"h\":\"Framework\"},\"464\":{\"h\":\"Jpa\"},\"465\":{\"h\":\"Microservice\"},\"466\":{\"h\":\"Security\"},\"467\":{\"h\":\"Git\"},\"468\":{\"h\":\"Tool\"},\"469\":{\"h\":\"Gradle\"},\"470\":{\"h\":\"Macos\"}},\"dirtCount\":0,\"index\":[[\"勾选upic\",{\"1\":{\"433\":1}}],[\"配置upic上传完生成markdown\",{\"1\":{\"433\":1}}],[\"配置upic\",{\"0\":{\"433\":1}}],[\"添加用户的role\",{\"1\":{\"431\":1}}],[\"访问用户界面\",{\"1\":{\"431\":1}}],[\"访问aliyun\",{\"1\":{\"430\":1}}],[\"访问远程的api\",{\"1\":{\"88\":1}}],[\"设置了本机的免密登录\",{\"1\":{\"427\":1}}],[\"设置方法调用和捕获参数\",{\"1\":{\"102\":1}}],[\"登录\",{\"1\":{\"427\":1}}],[\"生成id\",{\"1\":{\"427\":1}}],[\"免密登录centos\",{\"0\":{\"427\":1}}],[\"自带的快捷键\",{\"0\":{\"426\":1}}],[\"自旋锁\",{\"0\":{\"223\":1}}],[\"轻松玩转macos\",{\"0\":{\"424\":1}}],[\"轻量级锁\",{\"0\":{\"221\":1}}],[\"怎么编写gradle的插件\",{\"0\":{\"423\":1},\"1\":{\"423\":1}}],[\"怎么乘除法\",{\"0\":{\"67\":1}}],[\"经常会碰到会让人头大的版本冲突的问题\",{\"1\":{\"421\":1}}],[\"常用gradle插件指南\",{\"0\":{\"420\":1}}],[\"常见问题\",{\"0\":{\"105\":1}}],[\"常见的mocktio用法\",{\"0\":{\"101\":1}}],[\"常见的有grep\",{\"1\":{\"110\":1}}],[\"常见的有\",{\"1\":{\"99\":1}}],[\"想要更新所有的repo\",{\"1\":{\"419\":1}}],[\"想想看如果每个人\",{\"1\":{\"226\":1}}],[\"串行化\",{\"0\":{\"415\":1}}],[\"幻读\",{\"0\":{\"409\":1}}],[\"脏读\",{\"0\":{\"407\":1}}],[\"持久性\",{\"0\":{\"405\":1}}],[\"隔离性\",{\"0\":{\"404\":1}}],[\"事务的隔离级别\",{\"0\":{\"411\":1}}],[\"事务的传播级别\",{\"0\":{\"410\":1}}],[\"事务的四大特性\",{\"1\":{\"401\":1}}],[\"事务引发的问题\",{\"0\":{\"406\":1}}],[\"事实上对于正数的加法运算中原码是完全ok的\",{\"1\":{\"61\":1}}],[\"玩转spring事务\",{\"0\":{\"400\":1}}],[\"默认情况下\",{\"1\":{\"399\":1}}],[\"默认引入的starter\",{\"1\":{\"99\":1}}],[\"简而言之\",{\"1\":{\"380\":1}}],[\"简单使用\",{\"0\":{\"326\":1}}],[\"简单来说\",{\"1\":{\"63\":1}}],[\"判断线程是否存活\",{\"1\":{\"380\":1}}],[\"判断当前线程是否和获取锁对象线程是同一个线程\",{\"1\":{\"328\":1}}],[\"判断当前monitor计数器值是否为0\",{\"1\":{\"328\":1}}],[\"终止\",{\"0\":{\"380\":1}}],[\"终止线程过于暴力而被打入冷宫\",{\"1\":{\"346\":1}}],[\"根据java文档\",{\"1\":{\"379\":1}}],[\"根据javadocs\",{\"1\":{\"378\":1}}],[\"根据任务中睡眠时间\",{\"1\":{\"269\":1}}],[\"发现锁已经被t1拥有\",{\"1\":{\"377\":1}}],[\"拿到了blockrunnable\",{\"1\":{\"377\":1}}],[\"拿integer来说\",{\"1\":{\"64\":1}}],[\"被调用这期间\",{\"1\":{\"375\":1}}],[\"处于此状态的线程要么正在运行\",{\"1\":{\"376\":1}}],[\"处于终止或死亡状态\",{\"1\":{\"374\":1}}],[\"处理的id顺序是2130\",{\"1\":{\"269\":1}}],[\"进入该状态的线程需要等待其他线程做出一些特定动作\",{\"1\":{\"374\":1}}],[\"讲线程生命周期之前\",{\"1\":{\"374\":1}}],[\"非阻塞的意思与之相反\",{\"1\":{\"373\":1}}],[\"非原子性\",{\"0\":{\"360\":1}}],[\"等待\",{\"0\":{\"378\":1}}],[\"等待会导致线程挂起\",{\"1\":{\"373\":1}}],[\"等待有线程空闲时\",{\"1\":{\"269\":1}}],[\"临界区用来表示一种公共资源或者说是共享数据\",{\"1\":{\"372\":1}}],[\"临界区\",{\"0\":{\"372\":1}}],[\"整个过程不会阻碍调用者的工作\",{\"1\":{\"370\":1}}],[\"整数分为byte\",{\"1\":{\"64\":1}}],[\"整数的表示\",{\"0\":{\"64\":1}}],[\"整数的补码就是原码本身\",{\"1\":{\"63\":1}}],[\"异步方法调用更像一个消息传递\",{\"1\":{\"370\":1}}],[\"异常会释放锁\",{\"0\":{\"329\":1}}],[\"异常\",{\"1\":{\"146\":1}}],[\"异常的介绍\",{\"0\":{\"42\":1}}],[\"说服务端编程还是大量需要并行计算的\",{\"1\":{\"369\":1}}],[\"说明锁被释放了\",{\"1\":{\"328\":1}}],[\"说明有其它的线程做了更新\",{\"1\":{\"150\":1}}],[\"跟线程相关的概念\",{\"0\":{\"369\":1}}],[\"禁止指令重排序\",{\"0\":{\"361\":1}}],[\"解决办法\",{\"1\":{\"360\":1}}],[\"解决了0有两个编码的问题\",{\"1\":{\"63\":1}}],[\"解决了减法运算的问题\",{\"1\":{\"63\":1}}],[\"程序没办法退出\",{\"1\":{\"378\":1}}],[\"程序的输出结果如下\",{\"1\":{\"352\":1}}],[\"程序中创建一个固定数量为4的线程池\",{\"1\":{\"269\":1}}],[\"守护线程t也相应的结束了\",{\"1\":{\"352\":1}}],[\"守护线程会自动销毁\",{\"1\":{\"352\":1}}],[\"守护线程\",{\"0\":{\"352\":1},\"1\":{\"378\":1}}],[\"时\",{\"1\":{\"351\":1}}],[\"时获得列表中数据的不可变快照\",{\"1\":{\"174\":1}}],[\"打开system\",{\"1\":{\"433\":1}}],[\"打开文件目录位置\",{\"1\":{\"426\":1}}],[\"打开emoji面板\",{\"1\":{\"426\":1}}],[\"打开当前项目的github\",{\"0\":{\"419\":1}}],[\"打印并调用thread\",{\"1\":{\"351\":1}}],[\"打游戏不用占着位子\",{\"1\":{\"226\":1}}],[\"打游戏\",{\"1\":{\"226\":1}}],[\"刚开始t1线程执行了012\",{\"1\":{\"351\":1}}],[\"某一次的结果为\",{\"1\":{\"351\":1}}],[\"某次的结果如下\",{\"1\":{\"257\":1}}],[\"放弃当前的cpu资源\",{\"1\":{\"351\":1}}],[\"遍历打印0到10的数字\",{\"1\":{\"351\":1}}],[\"旨在改善线程之间的相对进度\",{\"1\":{\"351\":1}}],[\"马上又获得cpu时间片\",{\"1\":{\"351\":1}}],[\"试图操纵线程优先级通常是一个错误的选择\",{\"1\":{\"348\":1}}],[\"试想一下场景\",{\"1\":{\"248\":1}}],[\"高优先级线程也可能也会抢占失败\",{\"1\":{\"348\":1}}],[\"调度器将倾向于让优先级高的线程先得到执行\",{\"1\":{\"348\":1}}],[\"调用者就可以继续后续的操作\",{\"1\":{\"370\":1}}],[\"调用者必须等到方法调用返回后\",{\"1\":{\"370\":1}}],[\"调用yield\",{\"1\":{\"351\":1}}],[\"调用yield静态方法是向调度程序提示当前线程愿意让出其当前对处理器的使用\",{\"1\":{\"351\":1}}],[\"调用thread\",{\"1\":{\"351\":1}}],[\"调用了wait\",{\"1\":{\"347\":1}}],[\"调用sleep\",{\"1\":{\"344\":1}}],[\"调用start\",{\"1\":{\"341\":1,\"374\":1}}],[\"调用getinstance\",{\"1\":{\"321\":1}}],[\"调用matcher对象的groupcount方法就可以\",{\"1\":{\"116\":1}}],[\"调用静态方法时始终使用类名\",{\"1\":{\"91\":1}}],[\"意思是\",{\"1\":{\"347\":1}}],[\"查询线程t的中断状态为false\",{\"1\":{\"346\":1}}],[\"查看jdk的文档可知\",{\"1\":{\"45\":1}}],[\"告知目标线程有人希望你退出啦\",{\"1\":{\"346\":1}}],[\"答案是有的\",{\"1\":{\"346\":1}}],[\"🥶\",{\"1\":{\"345\":1}}],[\"钱没能转到对方账户b上面\",{\"1\":{\"345\":1}}],[\"来终止线程t\",{\"1\":{\"345\":1}}],[\"来启动新线程\",{\"1\":{\"342\":1}}],[\"极不推荐使用\",{\"1\":{\"345\":1}}],[\"您不能假设调用sleep会将线程暂停指定的时间段\",{\"1\":{\"344\":1}}],[\"您可以通过使用边界匹配器指定此类信息来使模式匹配更加精确\",{\"1\":{\"118\":1}}],[\"您可以使用构造函数引用来创建新的对象\",{\"1\":{\"49\":1}}],[\"更加的通用灵活\",{\"1\":{\"343\":1}}],[\"更安全\",{\"1\":{\"94\":1}}],[\"重写run\",{\"1\":{\"342\":1}}],[\"重入锁使用java\",{\"1\":{\"247\":1}}],[\"重入锁的使用\",{\"0\":{\"247\":1}}],[\"重入锁reentrantlock\",{\"0\":{\"246\":1}}],[\"继承thread类\",{\"0\":{\"342\":1}}],[\"能够在线程终止时收到通知\",{\"1\":{\"336\":1}}],[\"能够保证一个操作一旦开始\",{\"1\":{\"134\":1}}],[\"初始\",{\"0\":{\"375\":1}}],[\"初始化instance\",{\"1\":{\"321\":1}}],[\"初探kafka的世界\",{\"0\":{\"6\":1}}],[\"延迟加载解决方案之dcl双检查锁机制\",{\"0\":{\"321\":1}}],[\"延迟加载解决方案之同步部分代码块\",{\"0\":{\"320\":1}}],[\"延迟加载解决方案之同步代码块\",{\"0\":{\"319\":1}}],[\"延迟加载解决方案之声明synchronized\",{\"0\":{\"318\":1}}],[\"模拟一些准备的耗时操作\",{\"1\":{\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":1}}],[\"模拟程序如下\",{\"1\":{\"226\":1}}],[\"懒汉模式\",{\"0\":{\"317\":1}}],[\"饿汉模式\",{\"0\":{\"316\":1}}],[\"单例模式\",{\"0\":{\"315\":1}}],[\"单例模式是设计模式中使用最为普遍的模式之一\",{\"1\":{\"314\":1}}],[\"单例与多线程没啥直接关系\",{\"1\":{\"314\":1}}],[\"单个共享变量\",{\"0\":{\"156\":1}}],[\"伪共享问题\",{\"0\":{\"313\":1}}],[\"随时都可能被垃圾回收器回收\",{\"1\":{\"309\":1}}],[\"随后睡眠index\",{\"1\":{\"269\":1}}],[\"虚引用必须和引用队列一起使用\",{\"1\":{\"309\":1}}],[\"虚引用是所有引用类型中最弱的一个\",{\"1\":{\"309\":1}}],[\"虚引用\",{\"0\":{\"309\":1}}],[\"虚拟机宁愿抛出oom异常\",{\"1\":{\"306\":1}}],[\"虚拟机就可以使用这个指令了\",{\"1\":{\"150\":1}}],[\"弱引用使用java\",{\"1\":{\"308\":1}}],[\"弱引用对象可以存在较长的时间\",{\"1\":{\"308\":1}}],[\"弱引用\",{\"0\":{\"308\":1}}],[\"弱引用和虚引用\",{\"1\":{\"305\":1}}],[\"软引用使用java\",{\"1\":{\"307\":1}}],[\"软引用\",{\"0\":{\"307\":1},\"1\":{\"305\":1}}],[\"强行把执行到一半的线程终止\",{\"1\":{\"345\":1}}],[\"强引用可能导致内存泄露\",{\"1\":{\"306\":1}}],[\"强引用可以直接访问目标对象\",{\"1\":{\"306\":1}}],[\"强引用所指向的对象在任何时候都不会被系统回收\",{\"1\":{\"306\":1}}],[\"强引用具备以下特点\",{\"1\":{\"306\":1}}],[\"强引用的对象是可触及的\",{\"1\":{\"306\":1}}],[\"强引用就是程序中一般使用的引用类型\",{\"1\":{\"306\":1}}],[\"强引用\",{\"0\":{\"306\":1},\"1\":{\"305\":1}}],[\"强制它们等待由其他线程执行的一组操作完成\",{\"1\":{\"180\":1}}],[\"引用的类型\",{\"0\":{\"305\":1}}],[\"日志框架\",{\"0\":{\"285\":1}}],[\"日志门面\",{\"0\":{\"282\":1}}],[\"百花争艳的log\",{\"0\":{\"281\":1}}],[\"明辨是非断言库\",{\"0\":{\"278\":1}}],[\"又有新的任务提交\",{\"1\":{\"269\":1}}],[\"又是有哪些的不同呢\",{\"1\":{\"63\":1}}],[\"按先入先出的顺序执行队列中的任务\",{\"1\":{\"269\":1}}],[\"按照约定\",{\"1\":{\"111\":1}}],[\"待有线程空闲\",{\"1\":{\"269\":1}}],[\"若不是同一个线程\",{\"1\":{\"328\":1}}],[\"若是同一个线程\",{\"1\":{\"328\":1}}],[\"若所有线程均在工作\",{\"1\":{\"269\":1}}],[\"若多余一个任务被提交到该线程池\",{\"1\":{\"269\":1}}],[\"若无法获得\",{\"1\":{\"257\":1}}],[\"便会加入一个注册的引用队列\",{\"1\":{\"308\":1}}],[\"便处理在任务队列中的任务\",{\"1\":{\"269\":1}}],[\"便开始启动了车辆扬长而去\",{\"1\":{\"180\":1}}],[\"池中若有空闲的线程\",{\"1\":{\"269\":1}}],[\"池中允许的最大线程数\",{\"1\":{\"269\":1}}],[\"拒绝策略\",{\"1\":{\"269\":1}}],[\"多数据源的配置\",{\"0\":{\"397\":1}}],[\"多线程在单核处理上会提升性能吗\",{\"0\":{\"382\":1}}],[\"多余的空闲线程的存活时间\",{\"1\":{\"269\":1}}],[\"多个线程是可以同时读取\",{\"1\":{\"244\":1}}],[\"多个线程相互占用对方的资源的锁\",{\"1\":{\"211\":1}}],[\"多个线程协同工作\",{\"1\":{\"210\":1}}],[\"除非是设置了allowcorethreadtimeout\",{\"1\":{\"269\":1}}],[\"保留好创建完的accesskey\",{\"1\":{\"431\":1}}],[\"保留在池中的线​​程数\",{\"1\":{\"269\":1}}],[\"保证此刻t1已经执行完了wait方法\",{\"1\":{\"378\":1}}],[\"保证了判断和初始化逻辑是线程安全了\",{\"1\":{\"319\":1}}],[\"保存一个标记位\",{\"1\":{\"264\":1}}],[\"框架\",{\"1\":{\"269\":2}}],[\"很好的解决了线程创建和销毁的问题\",{\"1\":{\"268\":1}}],[\"很多情况下\",{\"1\":{\"114\":1}}],[\"频繁的线程创建和销毁势必会影响并发的吞吐量\",{\"1\":{\"268\":1}}],[\"取得当前等待队列的尾部节点作为其前序节点\",{\"1\":{\"264\":1}}],[\"每一个节点\",{\"1\":{\"264\":1}}],[\"每个人占着位子\",{\"1\":{\"226\":1}}],[\"每个人占着位置1个多小时\",{\"1\":{\"226\":1}}],[\"客户3得到了办理的机会\",{\"1\":{\"257\":1}}],[\"银行有两个窗口\",{\"1\":{\"257\":1}}],[\"休息中\",{\"1\":{\"257\":3}}],[\"个客户已办理完业务\",{\"1\":{\"257\":6}}],[\"个客户办理业务\",{\"1\":{\"257\":5}}],[\"第个线程存放的数据会有所差别\",{\"1\":{\"336\":1}}],[\"第\",{\"1\":{\"257\":6}}],[\"带参数的tryacquire区别在于它会等待指定的时间\",{\"1\":{\"257\":1}}],[\"带有参数的await方法多一种方式结束等待\",{\"1\":{\"180\":1}}],[\"失败则返回false\",{\"1\":{\"257\":1}}],[\"尝试获得一个许可\",{\"1\":{\"257\":1}}],[\"区别在于它不响应中断\",{\"1\":{\"257\":1}}],[\"获得一个准入的许可\",{\"1\":{\"257\":1}}],[\"信号量是公平的\",{\"1\":{\"257\":1}}],[\"信号量semaphore为多线程协作提供了更为强大的控制方法\",{\"1\":{\"257\":1}}],[\"信号量semaphore\",{\"0\":{\"256\":1}}],[\"哪个线程会拿到是不确定的\",{\"1\":{\"257\":1}}],[\"公平锁和非公平锁\",{\"0\":{\"251\":1}}],[\"限时等待锁申请\",{\"0\":{\"250\":1}}],[\"要不然线程t1没有被唤醒\",{\"1\":{\"378\":1}}],[\"要不然本地的debug会不能工作\",{\"1\":{\"88\":1}}],[\"要么准备运行\",{\"1\":{\"376\":1}}],[\"要么过10毫秒自行尝试醒来\",{\"1\":{\"347\":1}}],[\"要么它就保持等待\",{\"1\":{\"249\":1}}],[\"要么它获得这把锁继续执行\",{\"1\":{\"249\":1}}],[\"要做的第一件事并不是执行后续的代码\",{\"1\":{\"347\":1}}],[\"要保证上一个任务完成才进行下一个任务\",{\"1\":{\"270\":1}}],[\"释放了卫生间这个资源\",{\"1\":{\"372\":1}}],[\"释放锁n次\",{\"1\":{\"248\":1}}],[\"释放直接内存\",{\"1\":{\"137\":1}}],[\"假如线程获得锁m次\",{\"1\":{\"248\":1}}],[\"假定一个数是8位\",{\"1\":{\"61\":1}}],[\"否则会过度利用cpu\",{\"1\":{\"351\":1}}],[\"否则会把任务存放到一个任务队列中\",{\"1\":{\"269\":1}}],[\"否则\",{\"1\":{\"328\":1}}],[\"否则其他线程就没有机会再访问临界区了\",{\"1\":{\"247\":1}}],[\"否则如果是java\",{\"1\":{\"78\":1}}],[\"必须记得释放锁unlock\",{\"1\":{\"247\":1}}],[\"必须在栅栏处凑齐parties数目的线程后\",{\"1\":{\"186\":1}}],[\"确保多线程对i操作的安全性\",{\"1\":{\"247\":1}}],[\"确实给开发带来了很大的便利\",{\"1\":{\"50\":1}}],[\"现在最流行的构建工程莫过于gradle了\",{\"1\":{\"421\":1}}],[\"现在我们来学习下重入锁\",{\"1\":{\"246\":1}}],[\"现实生活中人们可能是谈虎色变\",{\"1\":{\"41\":1}}],[\"提高性能\",{\"1\":{\"244\":1}}],[\"适合于读多写少的场景\",{\"1\":{\"244\":1}}],[\"适合做无界队列或者比较大的队列\",{\"1\":{\"143\":1}}],[\"适合做有界队列\",{\"1\":{\"143\":1}}],[\"代码\",{\"1\":{\"234\":1}}],[\"代码里面我们创建五个线程taskworker模拟五个工人\",{\"1\":{\"180\":1}}],[\"去掉上述的secondssleep\",{\"1\":{\"234\":1}}],[\"真实的业务场景\",{\"1\":{\"226\":1}}],[\"费时操作\",{\"1\":{\"226\":1}}],[\"占了餐馆的位置\",{\"1\":{\"226\":1}}],[\"减少锁粒度\",{\"0\":{\"227\":1}}],[\"减少锁的持有时间\",{\"1\":{\"226\":1}}],[\"减少锁持有时间\",{\"0\":{\"226\":1}}],[\"锁立马被waitthread再次拿到然后继续执行\",{\"1\":{\"347\":1}}],[\"锁并没有释放\",{\"1\":{\"344\":1,\"351\":1}}],[\"锁升级\",{\"0\":{\"330\":1}}],[\"锁维护一个等待线程队列\",{\"1\":{\"264\":1}}],[\"锁工具类locksupport\",{\"0\":{\"233\":1}}],[\"锁粗化\",{\"0\":{\"229\":1}}],[\"锁分离\",{\"0\":{\"228\":1}}],[\"锁的优化思路\",{\"0\":{\"225\":1}}],[\"锁消除\",{\"0\":{\"224\":1}}],[\"锁膨胀\",{\"0\":{\"222\":1}}],[\"偏向锁\",{\"0\":{\"220\":1}}],[\"活锁恰恰与死锁相反\",{\"1\":{\"214\":1}}],[\"活锁livelock\",{\"0\":{\"214\":1}}],[\"导致线程t抛出interruptedexception异常\",{\"1\":{\"346\":1}}],[\"导致低优先级线程无法得到执行\",{\"1\":{\"213\":1}}],[\"导致当前线程等待\",{\"1\":{\"180\":1}}],[\"饥饿starvation\",{\"0\":{\"213\":1}}],[\"执行顺序有可能变成1\",{\"1\":{\"321\":1}}],[\"执行上述的程序\",{\"1\":{\"212\":1}}],[\"执行效率大为提升\",{\"1\":{\"136\":1}}],[\"举个例子\",{\"1\":{\"211\":1}}],[\"形成死锁\",{\"1\":{\"211\":1}}],[\"死锁是大家都拿不到资源都占用着对方的资源\",{\"1\":{\"214\":1}}],[\"死锁是多线程中最差的一种情况\",{\"1\":{\"211\":1}}],[\"死锁的排查\",{\"0\":{\"212\":1}}],[\"死锁deadlock\",{\"0\":{\"211\":1}}],[\"死锁和优先级反转等等\",{\"1\":{\"150\":1}}],[\"结果为\",{\"1\":{\"346\":1}}],[\"结果一直在拉扯不休\",{\"1\":{\"210\":1}}],[\"结束引用\",{\"1\":{\"111\":1}}],[\"势均力敌互不相让\",{\"1\":{\"210\":1}}],[\"都会清除中断标记\",{\"1\":{\"346\":1}}],[\"都会将对象进行回收\",{\"1\":{\"308\":1}}],[\"都判断instance没有被初始化\",{\"1\":{\"317\":1}}],[\"都主动将资源释放给别的线程使用\",{\"1\":{\"214\":1}}],[\"都在让对方先还给自己自己再还\",{\"1\":{\"211\":1}}],[\"都在等待对方线程做些什么\",{\"1\":{\"210\":1}}],[\"都知道数字在计算机中是二进制存储的\",{\"1\":{\"59\":1}}],[\"粗粒度synchronized\",{\"1\":{\"205\":1}}],[\"细粒度synchronized\",{\"1\":{\"205\":1}}],[\"任务开始于给定的初始延时时间\",{\"1\":{\"270\":1}}],[\"任务开始于初始延时时间\",{\"1\":{\"270\":1}}],[\"任务中打印出index值\",{\"1\":{\"269\":1}}],[\"任务会被保存在一个任务队列中\",{\"1\":{\"269\":1}}],[\"任务类必须继承自recursivetask或recursiveaction\",{\"1\":{\"202\":1}}],[\"任何线程都可以通过调用以下三种方法之一进入此状态\",{\"1\":{\"378\":1}}],[\"任何通过抛出interruptedexception退出的方法\",{\"1\":{\"346\":1}}],[\"任何在这个对象上调用await\",{\"1\":{\"180\":1}}],[\"任何试图往里存东西的操作也会被阻断进入等待状态\",{\"1\":{\"142\":1}}],[\"得到线程的状态\",{\"1\":{\"380\":1}}],[\"得到\",{\"1\":{\"194\":3}}],[\"给出去\",{\"1\":{\"194\":3}}],[\"货物\",{\"1\":{\"194\":3}}],[\"金钱\",{\"1\":{\"194\":3}}],[\"两个线程运行同样的代码\",{\"1\":{\"351\":1}}],[\"两个迎面走来的两个绅士互相礼让\",{\"1\":{\"214\":1}}],[\"两个人都相互占用对方的东西\",{\"1\":{\"211\":1}}],[\"两个人完成一笔交易\",{\"1\":{\"194\":1}}],[\"两者返回值都是名为arraylist的类\",{\"1\":{\"75\":1}}],[\"交换器exchanger\",{\"0\":{\"192\":1}}],[\"运动员们便不再等待开始起跑\",{\"1\":{\"186\":1}}],[\"运行的结果如下\",{\"1\":{\"168\":1}}],[\"运行测试\",{\"1\":{\"88\":1}}],[\"他一声枪响\",{\"1\":{\"186\":1}}],[\"他们都需要花些时间热身做准备\",{\"1\":{\"186\":1}}],[\"他们需要一直等待startsignal\",{\"1\":{\"180\":1}}],[\"已经在赛道前的运动员都还只能在等待\",{\"1\":{\"186\":1}}],[\"栅栏\",{\"1\":{\"186\":1}}],[\"裁判员会统计赛道\",{\"1\":{\"186\":1}}],[\"会一直wait被挂起\",{\"1\":{\"378\":1}}],[\"会导致main线程暂停直到t线程结束\",{\"1\":{\"350\":1}}],[\"会被销毀\",{\"1\":{\"269\":1}}],[\"会有一个或多个可用的线程\",{\"1\":{\"269\":1}}],[\"会执行cyclicbarrier第二个参数的逻辑\",{\"1\":{\"186\":1}}],[\"会在赛道上面等待barrier\",{\"1\":{\"186\":1}}],[\"会告知驾驶员自己工作已完成的信号donesignal\",{\"1\":{\"180\":1}}],[\"起跑\",{\"1\":{\"186\":4}}],[\"位没到达\",{\"1\":{\"186\":1}}],[\"准备好了\",{\"1\":{\"186\":4}}],[\"凑齐parties数目的最后一个线程会在放行前运行一次barrieraction操作\",{\"1\":{\"186\":1}}],[\"才能继续后续的行为\",{\"1\":{\"370\":1}}],[\"才能起跑\",{\"1\":{\"186\":1}}],[\"才会将这些线程放行\",{\"1\":{\"186\":1}}],[\"才可以共同触发后续的一个或多个线程的开始工作\",{\"1\":{\"180\":1}}],[\"才可以运行线程4\",{\"1\":{\"180\":1}}],[\"先到的线程得等待后来的线程\",{\"1\":{\"186\":1}}],[\"先准备购买的人必须等待\",{\"1\":{\"186\":1}}],[\"先后经历了几次更新\",{\"1\":{\"65\":1}}],[\"拼购\",{\"1\":{\"186\":1}}],[\"循环次数\",{\"1\":{\"205\":1}}],[\"循环栅栓cyclicbarrier\",{\"0\":{\"185\":1}}],[\"循环长开销大\",{\"0\":{\"155\":1}}],[\"工人完成自己的工作时\",{\"1\":{\"180\":1}}],[\"工作原理\",{\"0\":{\"152\":1}}],[\"于此同时驾驶员在等待所有工人完成工作donesignal\",{\"1\":{\"180\":1}}],[\"于是这个窗口被释放\",{\"1\":{\"257\":1}}],[\"于是客户4得到机会去办理业务\",{\"1\":{\"257\":1}}],[\"于是两开始了无限次的礼让\",{\"1\":{\"214\":1}}],[\"于是两人又都在左边\",{\"1\":{\"214\":1}}],[\"于是五个工人开始了工作\",{\"1\":{\"180\":1}}],[\"于是补码粉墨登场😎\",{\"1\":{\"62\":1}}],[\"于是\",{\"1\":{\"61\":1}}],[\"阻止任何工人开始工作\",{\"1\":{\"180\":2}}],[\"阻塞和非阻塞通常用来形容多线程间的相互影响\",{\"1\":{\"373\":1}}],[\"阻塞\",{\"0\":{\"373\":1,\"377\":1},\"1\":{\"146\":1}}],[\"递减锁存器的计数\",{\"1\":{\"180\":1}}],[\"指令重排序\",{\"0\":{\"362\":1}}],[\"指令重排在单线程环境下不会出现问题\",{\"1\":{\"321\":1}}],[\"指定的等待时间已过\",{\"1\":{\"180\":1}}],[\"指数位\",{\"1\":{\"65\":1}}],[\"指数位和尾数位\",{\"1\":{\"65\":1}}],[\"指数\",{\"1\":{\"65\":1}}],[\"即被释放的线程陆续处理接下来的4个任务\",{\"1\":{\"269\":1}}],[\"即超过corepoolsize的空闲线程\",{\"1\":{\"269\":1}}],[\"即使它们处于空闲状态\",{\"1\":{\"269\":1}}],[\"即多个线程同时去获取许可\",{\"1\":{\"257\":2}}],[\"即当前这个计数器的计数个数\",{\"1\":{\"180\":1}}],[\"即一定数量的线程都完成工作后\",{\"1\":{\"180\":1}}],[\"计时任务\",{\"0\":{\"270\":1}}],[\"计数值不能被重置\",{\"1\":{\"180\":1}}],[\"计算机表现小数的难点就在于小数点后面的数字了\",{\"1\":{\"65\":1}}],[\"计算机连最简单的1\",{\"1\":{\"61\":1}}],[\"计算机的信息都是以二进制形式表示的\",{\"1\":{\"60\":1}}],[\"你是我心上的一把锁\",{\"0\":{\"239\":1}}],[\"你希望创建一组任务\",{\"1\":{\"186\":1}}],[\"你可以向countdownlatch对象设置一个初始计数值\",{\"1\":{\"180\":1}}],[\"你心中的nio\",{\"1\":{\"108\":1}}],[\"你心中的io\",{\"0\":{\"82\":1},\"1\":{\"82\":1}}],[\"今天我们通过一些实例来学习一下它的用法\",{\"1\":{\"179\":1}}],[\"今天我们就通过实例来学习一下exchanger的用法\",{\"1\":{\"192\":1}}],[\"今天我们就通过实例来学习一个condition的用法\",{\"1\":{\"167\":1}}],[\"今天我们就来讲讲gradle是如何对依赖版本进行管理的\",{\"1\":{\"421\":1}}],[\"今天我们就来聊聊这单例\",{\"1\":{\"314\":1}}],[\"今天我们就来看下这个池子中究竟有什么\",{\"1\":{\"268\":1}}],[\"今天我们就来看下这个作为读写锁的升级版\",{\"1\":{\"262\":1}}],[\"今天我们就来学习下java中自带的一些原子类\",{\"1\":{\"134\":1}}],[\"今天我们就来了解下这个文字处理神器\",{\"1\":{\"109\":1}}],[\"今天我们就开始学习一下java中注解的知识\",{\"1\":{\"36\":1}}],[\"允许一个或者多个线程等待某个事件的发生\",{\"1\":{\"179\":1}}],[\"允许子类继承父类中的注解\",{\"1\":{\"37\":1}}],[\"倒计时器countdownlatch\",{\"0\":{\"179\":1}}],[\"相对而言\",{\"1\":{\"175\":1}}],[\"相应的double类型就是1023\",{\"1\":{\"65\":1}}],[\"再把列表b覆盖列表a\",{\"1\":{\"175\":1}}],[\"再将修改完的副本替换原来的数据\",{\"1\":{\"175\":1}}],[\"再到collections\",{\"1\":{\"74\":1}}],[\"写入完成之后\",{\"1\":{\"175\":1}}],[\"写入操作首先得获取对象锁\",{\"1\":{\"175\":1}}],[\"写入也不会阻塞读取操作\",{\"1\":{\"175\":1}}],[\"写完之后\",{\"1\":{\"175\":1}}],[\"读已提交\",{\"0\":{\"413\":1}}],[\"读未提交\",{\"0\":{\"412\":1}}],[\"读写锁readwritelock\",{\"0\":{\"240\":1}}],[\"读取代码没有任何同步控制和锁操作\",{\"1\":{\"175\":1}}],[\"读取是完全不用加锁的\",{\"1\":{\"175\":1}}],[\"读与写可以同步进行\",{\"1\":{\"173\":1}}],[\"条件condition\",{\"0\":{\"167\":1}}],[\"优先级的数字越大则优先级越高\",{\"1\":{\"348\":1}}],[\"优先级高的线程能够插队并优先执行\",{\"1\":{\"213\":1}}],[\"优先推荐bigdecimal\",{\"1\":{\"96\":1}}],[\"优缺点\",{\"0\":{\"153\":1}}],[\"把这种竞争失败的处理交由给开发人员\",{\"1\":{\"150\":1}}],[\"线程t1没准已经执行完改变了状态\",{\"1\":{\"376\":1}}],[\"线程t1执行了1和3\",{\"1\":{\"321\":1}}],[\"线程调度程序\",{\"1\":{\"376\":1}}],[\"线程被创建到start\",{\"1\":{\"375\":1}}],[\"线程被挂起\",{\"1\":{\"347\":1}}],[\"线程处于runnable状态\",{\"1\":{\"374\":1}}],[\"线程对象被创建\",{\"1\":{\"374\":1}}],[\"线程生命周期\",{\"0\":{\"374\":1}}],[\"线程到底是个什么东西\",{\"1\":{\"367\":1}}],[\"线程join和yield\",{\"0\":{\"349\":1}}],[\"线程优先级\",{\"0\":{\"348\":1}}],[\"线程waitthread首先获得waitnotifythread\",{\"1\":{\"347\":1}}],[\"线程wait和notify\",{\"0\":{\"347\":1}}],[\"线程在执行中遇到了类似于synchronized同步块\",{\"1\":{\"374\":1}}],[\"线程在执行完毕后就会结束\",{\"1\":{\"345\":1}}],[\"线程在竞争cas失败时不会阻塞\",{\"1\":{\"150\":1}}],[\"线程的状态从new变成了runnable\",{\"1\":{\"376\":1}}],[\"线程的状态是\",{\"1\":{\"375\":1}}],[\"线程的优先级将该线程的重要性传递给了调度器\",{\"1\":{\"348\":1}}],[\"线程的中断\",{\"0\":{\"346\":1}}],[\"线程的终止\",{\"0\":{\"345\":1}}],[\"线程的暂停\",{\"0\":{\"344\":1}}],[\"线程的创建有两种方式\",{\"1\":{\"341\":1}}],[\"线程的创建\",{\"0\":{\"341\":1}}],[\"线程的使用\",{\"0\":{\"340\":1}}],[\"线程的顺序是3241\",{\"1\":{\"269\":1}}],[\"线程界的清流threadlocal\",{\"0\":{\"334\":1}}],[\"线程池的拓展\",{\"0\":{\"273\":1}}],[\"线程池的原理\",{\"0\":{\"272\":1}}],[\"线程池的线程数量不确定\",{\"1\":{\"269\":1}}],[\"线程池大小是1\",{\"1\":{\"269\":1}}],[\"线程池一般都是由executors这个工厂类来创建\",{\"1\":{\"269\":1}}],[\"线程池里面保存的是线程而不是数据库连接\",{\"1\":{\"269\":1}}],[\"线程工厂\",{\"1\":{\"269\":1}}],[\"线程是操作系统的资源\",{\"1\":{\"268\":1}}],[\"线程安全synchronized\",{\"0\":{\"325\":1}}],[\"线程安全的单例模式\",{\"0\":{\"314\":1}}],[\"线程安全\",{\"1\":{\"244\":1}}],[\"线程请上锁\",{\"1\":{\"239\":1}}],[\"线程\",{\"1\":{\"226\":1,\"352\":1}}],[\"线程多了还不行\",{\"1\":{\"192\":1}}],[\"线程之间的协作姿势千姿百态\",{\"1\":{\"192\":1}}],[\"线程状态runnable\",{\"1\":{\"186\":1}}],[\"线程状态waiting\",{\"1\":{\"186\":1}}],[\"线程放行\",{\"1\":{\"186\":1}}],[\"线程可以通过等待之前必须调用countdown的次数\",{\"1\":{\"180\":1}}],[\"线程可以自行处理\",{\"1\":{\"150\":1}}],[\"线程2和线程3中都运行结束后\",{\"1\":{\"180\":1}}],[\"大部分情况两个线程是交替执行\",{\"1\":{\"351\":1}}],[\"大家都好了\",{\"1\":{\"186\":2}}],[\"大多数处理器架构中\",{\"1\":{\"150\":1}}],[\"大小\",{\"1\":{\"64\":1}}],[\"贴出add的方法\",{\"1\":{\"146\":1}}],[\"检查\",{\"1\":{\"146\":1}}],[\"检查远程接口是否打开\",{\"1\":{\"88\":1}}],[\"删除\",{\"1\":{\"146\":1}}],[\"插入\",{\"1\":{\"146\":1}}],[\"超时时间为5秒\",{\"1\":{\"379\":1}}],[\"超时等待\",{\"0\":{\"379\":1}}],[\"超时\",{\"1\":{\"146\":1}}],[\"操作\",{\"1\":{\"146\":1}}],[\"效率修改优于查询\",{\"1\":{\"143\":1}}],[\"效率查询优于修改\",{\"1\":{\"143\":1}}],[\"直至monitor计数器为0时\",{\"1\":{\"328\":1}}],[\"直至所有任务都完成\",{\"1\":{\"186\":1}}],[\"直至这个计数值达到0\",{\"1\":{\"180\":1}}],[\"直到获得请求的锁\",{\"1\":{\"374\":1}}],[\"直到用卫生间的人欣然走出😌\",{\"1\":{\"372\":1}}],[\"直到最后一个线程到达\",{\"1\":{\"186\":1}}],[\"直到要购买的人数达到一定值时才开团\",{\"1\":{\"186\":1}}],[\"直到驾驶员发送开始的信号\",{\"1\":{\"180\":1}}],[\"直到驾驶员准备好让他们继续操作\",{\"1\":{\"180\":1}}],[\"直到司机准备好\",{\"1\":{\"180\":1}}],[\"直到锁存器倒数为零或者线程被中断\",{\"1\":{\"180\":1}}],[\"直到blockingqueue里有空间才会被唤醒继续操作\",{\"1\":{\"142\":1}}],[\"直到blockingqueue进了东西才会被唤醒\",{\"1\":{\"142\":1}}],[\"直接上tolist方法\",{\"1\":{\"78\":1}}],[\"输出将是\",{\"1\":{\"379\":1}}],[\"输出的结果不确定\",{\"1\":{\"360\":1}}],[\"输出的日志中带有connection\",{\"1\":{\"88\":1}}],[\"输出不确定\",{\"1\":{\"257\":1,\"351\":1}}],[\"输出\",{\"1\":{\"234\":1}}],[\"输出结果是\",{\"1\":{\"241\":1,\"269\":1,\"270\":1,\"345\":1}}],[\"输出结果\",{\"1\":{\"186\":1,\"194\":1,\"211\":1,\"213\":1,\"234\":1,\"327\":1,\"329\":1,\"359\":1}}],[\"输出结果为\",{\"1\":{\"180\":1,\"248\":1}}],[\"输出结果如下\",{\"1\":{\"137\":1,\"142\":1,\"174\":1,\"205\":1,\"346\":1}}],[\"为每个线程分配固定的时间片\",{\"1\":{\"376\":1}}],[\"为每个对象提供多个等待set\",{\"1\":{\"167\":1}}],[\"为什么有依赖版本冲突\",{\"0\":{\"422\":1}}],[\"为什么让人如此的着迷\",{\"1\":{\"367\":1}}],[\"为什么叫重入锁\",{\"0\":{\"248\":1}}],[\"为instance分配内存空间\",{\"1\":{\"321\":1}}],[\"为此\",{\"1\":{\"149\":1}}],[\"为例子来介绍\",{\"1\":{\"135\":1}}],[\"为了支持多线程之间的协作\",{\"1\":{\"347\":1}}],[\"为了线程间共享数据的安全性\",{\"1\":{\"149\":1}}],[\"为了展开后面的学习\",{\"1\":{\"110\":1}}],[\"为了方便存储与计算效率\",{\"1\":{\"64\":1}}],[\"原因是第四行的代码是在main线程中执行\",{\"1\":{\"376\":1}}],[\"原因如下\",{\"1\":{\"343\":2}}],[\"原子性\",{\"0\":{\"298\":1,\"402\":1}}],[\"原子性是由硬件指令支持的\",{\"1\":{\"151\":1}}],[\"原子操作\",{\"0\":{\"151\":1}}],[\"原子类都存放在java\",{\"1\":{\"135\":1}}],[\"原码是最符合人直观的数值二进制表示\",{\"1\":{\"63\":1}}],[\"原码是10000000\",{\"1\":{\"63\":1}}],[\"原码\",{\"1\":{\"61\":6,\"62\":2,\"63\":2}}],[\"掌握junit5\",{\"0\":{\"127\":1},\"1\":{\"127\":1}}],[\"理解timezone\",{\"0\":{\"125\":1}}],[\"匹配标志位\",{\"0\":{\"120\":1}}],[\"匹配\",{\"1\":{\"119\":4}}],[\"匹配次数量词\",{\"0\":{\"114\":1}}],[\"同一时刻只有一个任务在执行\",{\"1\":{\"371\":1}}],[\"同步方法调用一旦开始\",{\"1\":{\"370\":1}}],[\"同步和异步通常用来形容一次方法调用\",{\"1\":{\"370\":1}}],[\"同步\",{\"0\":{\"370\":1}}],[\"同步代码将必须采取许多额外的预防措施\",{\"1\":{\"248\":1}}],[\"同步代码直接或间接调用包含同步代码的方法\",{\"1\":{\"248\":1}}],[\"同时创建了8个任务\",{\"1\":{\"269\":1}}],[\"同时b想让a通过也往右礼让\",{\"1\":{\"214\":1}}],[\"同时也引入了stream的流式操作\",{\"1\":{\"78\":1}}],[\"同时也简化整数的加减法计算\",{\"1\":{\"63\":1}}],[\"同样如果blockingqueue是满的\",{\"1\":{\"142\":1}}],[\"同样的有负后顾\",{\"1\":{\"119\":1}}],[\"同样的有负前瞻\",{\"1\":{\"119\":1}}],[\"零宽\",{\"1\":{\"119\":2}}],[\"前四个任务立马得到了执行\",{\"1\":{\"269\":1}}],[\"前瞻后顾\",{\"0\":{\"119\":1}}],[\"前提是\",{\"1\":{\"111\":1}}],[\"或者说持有多少次锁\",{\"1\":{\"248\":1}}],[\"或者啥都不干直接退出\",{\"1\":{\"150\":1}}],[\"或者执行一些恢复操作\",{\"1\":{\"150\":1}}],[\"或者发生在上一个匹配的末尾\",{\"1\":{\"118\":1}}],[\"或者您可能想知道匹配是否发生在单词边界上\",{\"1\":{\"118\":1}}],[\"或者方法签名对不上被覆盖的方法\",{\"1\":{\"37\":1}}],[\"边界匹配\",{\"0\":{\"118\":1}}],[\"稍后可以通过反向引用\",{\"1\":{\"117\":1}}],[\"定义一个与一行中的两个数字匹配的捕获组\",{\"1\":{\"117\":1}}],[\"后面执行完释放了锁\",{\"1\":{\"347\":1}}],[\"后面跟相同的两个数字\",{\"1\":{\"117\":1}}],[\"后发现instance不为空\",{\"1\":{\"321\":1}}],[\"后跟一个指示要调用的组编号的数字n\",{\"1\":{\"117\":1}}],[\"后续就可以根据此编号来取某个组的匹配内容\",{\"1\":{\"116\":1}}],[\"与之对应的是用户线程\",{\"1\":{\"352\":1}}],[\"与之相关的有以下三个thread类中的方法\",{\"1\":{\"346\":1}}],[\"与多线程并发执行的线程安全不同\",{\"1\":{\"327\":1}}],[\"与synchronized略有不同\",{\"1\":{\"247\":1}}],[\"与死锁不同的是饥饿在以后一段时间内还是能够得到执行的\",{\"1\":{\"213\":1}}],[\"与take相似的方法poll不会阻塞\",{\"1\":{\"143\":1}}],[\"与put相似的方法offer不会阻塞\",{\"1\":{\"143\":1}}],[\"与捕获组匹配的输入字符串部分保存在内存中\",{\"1\":{\"117\":1}}],[\"与函数式接口结合\",{\"1\":{\"49\":1}}],[\"反向引用在正则表达式中指定为反斜杠\",{\"1\":{\"117\":1}}],[\"反向引用\",{\"0\":{\"117\":1}}],[\"反码和补码\",{\"1\":{\"63\":1}}],[\"反码在原码基础之上\",{\"1\":{\"63\":1}}],[\"反码为11111111\",{\"1\":{\"63\":1}}],[\"反码\",{\"1\":{\"62\":6}}],[\"反码对于正数就是原码本身\",{\"1\":{\"62\":1}}],[\"了解组的编号至关重要\",{\"1\":{\"116\":1}}],[\"了解数字\",{\"1\":{\"59\":1}}],[\"还同时拥有可见性\",{\"1\":{\"360\":1}}],[\"还是分给了t1\",{\"1\":{\"351\":1}}],[\"还是会映射到新列表上面的\",{\"1\":{\"77\":1}}],[\"还有2位没到达\",{\"1\":{\"186\":1}}],[\"还有1位没到达\",{\"1\":{\"186\":1}}],[\"还有0位没到达\",{\"1\":{\"186\":1}}],[\"还有\",{\"1\":{\"186\":1}}],[\"还有一个特殊的组\",{\"1\":{\"116\":1}}],[\"组的编号\",{\"0\":{\"116\":1}}],[\"捕获组通过从左到右计算其左括号来进行编号\",{\"1\":{\"116\":1}}],[\"捕获组是将多个字符视为一个单元的一种方法\",{\"1\":{\"115\":1}}],[\"捕获组\",{\"0\":{\"115\":1}}],[\"然而事实却没那么简单\",{\"1\":{\"114\":1}}],[\"然后在markdown中使用上传完成返回文件的url\",{\"1\":{\"428\":1}}],[\"然后在进行下一个步骤之前等待\",{\"1\":{\"186\":1}}],[\"然后自己博客的资源文件存放在何处呢\",{\"1\":{\"428\":1}}],[\"然后我们需要使用\",{\"1\":{\"386\":1}}],[\"然后将控制权交给其他runnable线程\",{\"1\":{\"376\":1}}],[\"然后把这个接口作为参数传递给thread即可\",{\"1\":{\"343\":1}}],[\"然后通过将自己作为key取得内部的实际数据\",{\"1\":{\"336\":1}}],[\"然后通过getmap拿到线程的threadlocalmap\",{\"1\":{\"336\":1}}],[\"然后多个线程都进行了初始化\",{\"1\":{\"317\":1}}],[\"然后两人又同时开始礼让对方\",{\"1\":{\"214\":1}}],[\"然后两线程以安全的方式交换彼此的数据\",{\"1\":{\"194\":1}}],[\"然后可以看到包含如下的输出信息\",{\"1\":{\"212\":1}}],[\"然后使用jstack\",{\"1\":{\"212\":1}}],[\"然后使用jps\",{\"1\":{\"212\":1}}],[\"然后裁判员知道所有的运动员到齐之后\",{\"1\":{\"186\":1}}],[\"然后对现有的列表a进行一次复制\",{\"1\":{\"175\":1}}],[\"然后打印出匹配的字符串以及相应的index\",{\"1\":{\"110\":1}}],[\"然后这个list调用了addall\",{\"1\":{\"78\":1}}],[\"乍一看\",{\"1\":{\"114\":1}}],[\"比较推荐的是实现runnable接口的这种方式\",{\"1\":{\"341\":1}}],[\"比方说1212或者大大方方这类的叠词\",{\"1\":{\"114\":1}}],[\"比如一个线程占用了临界区资源\",{\"1\":{\"373\":1}}],[\"比如垃圾回收器\",{\"1\":{\"352\":1}}],[\"比如sleep\",{\"1\":{\"346\":1}}],[\"比如q\",{\"1\":{\"119\":1}}],[\"比如说转账业务a向b转账\",{\"1\":{\"345\":1}}],[\"比如说\",{\"1\":{\"111\":1,\"112\":1}}],[\"比如说正则表达式为foo并且输入字符串为foo\",{\"1\":{\"111\":1}}],[\"比如说该整数类型的位数是8\",{\"1\":{\"61\":1}}],[\"比如下面实际存储的值就是\",{\"1\":{\"96\":1}}],[\"比如\",{\"1\":{\"45\":1,\"90\":1,\"112\":2,\"119\":1}}],[\"则完全由目标线程自行决定\",{\"1\":{\"346\":1}}],[\"则只能等待其它线程释放锁资源\",{\"1\":{\"328\":1}}],[\"则monitor计数器累加1\",{\"1\":{\"328\":1}}],[\"则说明当前线程可直接获取当前锁对象\",{\"1\":{\"328\":1}}],[\"则会创建新的线程处理任务\",{\"1\":{\"269\":1}}],[\"则会优先使用可复用的线程\",{\"1\":{\"269\":1}}],[\"则线程会等待直到有其它线程释放一个许可或者当前线程被中断\",{\"1\":{\"257\":1}}],[\"则表示栅栏要放行了\",{\"1\":{\"186\":1}}],[\"则表示q后面必须不是u\",{\"1\":{\"119\":1}}],[\"则释放所有等待线程\",{\"1\":{\"180\":1}}],[\"则可以使用cyclicbarrier\",{\"1\":{\"180\":1}}],[\"则当前线程就不做v值的更新\",{\"1\":{\"150\":1}}],[\"则执行正常的出队操作\",{\"1\":{\"143\":1}}],[\"则执行正常的入队操作\",{\"1\":{\"143\":1}}],[\"则必须在反斜杠前面加上另一个反斜杠才能编译字符串\",{\"1\":{\"113\":1}}],[\"则选择\",{\"1\":{\"100\":1}}],[\"开启caching\",{\"0\":{\"386\":1}}],[\"开头的结构称为转义结构\",{\"1\":{\"113\":1}}],[\"开始引用\",{\"1\":{\"111\":1}}],[\"尽可能使用它\",{\"1\":{\"113\":1}}],[\"预定义字符比较简洁\",{\"1\":{\"113\":1}}],[\"预定义字符\",{\"0\":{\"113\":1}}],[\"包含1和9这两个字符\",{\"1\":{\"112\":1}}],[\"包含首尾字符\",{\"1\":{\"112\":1}}],[\"包含了大量的函数式的接口\",{\"1\":{\"44\":1}}],[\"zero\",{\"1\":{\"114\":1,\"119\":1}}],[\"z\",{\"1\":{\"112\":10,\"113\":1,\"118\":2}}],[\"za\",{\"1\":{\"112\":1,\"113\":1}}],[\"zshrc\",{\"1\":{\"15\":1}}],[\"zsh\",{\"1\":{\"15\":2}}],[\"描述说明\",{\"1\":{\"112\":1,\"113\":1}}],[\"内存读写屏障\",{\"1\":{\"361\":1}}],[\"内存屏障\",{\"1\":{\"151\":1}}],[\"内\",{\"1\":{\"111\":1}}],[\"和运行中\",{\"1\":{\"374\":1}}],[\"和非阻塞\",{\"0\":{\"373\":1}}],[\"和并行\",{\"0\":{\"371\":1}}],[\"和异步\",{\"0\":{\"370\":1}}],[\"和notifyall\",{\"1\":{\"347\":1}}],[\"和join\",{\"1\":{\"346\":1}}],[\"和上面的写法很类似\",{\"1\":{\"319\":1}}],[\"和没有引用几乎是一样的\",{\"1\":{\"309\":1}}],[\"和acquire方法类似\",{\"1\":{\"257\":1}}],[\"和getholdcount\",{\"1\":{\"248\":1}}],[\"和countdownlatch非常类似\",{\"1\":{\"185\":1}}],[\"和x\",{\"1\":{\"114\":1}}],[\"和\",{\"1\":{\"111\":1}}],[\"和00000000\",{\"1\":{\"62\":1}}],[\"queue\",{\"1\":{\"142\":4,\"146\":1}}],[\"q在前面\",{\"1\":{\"111\":1}}],[\"q和\",{\"1\":{\"111\":1}}],[\"qab\",{\"1\":{\"111\":1}}],[\"q\",{\"1\":{\"111\":3,\"119\":2}}],[\"^0\",{\"1\":{\"113\":1}}],[\"^345\",{\"1\":{\"112\":1}}],[\"^ab\",{\"1\":{\"112\":1}}],[\"^abc\",{\"1\":{\"112\":1}}],[\"^m\",{\"1\":{\"112\":1}}],[\"^bc\",{\"1\":{\"112\":1}}],[\"^\",{\"1\":{\"111\":1,\"113\":2,\"118\":1}}],[\"元字符之前加一个反斜杠\",{\"1\":{\"111\":1}}],[\"元字符有<\",{\"1\":{\"111\":1}}],[\"元注解\",{\"1\":{\"37\":1}}],[\"元注解专职负责注解其他的注解\",{\"1\":{\"37\":1}}],[\"范围包含起始索引但不包含结束索引\",{\"1\":{\"111\":1}}],[\"year\",{\"1\":{\"433\":1}}],[\"yield\",{\"1\":{\"351\":3}}],[\"yieldthread\",{\"1\":{\"351\":4}}],[\"yield是一种启发式尝试\",{\"1\":{\"351\":1}}],[\"yield方法对于调试或测试目的可能很有用\",{\"1\":{\"351\":1}}],[\"yield方法的作用是放弃当前的cpu资源\",{\"1\":{\"351\":1}}],[\"yield方法\",{\"0\":{\"351\":1}}],[\"your\",{\"1\":{\"110\":1,\"111\":7,\"117\":2}}],[\"yaml\",{\"1\":{\"13\":1,\"14\":4}}],[\"由于waitthread已经释放了锁\",{\"1\":{\"347\":1}}],[\"由于垃圾回收器的线程通常优先级很低\",{\"1\":{\"308\":1}}],[\"由于线程池支持定时的任务\",{\"1\":{\"270\":1}}],[\"由于客户4业务比较简单只花了7秒钟就完成了\",{\"1\":{\"257\":1}}],[\"由于是二进制的科学计数法\",{\"1\":{\"65\":1}}],[\"由pattern对象中的matcher方法生成\",{\"1\":{\"110\":1}}],[\"由带参数的静态函数创建\",{\"1\":{\"110\":1}}],[\"表达正则肯定是用对象了\",{\"1\":{\"110\":1}}],[\"表示银行业务办理窗口的数量\",{\"1\":{\"257\":1}}],[\"表示一次性可以操作多个许可\",{\"1\":{\"257\":1}}],[\"表示驾驶员发送了开始的信号\",{\"1\":{\"180\":1}}],[\"表示q后面必须是u\",{\"1\":{\"119\":1}}],[\"表示匹配一个数字\",{\"1\":{\"113\":1}}],[\"表示且的关系\",{\"1\":{\"112\":1}}],[\"表示范围\",{\"1\":{\"112\":1}}],[\"表示任意字符\",{\"1\":{\"111\":1}}],[\"表示正则表达式模式中存在语法错误\",{\"1\":{\"110\":1}}],[\"表示符号\",{\"1\":{\"65\":1}}],[\"表示成二进制之后成了循环体为1001的无限循环小数\",{\"1\":{\"65\":1}}],[\"表示需要在什么级别保存该注解信息\",{\"1\":{\"37\":1}}],[\"表示该注解可以用于什么地方\",{\"1\":{\"37\":1}}],[\"表示当前的方法定义将覆盖超类中的方法\",{\"1\":{\"37\":1}}],[\"各个语言实现的版本具有差异化\",{\"1\":{\"110\":1}}],[\"编辑器上下分页滚动\",{\"1\":{\"426\":1}}],[\"编辑或操作文本和数据\",{\"1\":{\"110\":1}}],[\"编译报错\",{\"1\":{\"113\":1}}],[\"编译量就是127\",{\"1\":{\"65\":1}}],[\"编译器都会识别这个重载函数\",{\"1\":{\"45\":1}}],[\"编译器就会发出错误提示\",{\"1\":{\"37\":1}}],[\"主要用于调试和断言\",{\"1\":{\"186\":1}}],[\"主要在于它在文字处理方面展现出恐怖而全面的能力\",{\"1\":{\"109\":1}}],[\"主要是为了简化函数式编程的语法和提高代码的可读性\",{\"1\":{\"56\":1}}],[\"网络io\",{\"1\":{\"108\":1}}],[\"缓冲区\",{\"1\":{\"108\":1}}],[\"通知或中断\",{\"1\":{\"374\":1}}],[\"通过继承thread类\",{\"1\":{\"342\":1}}],[\"通过分解任务\",{\"1\":{\"202\":1}}],[\"通过反射的方式获取unsafe\",{\"1\":{\"137\":1}}],[\"通过对比可以得知\",{\"1\":{\"77\":1}}],[\"通道\",{\"1\":{\"108\":1}}],[\"新版io\",{\"0\":{\"108\":1}}],[\"新的列表也没有影响\",{\"1\":{\"77\":1}}],[\"之前介绍的synchronized关键字就是一种最简单的同步控制方法\",{\"1\":{\"246\":1}}],[\"之前说的\",{\"1\":{\"63\":1}}],[\"之后线程1和2继续运行\",{\"1\":{\"194\":1}}],[\"之间\",{\"1\":{\"112\":1}}],[\"之所以调用setdaemon方法\",{\"1\":{\"378\":1}}],[\"之所以推崇使用实现runnable接口这种方式\",{\"1\":{\"343\":1}}],[\"之所以不用重写thread类的run\",{\"1\":{\"343\":1}}],[\"之所以整出这么多的引用类型\",{\"1\":{\"305\":1}}],[\"之所以叫重入锁\",{\"1\":{\"248\":1}}],[\"之所以正则经久不衰\",{\"1\":{\"109\":1}}],[\"之所以使用try是因为只想静态的mock在try块中生效\",{\"1\":{\"103\":1}}],[\"首先要引入依赖\",{\"1\":{\"386\":1}}],[\"首先获得当前线程对象\",{\"1\":{\"336\":1}}],[\"首先使用mocktio\",{\"1\":{\"103\":1}}],[\"首先如果在项目中使用mocktio\",{\"1\":{\"99\":1}}],[\"让出调度\",{\"1\":{\"351\":1}}],[\"让驾驶员等待直到所有工作人员完成任务\",{\"1\":{\"180\":1}}],[\"让mock变得从未如此简单\",{\"1\":{\"103\":1}}],[\"让人抓狂的exception\",{\"0\":{\"41\":1}}],[\"无法精准控制\",{\"1\":{\"348\":1}}],[\"无法直接模拟静态方法\",{\"1\":{\"103\":1}}],[\"无须手工关闭\",{\"1\":{\"345\":1}}],[\"无论如何\",{\"1\":{\"344\":1}}],[\"无论你是否标注了\",{\"1\":{\"45\":1}}],[\"无锁宗师cas\",{\"0\":{\"149\":1}}],[\"无构造函数\",{\"1\":{\"110\":1}}],[\"无所不能的正则\",{\"0\":{\"109\":1}}],[\"版本之前\",{\"1\":{\"103\":1}}],[\"该线程才处于活动状态\",{\"1\":{\"380\":1}}],[\"该线程进入睡眠状态\",{\"1\":{\"379\":1}}],[\"该线程处于waiting状态\",{\"1\":{\"378\":1}}],[\"该线程就处于blocked状态\",{\"1\":{\"377\":1}}],[\"该线程就是waitthread\",{\"1\":{\"347\":1}}],[\"该线程已经执行完毕\",{\"1\":{\"374\":1}}],[\"该方法也返回一个scheduledexecutorservice对象\",{\"1\":{\"269\":1}}],[\"该方法用于获取捕获的所有参数值\",{\"1\":{\"102\":1}}],[\"该队列将仅保存由execute方法提交的runnable任务\",{\"1\":{\"269\":1}}],[\"该接口有且只有一个抽象方法\",{\"1\":{\"45\":1}}],[\"接下来就到了配置upic客户端的环节了\",{\"1\":{\"431\":1}}],[\"接下来就让我们来看下线程同步的辅助类semaphore\",{\"1\":{\"256\":1}}],[\"接下来我们给出一个比较复杂的例子\",{\"1\":{\"102\":1}}],[\"接收控制台的正则表达式和字符串输入\",{\"1\":{\"110\":1}}],[\"接受参数\",{\"0\":{\"51\":1,\"52\":1,\"53\":1}}],[\"测试用例\",{\"0\":{\"205\":1}}],[\"测试例子中\",{\"1\":{\"102\":1}}],[\"测试你得这样写\",{\"0\":{\"73\":1}}],[\"演示了argumentcaptor的使用\",{\"1\":{\"102\":1}}],[\"验证参数值\",{\"1\":{\"102\":1}}],[\"并设置为守护线程\",{\"1\":{\"352\":1}}],[\"并设置当前中断状态为false\",{\"1\":{\"346\":1}}],[\"并在synchronized块中调用了wait\",{\"1\":{\"378\":1}}],[\"并在index为偶数的时候\",{\"1\":{\"351\":1}}],[\"并在上面吃饭\",{\"1\":{\"226\":1}}],[\"并通知jvm中断目标线程\",{\"1\":{\"346\":1}}],[\"并通过when和thenreturn方法模拟了静态方法的返回值\",{\"1\":{\"103\":1}}],[\"并通过captor\",{\"1\":{\"102\":1}}],[\"并让此线程调用run\",{\"1\":{\"341\":1}}],[\"并将值设入threadlocalmap中\",{\"1\":{\"336\":1}}],[\"并不一定能很快地发现持有弱引用的对象\",{\"1\":{\"308\":1}}],[\"并不修改原有的内容\",{\"1\":{\"175\":1}}],[\"并使用类似如下代码判断前序节点是杏已经成功释放锁\",{\"1\":{\"264\":1}}],[\"并发与并行\",{\"1\":{\"371\":1}}],[\"并发和并行都可以表示多个任务一起执行\",{\"1\":{\"371\":1}}],[\"并发\",{\"0\":{\"371\":1}}],[\"并发liveness问题\",{\"0\":{\"210\":1}}],[\"并发量\",{\"1\":{\"205\":1}}],[\"并行执行\",{\"1\":{\"202\":1}}],[\"并把整数42写入此内存地址中\",{\"1\":{\"137\":1}}],[\"并且这种优先级产生的后果也可能不容易预测\",{\"1\":{\"348\":1}}],[\"并且\",{\"1\":{\"309\":1}}],[\"并且可以保证fifo的服务顺序\",{\"1\":{\"264\":1}}],[\"并且两组代码使用相同的锁\",{\"1\":{\"248\":1}}],[\"并且更好的消息是\",{\"1\":{\"175\":1}}],[\"并且分别verify了两次调用参数的值\",{\"1\":{\"102\":1}}],[\"并且每次参数还不一样\",{\"1\":{\"102\":1}}],[\"并进行相应的验证\",{\"1\":{\"102\":1}}],[\"并指定要捕获的参数类型\",{\"1\":{\"102\":1}}],[\"并简化测试代码的编写\",{\"1\":{\"99\":1}}],[\"创建完用户之后\",{\"1\":{\"431\":1}}],[\"创建用户并勾选其编程访问\",{\"1\":{\"431\":1}}],[\"创建用户用于访问bucket\",{\"0\":{\"431\":1}}],[\"创建bucket完之后\",{\"1\":{\"430\":1}}],[\"创建线程直接简单的方式就是\",{\"1\":{\"342\":1}}],[\"创建一个周期性任务\",{\"1\":{\"270\":1}}],[\"创建并执行一个周期性任务\",{\"1\":{\"270\":1}}],[\"创建argumentcaptor对象\",{\"1\":{\"102\":1}}],[\"创建新对象\",{\"1\":{\"49\":1}}],[\"至于目标线程接到通知后如何处理\",{\"1\":{\"346\":1}}],[\"至于原因\",{\"1\":{\"113\":1}}],[\"至于thenthrow和dothrow的区别\",{\"1\":{\"101\":1}}],[\"至于doreturn和thenreturn的区别\",{\"1\":{\"101\":1}}],[\"注意设置bucket是公开可读\",{\"1\":{\"430\":1}}],[\"注意\",{\"1\":{\"342\":1}}],[\"注意threadlocalmap是thread类的成员变量\",{\"1\":{\"336\":1}}],[\"注入模拟对象和捕获方法参数等\",{\"1\":{\"99\":1}}],[\"注解\",{\"0\":{\"37\":1},\"1\":{\"100\":1}}],[\"注解是众多引入到java\",{\"1\":{\"36\":1}}],[\"注解annotation\",{\"0\":{\"36\":1}}],[\"基础使用\",{\"0\":{\"99\":1}}],[\"基本上已经被用于所有计算机中\",{\"1\":{\"65\":1}}],[\"基本类型\",{\"1\":{\"64\":1}}],[\"层级之间可能存在依赖\",{\"1\":{\"98\":1}}],[\"特别是spring\",{\"1\":{\"98\":1}}],[\"当且仅当线程已启动且尚未死亡时\",{\"1\":{\"380\":1}}],[\"当t1启动之后首先进入synchronized代码块中\",{\"1\":{\"377\":1}}],[\"当它等待监视器锁并尝试访问被其他线程锁定的代码段时\",{\"1\":{\"377\":1}}],[\"当创建的线程调用了start\",{\"1\":{\"376\":1}}],[\"当run\",{\"1\":{\"374\":1}}],[\"当进程中所有的用户线程结束\",{\"1\":{\"352\":1}}],[\"当锁被成功获得后\",{\"1\":{\"347\":1}}],[\"当一个线程被中断\",{\"1\":{\"346\":1}}],[\"当一个线程试图获得锁时\",{\"1\":{\"264\":1}}],[\"当执行完synchronized锁对象的代码后\",{\"1\":{\"328\":1}}],[\"当执行monitorenter命令时\",{\"1\":{\"328\":1}}],[\"当前线程能再次获取到锁\",{\"1\":{\"328\":1}}],[\"当垃圾回收器准备回收一个对象时\",{\"1\":{\"309\":1}}],[\"当试图通过虚引用的get\",{\"1\":{\"309\":1}}],[\"当有任务提交时\",{\"1\":{\"269\":1}}],[\"当有大量的读线程\",{\"1\":{\"262\":1}}],[\"当任务太多来不及处理\",{\"1\":{\"269\":1}}],[\"当任务进入栅栏时\",{\"1\":{\"193\":1}}],[\"当你完成工作时\",{\"1\":{\"269\":1}}],[\"当需要使用线程时\",{\"1\":{\"269\":1}}],[\"当多个线程同时执行到第7行\",{\"1\":{\"317\":1}}],[\"当多个线程尝试使用cas更新同一个变量时\",{\"1\":{\"150\":1}}],[\"当多线程中出现了相互谦让\",{\"1\":{\"214\":1}}],[\"当线程完成执行或被异常终止时\",{\"1\":{\"380\":1}}],[\"当线程a等待另一个线程b在规定的时间内执行特定操作时\",{\"1\":{\"379\":1}}],[\"当线程等待其他线程执行特定操作时\",{\"1\":{\"378\":1}}],[\"当线程当前不符合运行条件时\",{\"1\":{\"377\":1}}],[\"当线程池线程数量超过corepoolsize时\",{\"1\":{\"269\":1}}],[\"当线程1调用exchange对象的exchange\",{\"1\":{\"194\":1}}],[\"当线程到达栅栏时\",{\"1\":{\"186\":1}}],[\"当他们离开时\",{\"1\":{\"193\":1}}],[\"当他们准备好后\",{\"1\":{\"186\":1}}],[\"当驾驶员收到所有工人完成工作的信号后\",{\"1\":{\"180\":1}}],[\"当v的值不等于e时\",{\"1\":{\"150\":1}}],[\"当v的值等于e时\",{\"1\":{\"150\":1}}],[\"当我们打印线程t1状态时\",{\"1\":{\"378\":1}}],[\"当我们调用t\",{\"1\":{\"350\":1}}],[\"当我们为copyonwritearraylist创建迭代器时\",{\"1\":{\"174\":1}}],[\"当我们使用\",{\"1\":{\"113\":1}}],[\"当我们在想要测试某个方法被调用\",{\"1\":{\"102\":1}}],[\"当然包括aliyun\",{\"1\":{\"432\":1}}],[\"当然sleep时间不能保证精确\",{\"1\":{\"344\":1}}],[\"当然上述方法都有带permits额外参数的重载方法\",{\"1\":{\"257\":1}}],[\"当然还有一种饥饿的情况\",{\"1\":{\"213\":1}}],[\"当然如果是使用springboot\",{\"1\":{\"99\":1}}],[\"当然对比于运算速度\",{\"1\":{\"96\":1}}],[\"当涉及到金钱\",{\"1\":{\"96\":1}}],[\"当通过\",{\"1\":{\"91\":1}}],[\"此外在睡眠期间还可以被中断终止\",{\"1\":{\"344\":1}}],[\"此线程不再持有这个锁\",{\"1\":{\"248\":1}}],[\"此线程仍旧持有这个锁\",{\"1\":{\"248\":1}}],[\"此时如果占用资源的线程一直不愿意释放资源\",{\"1\":{\"373\":1}}],[\"此时输出结果为\",{\"1\":{\"347\":1}}],[\"此时waitthread要么被其他线程通知唤醒\",{\"1\":{\"347\":1}}],[\"此时waitthread处于blocked状态\",{\"1\":{\"347\":1}}],[\"此时waitthread线程处于waiting状态\",{\"1\":{\"347\":1}}],[\"此时monitor计数器就减1\",{\"1\":{\"328\":1}}],[\"此时t2线程就处于blocked的状态\",{\"1\":{\"377\":1}}],[\"此时t2\",{\"1\":{\"321\":1}}],[\"此时ab都在右边\",{\"1\":{\"214\":1}}],[\"此时若无外力干预\",{\"1\":{\"211\":1}}],[\"此方法内部其实执行了double的tostring方法\",{\"1\":{\"96\":1}}],[\"此处的m的范围\",{\"1\":{\"65\":1}}],[\"的方法用以立即终止线程\",{\"1\":{\"345\":1}}],[\"的时候\",{\"1\":{\"344\":1,\"351\":1}}],[\"的大小\",{\"1\":{\"257\":1}}],[\"的原理是拿期望的值和原本的一个值作比较\",{\"1\":{\"136\":1}}],[\"的原因与java\",{\"1\":{\"56\":1}}],[\"的高开销\",{\"1\":{\"136\":1}}],[\"的行为不再是mock的\",{\"1\":{\"103\":1}}],[\"的构造方法或使用bigdecimal\",{\"1\":{\"96\":1}}],[\"存在精度损失风险\",{\"1\":{\"96\":1}}],[\"构造函数把runnable参数设置成thread的局部变量target\",{\"1\":{\"343\":1}}],[\"构造函数有两个参数\",{\"1\":{\"110\":1}}],[\"构造函数引用可以与函数式接口结合使用\",{\"1\":{\"49\":1}}],[\"构造函数引用主要用于以下情况\",{\"1\":{\"49\":1}}],[\"构造函数引用\",{\"0\":{\"49\":1},\"1\":{\"48\":1,\"49\":1}}],[\"构造\",{\"0\":{\"96\":1}}],[\"谨慎使用bigdecimal\",{\"0\":{\"96\":1}}],[\"性能也更好\",{\"1\":{\"94\":1}}],[\"方便后续的线程需要\",{\"1\":{\"269\":1}}],[\"方便了我们对collection的操作\",{\"1\":{\"94\":1}}],[\"方括号里面的字符是或关系的\",{\"1\":{\"112\":1}}],[\"方括号内字符\",{\"0\":{\"112\":1}}],[\"方法退出时\",{\"1\":{\"374\":1}}],[\"方法进入了等待状态\",{\"1\":{\"347\":1}}],[\"方法和通知notify\",{\"1\":{\"347\":1}}],[\"方法被调用\",{\"1\":{\"346\":1,\"347\":1}}],[\"方法返回目标线程的中断状态\",{\"1\":{\"346\":2}}],[\"方法设置目标线程的中断状态为true\",{\"1\":{\"346\":1}}],[\"方法会新建一个线程\",{\"1\":{\"341\":1}}],[\"方法取得强引用时\",{\"1\":{\"309\":1}}],[\"方法后\",{\"1\":{\"194\":1,\"374\":1}}],[\"方法来减小这个计数值\",{\"1\":{\"180\":1}}],[\"方法都将阻塞\",{\"1\":{\"180\":1}}],[\"方法都未实现只是抛出异常\",{\"1\":{\"75\":1}}],[\"方法分析\",{\"0\":{\"104\":1}}],[\"方法捕获参数值\",{\"1\":{\"102\":1}}],[\"方法的返回值是1\",{\"1\":{\"101\":1}}],[\"方法\",{\"1\":{\"93\":1,\"194\":1,\"250\":1,\"341\":1,\"342\":1,\"343\":2,\"346\":1,\"347\":2,\"374\":1,\"376\":1,\"378\":1}}],[\"方法把数据复制过来\",{\"1\":{\"78\":1}}],[\"方法引用\",{\"0\":{\"48\":1},\"1\":{\"48\":1}}],[\"方法引用和构造函数引用这些具体是什么\",{\"1\":{\"45\":1}}],[\"方法引用和构造函数引用来创建\",{\"1\":{\"45\":1}}],[\"另一个是创建访问bucket的权限\",{\"1\":{\"429\":1}}],[\"另一个是用户线程main\",{\"1\":{\"352\":1}}],[\"另一个是我们自己创建的t\",{\"1\":{\"350\":1}}],[\"另一种是实现runnable接口\",{\"1\":{\"341\":1}}],[\"另一种是arraylist\",{\"1\":{\"75\":1}}],[\"另外一个就是上传到aliyun\",{\"1\":{\"428\":1}}],[\"另外value是一个volatile变量\",{\"1\":{\"136\":1}}],[\"另外java\",{\"1\":{\"93\":1}}],[\"建议使用contains\",{\"1\":{\"93\":1}}],[\"推荐使用==\",{\"1\":{\"92\":1}}],[\"上述的输出结果为\",{\"1\":{\"378\":1}}],[\"上述的例子我们只是简单的打印当前线程的中断状态\",{\"1\":{\"346\":1}}],[\"上述创建两个线程t1和t2\",{\"1\":{\"377\":1}}],[\"上述很大可能是打印\",{\"1\":{\"376\":1}}],[\"上述我们创建线程t\",{\"1\":{\"352\":1}}],[\"上述流程\",{\"1\":{\"345\":1}}],[\"上述例子返回false\",{\"1\":{\"380\":1}}],[\"上述例子中\",{\"1\":{\"345\":1}}],[\"上述例子模拟3名运动员\",{\"1\":{\"186\":1}}],[\"上述代码有两个线程\",{\"1\":{\"350\":1}}],[\"上述代码输出结果\",{\"1\":{\"335\":1}}],[\"上述代码8~12行\",{\"1\":{\"247\":1}}],[\"上述第5行代码将schedulewithfixeddelay方法改成scheduleatfixedrate\",{\"1\":{\"270\":1}}],[\"上述测试首先验证userservice的create方法被调用两次\",{\"1\":{\"102\":1}}],[\"上述将调用add方法并将传递的参数值捕获到captor对象中\",{\"1\":{\"102\":1}}],[\"上述将创建一个用于捕获user对象的argumentcaptor\",{\"1\":{\"102\":1}}],[\"上述可以工作\",{\"1\":{\"92\":1}}],[\"上面提到stop\",{\"1\":{\"346\":1}}],[\"上面提到的arrays\",{\"1\":{\"75\":1}}],[\"上面提到的接口有一个共性\",{\"1\":{\"45\":1}}],[\"上面是通过继承方式来创建线程的\",{\"1\":{\"343\":1}}],[\"上面等待的人数\",{\"1\":{\"186\":1}}],[\"上面讲述的是不可变列表\",{\"1\":{\"76\":1}}],[\"枚举类的比较\",{\"0\":{\"92\":1}}],[\"变成greeting\",{\"1\":{\"91\":1}}],[\"中断正在睡眠当中的线程t\",{\"1\":{\"346\":1}}],[\"中断方法之前\",{\"1\":{\"346\":1}}],[\"中断机制是使用称为中断状态的内部标志来实现的\",{\"1\":{\"346\":1}}],[\"中断响应lockinterruptibly\",{\"0\":{\"249\":1}}],[\"中的类只能单继承却可以多实现\",{\"1\":{\"343\":1}}],[\"中的代码\",{\"1\":{\"342\":1}}],[\"中的空引用调用静态方法时\",{\"1\":{\"91\":1}}],[\"中\",{\"1\":{\"116\":1}}],[\"中不能抛出已检查异常\",{\"1\":{\"56\":1}}],[\"利用这个特性的话\",{\"1\":{\"90\":1}}],[\"本地代码打上断点\",{\"1\":{\"88\":1}}],[\"本地和远程的源代码要保持一致\",{\"1\":{\"88\":1}}],[\"需要时间\",{\"1\":{\"257\":5}}],[\"需要完成吃饭和打完游戏才离开\",{\"1\":{\"226\":1}}],[\"需要调用该函数告知自己已经到达栅栏并开始等待\",{\"1\":{\"186\":1}}],[\"需要引入相关依赖\",{\"1\":{\"99\":1}}],[\"需要远程的服务器防火墙打开此接口\",{\"1\":{\"88\":1}}],[\"需要存储三个部分\",{\"1\":{\"65\":1}}],[\"远程debug的端口\",{\"1\":{\"88\":1}}],[\"应用端口\",{\"1\":{\"88\":1}}],[\"❌\",{\"1\":{\"86\":3}}],[\"🔘\",{\"1\":{\"86\":3}}],[\"字符串文字\",{\"0\":{\"111\":1}}],[\"字段级别\",{\"1\":{\"85\":1}}],[\"字节序的大端模式与小端模式\",{\"0\":{\"68\":1}}],[\"全局\",{\"1\":{\"85\":1}}],[\"具体使用如下\",{\"1\":{\"102\":1}}],[\"具体参考\",{\"1\":{\"78\":1}}],[\"具体如下\",{\"1\":{\"64\":1}}],[\"示例代码如下\",{\"1\":{\"78\":1}}],[\"别无二致\",{\"1\":{\"78\":1}}],[\"返回一个scheduledexecutorservice对象\",{\"1\":{\"269\":1}}],[\"返回一个可根据实际情况调整线程数量的线程池\",{\"1\":{\"269\":1}}],[\"返回一个只有一个线程的线程池\",{\"1\":{\"269\":1}}],[\"返回一个固定数量的线程池\",{\"1\":{\"269\":1}}],[\"返回当前在栅栏处等待的线程数量\",{\"1\":{\"186\":1}}],[\"返回当前计数\",{\"1\":{\"180\":1}}],[\"返回的结果是v的值\",{\"1\":{\"150\":1}}],[\"返回的结果为v原有的值e\",{\"1\":{\"150\":1}}],[\"返回的是整个参数列表\",{\"1\":{\"102\":1}}],[\"返回的是参数列表中的最后一个值\",{\"1\":{\"102\":1}}],[\"返回值\",{\"1\":{\"146\":1}}],[\"返回值是list\",{\"1\":{\"102\":1}}],[\"返回不可修改的list\",{\"1\":{\"78\":1}}],[\"返回之后的list行为和上述new\",{\"1\":{\"78\":1}}],[\"返回boolean\",{\"0\":{\"53\":1}}],[\"排序等\",{\"1\":{\"78\":1}}],[\"映射\",{\"1\":{\"78\":1}}],[\"修改person里面的属性\",{\"1\":{\"77\":1}}],[\"虽说list\",{\"1\":{\"77\":1}}],[\"皆是抛出异常\",{\"1\":{\"77\":1}}],[\"分门别类有助于gc更好的进行垃圾回收\",{\"1\":{\"305\":1}}],[\"分而治之fork\",{\"0\":{\"198\":1}}],[\"分解成截然不同的对象\",{\"1\":{\"167\":1}}],[\"分配1024\",{\"1\":{\"137\":1}}],[\"分析\",{\"0\":{\"130\":1,\"136\":1,\"143\":1,\"163\":1,\"169\":1,\"175\":1,\"187\":1,\"194\":1,\"200\":1,\"206\":1,\"235\":1,\"242\":1,\"264\":1}}],[\"分析下原因\",{\"1\":{\"77\":1}}],[\"分别是符号位\",{\"1\":{\"65\":1}}],[\"分别表示8位\",{\"1\":{\"64\":1}}],[\"也可以像上面一样定义\",{\"1\":{\"419\":1}}],[\"也可以使用isalive\",{\"1\":{\"380\":1}}],[\"也可以说是执行时间\",{\"1\":{\"269\":1}}],[\"也不会回收强引用所指向的对象\",{\"1\":{\"306\":1}}],[\"也是会提升系统性能的\",{\"1\":{\"225\":1}}],[\"也是无构造函数\",{\"1\":{\"110\":1}}],[\"也有可能多个线程抢占某个资源\",{\"1\":{\"210\":1}}],[\"也许您有兴趣查找某个特定单词\",{\"1\":{\"118\":1}}],[\"也就是同时可以申请多少许可证\",{\"1\":{\"257\":1}}],[\"也就是\",{\"1\":{\"234\":1}}],[\"也就是说当线程t1执行到i=0时\",{\"1\":{\"351\":1}}],[\"也就是说当这个list需要修改时\",{\"1\":{\"175\":1}}],[\"也就是说同时办理业务的人数最大是2\",{\"1\":{\"257\":1}}],[\"也就是说新的列表不能使用add或者set等等可以修改列表的方法\",{\"1\":{\"77\":1}}],[\"也就是所谓的零宽\",{\"1\":{\"119\":1}}],[\"也就是b\",{\"1\":{\"112\":1}}],[\"也多出了一个编码表示最低数\",{\"1\":{\"63\":1}}],[\"甚至于不能调用set方法\",{\"1\":{\"76\":1}}],[\"用于产生一个对象的具体实例\",{\"1\":{\"314\":1}}],[\"用于创建线程\",{\"1\":{\"269\":1}}],[\"用于创建不可变的list\",{\"1\":{\"76\":1}}],[\"用于在执行任务之前保存任务的队列\",{\"1\":{\"269\":1}}],[\"用于判断当前线程是否已经持有锁\",{\"1\":{\"264\":1}}],[\"用于资源访问结束后释放一个许可\",{\"1\":{\"257\":1}}],[\"用时15秒\",{\"1\":{\"226\":1}}],[\"用时55秒\",{\"1\":{\"226\":1}}],[\"用的是junit5和assertj框架\",{\"1\":{\"102\":1}}],[\"用二进制表示是111\",{\"1\":{\"65\":1}}],[\"因此线程会运行一段特定的时间\",{\"1\":{\"376\":1}}],[\"因此您不应假设join将完全等待您指定的时间\",{\"1\":{\"350\":1}}],[\"因此返回instance\",{\"1\":{\"321\":1}}],[\"因此\",{\"1\":{\"136\":1}}],[\"因此调用会有异常\",{\"1\":{\"75\":1}}],[\"因为没有调用native方法start0启动线程\",{\"1\":{\"342\":1}}],[\"因为getinstance方法加了synchronized\",{\"1\":{\"318\":1}}],[\"因为每次写入会进行一次复制\",{\"1\":{\"177\":1}}],[\"因为是链表\",{\"1\":{\"143\":1}}],[\"因为是数组\",{\"1\":{\"143\":1}}],[\"因为是引用\",{\"1\":{\"77\":1}}],[\"因为它们受到底层操作系统提供的设施的限制\",{\"1\":{\"344\":1}}],[\"因为它们都表示匹配x一次或根本不匹配\",{\"1\":{\"114\":1}}],[\"因为它总是希望自己能够成功的执行更新操作\",{\"1\":{\"150\":1}}],[\"因为它始终代表整个表达式\",{\"1\":{\"116\":1}}],[\"因为它提供类型的编译时检查并且保证了null安全\",{\"1\":{\"92\":1}}],[\"因为mocktio\",{\"1\":{\"103\":1}}],[\"因为anymatch在检索过程中\",{\"1\":{\"94\":1}}],[\"因为default\",{\"1\":{\"45\":1}}],[\"因abstractimmutablelist类中add和set等方法都没有实现且抛出异常\",{\"1\":{\"76\":1}}],[\"且两者都继承自abstractlist<e>类\",{\"1\":{\"75\":1}}],[\"且有多个抽象方法\",{\"1\":{\"45\":1}}],[\"到目前为止\",{\"1\":{\"118\":1}}],[\"到arraylist\",{\"1\":{\"74\":1}}],[\"到了函数接口创建的环节了\",{\"1\":{\"45\":1}}],[\"从结果可以得知\",{\"1\":{\"351\":1}}],[\"从输出结果上看\",{\"1\":{\"269\":1}}],[\"从上述输出来看waitthread被唤醒还等了3秒才拿到了锁\",{\"1\":{\"347\":1}}],[\"从上述的输出结果得知\",{\"1\":{\"257\":1}}],[\"从上述打印信息我们知道\",{\"1\":{\"212\":1}}],[\"从上述打印结果来看\",{\"1\":{\"186\":1}}],[\"从数字递增看锁与无锁\",{\"0\":{\"204\":1}}],[\"从这个类名字copyonwrite我们知道\",{\"1\":{\"175\":1}}],[\"从blockingqueue取东西的操作将会被阻断进入等待状态\",{\"1\":{\"142\":1}}],[\"从内存地址中读取整数\",{\"1\":{\"137\":1}}],[\"从而生成了多个实例\",{\"1\":{\"317\":1}}],[\"从而取消对锁的请求\",{\"1\":{\"249\":1}}],[\"从而避免\",{\"1\":{\"136\":1}}],[\"从而提高代码的质量以及我们的工作效率\",{\"1\":{\"83\":1}}],[\"从而减少了冗余的代码\",{\"1\":{\"47\":1}}],[\"从list\",{\"1\":{\"77\":1}}],[\"从简单的new\",{\"1\":{\"74\":1}}],[\"负无穷\",{\"1\":{\"65\":1}}],[\"负数的补码就是反码加1\",{\"1\":{\"63\":1}}],[\"二进制表示\",{\"1\":{\"65\":1}}],[\"二进制的科学记数法表现形式如下\",{\"1\":{\"65\":1}}],[\"不可重复读\",{\"0\":{\"408\":1}}],[\"不要用run\",{\"1\":{\"342\":1}}],[\"不管系统堆空间使用情况如何\",{\"1\":{\"308\":1}}],[\"不管是synchronized内置锁还是重入锁\",{\"1\":{\"149\":1}}],[\"不会被回收\",{\"1\":{\"306\":1}}],[\"不会引发异常并且代码会运行\",{\"1\":{\"91\":1}}],[\"不必关闭线程\",{\"1\":{\"269\":1}}],[\"不带fair参数的信号量是非公平的\",{\"1\":{\"257\":1}}],[\"不为人知的锁优化\",{\"0\":{\"218\":1}}],[\"不固定\",{\"1\":{\"168\":1}}],[\"不匹配\",{\"1\":{\"119\":4}}],[\"不受底层硬件的影响\",{\"1\":{\"65\":1}}],[\"不接受参数\",{\"0\":{\"54\":1}}],[\"7s\",{\"1\":{\"257\":1}}],[\"781756\",{\"1\":{\"234\":1}}],[\"7f7b4c844000\",{\"1\":{\"137\":1}}],[\"7\",{\"1\":{\"65\":2,\"112\":1,\"241\":1,\"269\":1,\"351\":2}}],[\"754\",{\"1\":{\"72\":1}}],[\"754的定义中\",{\"1\":{\"65\":1}}],[\"754标准了\",{\"1\":{\"65\":1}}],[\"加上了编译量2n−1\",{\"1\":{\"65\":1}}],[\"总会失败\",{\"1\":{\"309\":1}}],[\"总是会遇到一些莫名其妙的情况\",{\"1\":{\"210\":1}}],[\"总的原则就是把耗时的表达式滞后\",{\"1\":{\"90\":1}}],[\"总共\",{\"1\":{\"65\":1}}],[\"总结\",{\"0\":{\"20\":1,\"39\":1,\"57\":1,\"71\":1,\"80\":1,\"123\":1,\"132\":1,\"139\":1,\"145\":1,\"158\":1,\"165\":1,\"171\":1,\"177\":1,\"183\":1,\"190\":1,\"196\":1,\"202\":1,\"207\":1,\"216\":1,\"231\":1,\"237\":1,\"244\":1,\"254\":1,\"260\":1,\"266\":1,\"276\":1,\"291\":1,\"303\":1,\"311\":1,\"322\":1,\"332\":1,\"338\":1,\"356\":1,\"365\":1,\"383\":1}}],[\"符号位\",{\"1\":{\"65\":1}}],[\"符号位不变\",{\"1\":{\"62\":1}}],[\"但它们正在等待系统的资源分配\",{\"1\":{\"376\":1}}],[\"但它的功能比countdownlatch更加复杂且强大\",{\"1\":{\"185\":1}}],[\"但线程调度程序尚未选择它作为正在运行的线程\",{\"1\":{\"374\":1}}],[\"但还没有调用start\",{\"1\":{\"374\":1}}],[\"但首先\",{\"1\":{\"369\":1}}],[\"但放弃的时间不确定\",{\"1\":{\"351\":1}}],[\"但此时instance还未被初始化\",{\"1\":{\"321\":1}}],[\"但该线程池可以指定线程数量\",{\"1\":{\"269\":1}}],[\"但若有空闲线程可以复用\",{\"1\":{\"269\":1}}],[\"但具有扩展功能\",{\"1\":{\"246\":1}}],[\"但匹配结果不包含q\",{\"1\":{\"119\":1}}],[\"但匹配结果中不包含u\",{\"1\":{\"119\":1}}],[\"但前提是该单词出现在行首或行尾\",{\"1\":{\"118\":1}}],[\"但浮点数的表示规则却从来没有变过\",{\"1\":{\"65\":1}}],[\"但是它可以在指定的时间过后自行返回\",{\"1\":{\"374\":1}}],[\"但是每一次只能有一个线程使用它\",{\"1\":{\"372\":1}}],[\"但是并发是多个任务交替执行\",{\"1\":{\"371\":1}}],[\"但是并不包含匹配模式\",{\"1\":{\"119\":1}}],[\"但是一般会小于10000\",{\"1\":{\"360\":1}}],[\"但是在应用程序中\",{\"1\":{\"351\":1}}],[\"但是在多线程环境下会导致一个线程获得还没有初始化的实例\",{\"1\":{\"321\":1}}],[\"但是下一次的执行权\",{\"1\":{\"351\":1}}],[\"但是调度程序可以忽略这个提示\",{\"1\":{\"351\":1}}],[\"但是与sleep一样会依赖于操作系统的计时\",{\"1\":{\"350\":1}}],[\"但是与多数操作系统都不能很好的映射\",{\"1\":{\"348\":1}}],[\"但是这并不意味着低优先级的线程得不到执行\",{\"1\":{\"348\":1}}],[\"但是jdk中thread类提供了一个stop\",{\"1\":{\"345\":1}}],[\"但是由于jvm具有指令重排的特性\",{\"1\":{\"321\":1}}],[\"但是对于变量instance会在类的首次初始化时被创建\",{\"1\":{\"316\":1}}],[\"但是保证多线程下单例模式的安全性\",{\"1\":{\"314\":1}}],[\"但是\",{\"1\":{\"308\":1}}],[\"但是读写之间仍旧是需要同步的\",{\"1\":{\"262\":1}}],[\"但是仍旧没有一个人能够通过\",{\"1\":{\"214\":1}}],[\"但是不用过于担心基本上是大同小异\",{\"1\":{\"110\":1}}],[\"但是没有类型的编译时检查\",{\"1\":{\"92\":1}}],[\"但是如果列表类型是person对象这种的\",{\"1\":{\"77\":1}}],[\"但是有所区别的是\",{\"1\":{\"77\":1}}],[\"但是有瑕疵\",{\"1\":{\"62\":1}}],[\"但是却可以调用set方法\",{\"1\":{\"75\":1}}],[\"但是arrays\",{\"1\":{\"75\":1}}],[\"但是同名不同类\",{\"1\":{\"75\":1}}],[\"但是又存在0有两个编码的问题\",{\"1\":{\"63\":1}}],[\"但是存在减法运算的问题\",{\"1\":{\"63\":1}}],[\"但是给0带上符号是没意义的\",{\"1\":{\"62\":1}}],[\"但是很快就发现原码进行乘除运算时还好\",{\"1\":{\"61\":1}}],[\"但是具体到存储细节可能让很多程序员犯难了\",{\"1\":{\"59\":1}}],[\"知道了这三个是浮点数表示的重要组成部分\",{\"1\":{\"65\":1}}],[\"<s>\",{\"1\":{\"336\":1}}],[\"<0x000000070ffed730>\",{\"1\":{\"212\":2}}],[\"<0x000000070ffed740>\",{\"1\":{\"212\":2}}],[\"<abc\",{\"1\":{\"119\":1}}],[\"<q\",{\"1\":{\"119\":1}}],[\"<t>\",{\"1\":{\"77\":1}}],[\"<e>\",{\"1\":{\"76\":3,\"77\":2,\"175\":1}}],[\"<\",{\"1\":{\"65\":1,\"76\":1,\"119\":4,\"142\":2,\"180\":3,\"234\":1,\"241\":4,\"247\":1,\"248\":1,\"257\":1,\"269\":4,\"351\":1,\"360\":3}}],[\"<=\",{\"1\":{\"65\":1,\"143\":1,\"186\":1,\"269\":1}}],[\"尾数位\",{\"1\":{\"65\":1}}],[\"尾数\",{\"1\":{\"65\":1}}],[\"正在为第\",{\"1\":{\"257\":5}}],[\"正在把\",{\"1\":{\"194\":3}}],[\"正是我们这里需要解答的\",{\"1\":{\"173\":1}}],[\"正则最基本形式是字符串文字的匹配\",{\"1\":{\"111\":1}}],[\"正则的实现百家争鸣\",{\"1\":{\"110\":1}}],[\"正则表达式可以写成\",{\"1\":{\"117\":1}}],[\"正则表达式构造\",{\"1\":{\"112\":1,\"113\":1}}],[\"正则表达式中定义了一些元字符\",{\"1\":{\"111\":1}}],[\"正则表达式的编译表示\",{\"1\":{\"110\":1}}],[\"正则表达式是用字符串描述的一个匹配规则\",{\"1\":{\"110\":1}}],[\"正则表达式\",{\"1\":{\"109\":1}}],[\"正则基本上算是每个开发语言的标配\",{\"1\":{\"109\":1}}],[\"正如名字所言返回的是tounmodifiablelist\",{\"1\":{\"78\":1}}],[\"正常的锁不管是内部锁synchronized还是重入锁reentrantlock在任意时刻只允许一个线程访问临界资源\",{\"1\":{\"256\":1}}],[\"正常编译\",{\"1\":{\"92\":1,\"113\":1}}],[\"正常\",{\"1\":{\"78\":1}}],[\"正无穷\",{\"1\":{\"65\":1}}],[\"正负号\",{\"1\":{\"65\":1}}],[\"正好也可以看看lambda表达式\",{\"1\":{\"45\":1}}],[\"所有的线程都会尝试不断前向执行\",{\"1\":{\"373\":1}}],[\"所有的线程才会被放行\",{\"1\":{\"186\":1}}],[\"所有线程都应该以默认的优先级运行\",{\"1\":{\"348\":1}}],[\"所有线程在当前任务执行完毕后\",{\"1\":{\"269\":1}}],[\"所有申请锁但是没有成功的线程都记录在这个队列中\",{\"1\":{\"264\":1}}],[\"所谓守护\",{\"1\":{\"352\":1}}],[\"所谓copyonwrite就是在写入操作时会进行一次自我复制\",{\"1\":{\"175\":1}}],[\"所谓原码\",{\"1\":{\"61\":1}}],[\"所以在等到5秒之后main线程的正常退出\",{\"1\":{\"352\":1}}],[\"所以这个应用程序一共有两个线程\",{\"1\":{\"352\":1}}],[\"所以紧接着打印\",{\"1\":{\"351\":1}}],[\"所以上面的输出结果是\",{\"1\":{\"350\":1}}],[\"所以上述threadlocal的创建可以修改为\",{\"1\":{\"335\":1}}],[\"所以上述的captor的创建可以使用\",{\"1\":{\"102\":1}}],[\"所以有输出\",{\"1\":{\"347\":1}}],[\"所以t线程在睡眠期间\",{\"1\":{\"344\":1}}],[\"所以我们只需实现runnable接口\",{\"1\":{\"343\":1}}],[\"所以保证了这个方法只能同时被一个线程访问\",{\"1\":{\"318\":1}}],[\"所以线程执行完的顺序大概率是1234\",{\"1\":{\"269\":1}}],[\"所以没有包含在groupcount方法的返回当中\",{\"1\":{\"116\":1}}],[\"所以第一个abc的匹配index为\",{\"1\":{\"111\":1}}],[\"所以当我们编写service测试时\",{\"1\":{\"98\":1}}],[\"所以说如果想要判断key在map中是否存在\",{\"1\":{\"93\":1}}],[\"所以说list\",{\"1\":{\"77\":1}}],[\"所以原列表的修改会反映到新的列表上面来\",{\"1\":{\"77\":1}}],[\"所以由list\",{\"1\":{\"76\":1}}],[\"所以调用不会有异常\",{\"1\":{\"75\":1}}],[\"所以对于float类型的\",{\"1\":{\"65\":1}}],[\"所以对于8位的float类型\",{\"1\":{\"65\":1}}],[\"所以再看上面的公式\",{\"1\":{\"65\":1}}],[\"所以要存浮点数数\",{\"1\":{\"65\":1}}],[\"下载upic\",{\"1\":{\"433\":1}}],[\"下一步\",{\"1\":{\"65\":1}}],[\"下面给一个简单的例子\",{\"1\":{\"248\":1}}],[\"下面给出一个例子来说明上述几个方法的使用\",{\"1\":{\"346\":1}}],[\"下面给出一个使用lockinterruptibly解决死锁的例子\",{\"1\":{\"249\":1}}],[\"下面给出一个示例来加以说明list\",{\"1\":{\"77\":1}}],[\"下面给出一些例子\",{\"1\":{\"112\":1}}],[\"下面列举一个例子\",{\"1\":{\"142\":1}}],[\"下面看下各自的源码\",{\"1\":{\"77\":1}}],[\"下面介绍如何将可变列表转换成不可变的列表\",{\"1\":{\"76\":1}}],[\"下面我们就来具体看下这些引用类型\",{\"1\":{\"305\":1}}],[\"下面我们就举一个计时任务的例子\",{\"1\":{\"270\":1}}],[\"下面我们就举个银行业务办理的例子来说明semaphore的用法\",{\"1\":{\"257\":1}}],[\"下面我们就以简单的例子加以说明\",{\"1\":{\"269\":1}}],[\"下面我们就无情揭开它们的面纱\",{\"1\":{\"210\":1}}],[\"下面我们就list的可变性这个角度去分析以上list创建方法的特性以及区别\",{\"1\":{\"74\":1}}],[\"下面我们举个例子\",{\"1\":{\"194\":1}}],[\"下面我们举个例子来说明\",{\"1\":{\"186\":1}}],[\"下面我们给出一个例子\",{\"1\":{\"180\":1}}],[\"下面我们来看看连set方法都不能调用的list\",{\"1\":{\"75\":1}}],[\"下面我们来讲下比较通用的几个\",{\"1\":{\"50\":1}}],[\"下面是一个强引用的例子\",{\"1\":{\"306\":1}}],[\"下面是一个完整的例子\",{\"1\":{\"102\":1}}],[\"下面是一段最简单的重入锁使用案例\",{\"1\":{\"247\":1}}],[\"下面是一些例子\",{\"1\":{\"119\":1}}],[\"下面是java中的具体例子\",{\"1\":{\"65\":1}}],[\"下面是构造函数引用的示例\",{\"1\":{\"49\":1}}],[\"下面举几个例子\",{\"1\":{\"65\":1}}],[\"可重复读\",{\"0\":{\"414\":1}}],[\"可重入原理\",{\"0\":{\"328\":1}}],[\"可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的\",{\"1\":{\"327\":1}}],[\"可重入锁是同一个线程重复请求由自己持有的锁对象时\",{\"1\":{\"327\":1}}],[\"可重入性\",{\"0\":{\"327\":1}}],[\"可运行\",{\"0\":{\"376\":1}}],[\"可能会引起一些数据不一致的问题\",{\"1\":{\"345\":1}}],[\"可能一直没机会得到调度\",{\"1\":{\"210\":1}}],[\"可见性volatile\",{\"0\":{\"358\":1}}],[\"可见性\",{\"0\":{\"300\":1,\"359\":1}}],[\"可取代readwritelock以进一步提升并发性能\",{\"1\":{\"266\":1}}],[\"可以手写路径也可以使用剪切板的内容\",{\"1\":{\"426\":1}}],[\"可以被多个线程使用\",{\"1\":{\"372\":1}}],[\"可以使用提供cas功能的atomicinteger\",{\"1\":{\"360\":1}}],[\"可以使您的代码更易于阅读并消除格式错误的字符类引入的错误\",{\"1\":{\"113\":1}}],[\"可以编译但是运行的时候会抛出异常illegalmonitorstateexception\",{\"1\":{\"347\":1}}],[\"可以请求成功而不会发生死锁\",{\"1\":{\"327\":1}}],[\"可以参考\",{\"1\":{\"205\":1}}],[\"可以参考引用\",{\"1\":{\"101\":2}}],[\"可以当成是完成信号\",{\"1\":{\"180\":1}}],[\"可以当成是启动信号\",{\"1\":{\"180\":1}}],[\"可以在该对象上调用countdown\",{\"1\":{\"180\":1}}],[\"可以保证任何时刻任何线程总能拿到该变量的最新值\",{\"1\":{\"136\":1}}],[\"可以提取成函数\",{\"1\":{\"90\":1}}],[\"可以看到本质上和上面分析的collections\",{\"1\":{\"78\":1}}],[\"可以看到两种方式都把可变列表转换成不可变的列表\",{\"1\":{\"77\":1}}],[\"可以知道它的add和remove\",{\"1\":{\"75\":1}}],[\"可以简单看下abstractlist类的代码\",{\"1\":{\"75\":1}}],[\"可别用浮点数了\",{\"1\":{\"65\":1}}],[\"可选的参数有source\",{\"1\":{\"37\":1}}],[\"可选的参数有constructor\",{\"1\":{\"37\":1}}],[\"像上述例子中的0\",{\"1\":{\"65\":1}}],[\"转换成二进制就变成了无限循环小数\",{\"1\":{\"65\":1}}],[\"十进制不是无限循环小数的\",{\"1\":{\"65\":1}}],[\"十进制的7\",{\"1\":{\"65\":1}}],[\"往高位依次是21\",{\"1\":{\"65\":1}}],[\"只要发现弱引用\",{\"1\":{\"308\":1}}],[\"只要你的函数符合重载的要求\",{\"1\":{\"45\":1}}],[\"只有运动员在跑道上面都准备好之后\",{\"1\":{\"186\":1}}],[\"只有4个线程都到达栅栏时\",{\"1\":{\"186\":1}}],[\"只有等线程1\",{\"1\":{\"180\":1}}],[\"只有写入和写入之间需要进行同步等待\",{\"1\":{\"175\":1}}],[\"只有一个线程能够更新成功\",{\"1\":{\"150\":1}}],[\"只是它的执行频率或者机会较低\",{\"1\":{\"348\":1}}],[\"只是它的基数是2而不是10\",{\"1\":{\"65\":1}}],[\"只是写与写之间会阻塞\",{\"1\":{\"173\":1}}],[\"只是确定是否匹配\",{\"1\":{\"119\":1}}],[\"只能在synchronzied语句中调用wait\",{\"1\":{\"347\":1}}],[\"只能借助于powermockito库\",{\"1\":{\"103\":1}}],[\"只能存一个四舍五入的数值了\",{\"1\":{\"65\":1}}],[\"只存小数点后面的数字了\",{\"1\":{\"65\":1}}],[\"只不过是二进制的而已\",{\"1\":{\"65\":1}}],[\"浮点数为什么要加偏移量\",{\"0\":{\"70\":1}}],[\"浮点数正无穷与负无穷\",{\"0\":{\"69\":1}}],[\"浮点数\",{\"1\":{\"65\":2}}],[\"浮点数在计算机中的表示与此类似\",{\"1\":{\"65\":1}}],[\"浮点数在计算机中的表示是基于科学计数法的\",{\"1\":{\"65\":1}}],[\"浮点数的表示\",{\"0\":{\"65\":1}}],[\"浮点类型数据主要用于表示小数的\",{\"1\":{\"65\":1}}],[\"最近花了些时间使用vuepress搭建了自己的博客网站\",{\"1\":{\"428\":1}}],[\"最先到达的返回值parties\",{\"1\":{\"186\":1}}],[\"最好是使用bigdecimal\",{\"1\":{\"96\":1}}],[\"最终的list对象还是交由list\",{\"1\":{\"77\":1}}],[\"最后客户2和客户3办理完业务\",{\"1\":{\"257\":1}}],[\"最后合并结果得到最终结果\",{\"1\":{\"202\":1}}],[\"最后一个运动员准备好之后\",{\"1\":{\"186\":1}}],[\"最后到达的返回0\",{\"1\":{\"186\":1}}],[\"最后到java\",{\"1\":{\"74\":1}}],[\"最后把元素数组传递给一个名为listn的类\",{\"1\":{\"76\":1}}],[\"最小正浮点数\",{\"1\":{\"65\":1}}],[\"最小值\",{\"1\":{\"64\":1}}],[\"最大正浮点数\",{\"1\":{\"65\":1}}],[\"最大值\",{\"1\":{\"64\":1}}],[\"最高位则是2−1\",{\"1\":{\"65\":1}}],[\"最低位表示20\",{\"1\":{\"65\":1}}],[\"实际上\",{\"1\":{\"347\":1}}],[\"实现runnable接口\",{\"0\":{\"343\":1}}],[\"实现代码如下\",{\"1\":{\"78\":1}}],[\"实现加减法的统一\",{\"1\":{\"63\":1}}],[\"实例方法名的方式引用类的任意对象的实例方法\",{\"1\":{\"48\":1}}],[\"实例方法名的方式引用实例方法\",{\"1\":{\"48\":1}}],[\"实例方法引用\",{\"1\":{\"48\":2}}],[\"将密钥推送到远程服务器\",{\"1\":{\"427\":1}}],[\"将它让给其它的任务去占用cpu执行时间\",{\"1\":{\"351\":1}}],[\"将尝试唤醒在waitnotifythread\",{\"1\":{\"347\":1}}],[\"将runnable任务与执行该任务的thread对象分开\",{\"1\":{\"343\":1}}],[\"将instance指向分配的内存地址\",{\"1\":{\"321\":1}}],[\"将这个虚引用加入引用队列\",{\"1\":{\"309\":1}}],[\"将返回线程池进行复用\",{\"1\":{\"269\":1}}],[\"将修改的内容写入副本中\",{\"1\":{\"175\":1}}],[\"将元字符括在\",{\"1\":{\"111\":1}}],[\"将枚举常量放在左边\",{\"1\":{\"92\":1}}],[\"将二进制表示为以2为底的科学计数法\",{\"1\":{\"65\":1}}],[\"将减法视为加法\",{\"1\":{\"63\":1}}],[\"将此注解包含在javadoc中\",{\"1\":{\"37\":1}}],[\"成为了计算机中的数值表示\",{\"1\":{\"63\":1}}],[\"补码在反码基础之上\",{\"1\":{\"63\":1}}],[\"补码不负众望\",{\"1\":{\"63\":1}}],[\"补码为反码加上则是00000000\",{\"1\":{\"63\":1}}],[\"补码为原码本身\",{\"1\":{\"63\":1}}],[\"补码\",{\"1\":{\"63\":3}}],[\"人们想到了一种称为非阻塞同步的方法\",{\"1\":{\"149\":1}}],[\"人们还是接受不了0的这个问题\",{\"1\":{\"62\":1}}],[\"人们为了解决这个问题\",{\"1\":{\"61\":1}}],[\"有四种格式可以选择\",{\"1\":{\"433\":1}}],[\"有四个这样的组\",{\"1\":{\"116\":1}}],[\"有多个repo\",{\"1\":{\"419\":1}}],[\"有以下五种方法可以将线程置于timed\",{\"1\":{\"379\":1}}],[\"有可能刚刚放弃\",{\"1\":{\"351\":1}}],[\"有可能出现多个线程敌不动我不动的情形\",{\"1\":{\"210\":1}}],[\"有序性\",{\"0\":{\"299\":1}}],[\"有没有一种锁可以针对这种场景做些优化呢\",{\"1\":{\"262\":1}}],[\"有请下一位\",{\"1\":{\"257\":3}}],[\"有的线程不积极抢不过其他线程\",{\"1\":{\"210\":1}}],[\"有关读取的代码实现\",{\"1\":{\"175\":1}}],[\"有一个list的接口\",{\"1\":{\"76\":1}}],[\"有些小问题\",{\"1\":{\"62\":1}}],[\"有返回值\",{\"0\":{\"54\":1}}],[\"有返回参数\",{\"0\":{\"51\":1}}],[\"其实在thread中的state枚举中定义了如下状态\",{\"1\":{\"374\":1}}],[\"其实wait方法也有其可以指定超时时间的重载方法\",{\"1\":{\"347\":1}}],[\"其实thread类提供了runnable的构造函数来创建线程\",{\"1\":{\"343\":1}}],[\"其实就是移出没有必要加锁的操作\",{\"1\":{\"226\":1}}],[\"其实这种转换是存在些问题的\",{\"1\":{\"65\":1}}],[\"其他的人如果要用此卫生间的话\",{\"1\":{\"372\":1}}],[\"其他运动员\",{\"1\":{\"186\":1}}],[\"其他线程要想使用这个资源就必须等待\",{\"1\":{\"372\":1}}],[\"其他线程想进入临界区无需等待\",{\"1\":{\"248\":1}}],[\"其他线程想进入临界区需要等待\",{\"1\":{\"248\":1}}],[\"其他线程在结束工作时\",{\"1\":{\"180\":1}}],[\"其他线程都将更新失败\",{\"1\":{\"150\":1}}],[\"其重要性不言而谕\",{\"1\":{\"109\":1}}],[\"其余位取反\",{\"1\":{\"62\":1}}],[\"其中包含一些可以提高生产力的工具和mac上面鲜为人知的强大功能\",{\"1\":{\"424\":1}}],[\"其中包含了所有捕获的参数值的顺序\",{\"1\":{\"102\":1}}],[\"其中上述的gupa是设置alias\",{\"1\":{\"419\":1}}],[\"其中threadpoolexecutor是线程池\",{\"1\":{\"269\":1}}],[\"其中semaphore的许可个数设置为2\",{\"1\":{\"257\":1}}],[\"其中需要指定许可证\",{\"1\":{\"257\":1}}],[\"其中需要注意的是\",{\"1\":{\"111\":1}}],[\"其中的count其实就是\",{\"1\":{\"180\":1}}],[\"其中v表示要更新的地址\",{\"1\":{\"150\":1}}],[\"其中比较常用的就是arrayblockingqueue和linkedbiockingqueue\",{\"1\":{\"143\":1}}],[\"其中最为重要的莫过于\",{\"1\":{\"110\":1}}],[\"其中add\",{\"1\":{\"77\":1}}],[\"其中\",{\"1\":{\"65\":1,\"167\":1}}],[\"其中符号位1表示负数\",{\"1\":{\"61\":1}}],[\"其中就有我们熟悉的function和supplier\",{\"1\":{\"44\":1}}],[\"就得在外等候了\",{\"1\":{\"372\":1}}],[\"就好比卫生间是临界区\",{\"1\":{\"372\":1}}],[\"就会进入blocked阻塞状态\",{\"1\":{\"374\":1}}],[\"就会调用target里面的run方法\",{\"1\":{\"343\":1}}],[\"就会执行monitorexit命令\",{\"1\":{\"328\":1}}],[\"就会在回收对象后\",{\"1\":{\"309\":1}}],[\"就会被回收\",{\"1\":{\"307\":1}}],[\"就会走到本地相应的断点\",{\"1\":{\"88\":1}}],[\"就可以使用\",{\"1\":{\"427\":1}}],[\"就可以从池子中随便取一个可用的空闲线程\",{\"1\":{\"269\":1}}],[\"就可能需要mock或者verify\",{\"1\":{\"98\":1}}],[\"就不用执行\",{\"1\":{\"186\":1}}],[\"就不会被其他线程干扰\",{\"1\":{\"134\":1}}],[\"就不需要再显示的添加mocktio\",{\"1\":{\"99\":1}}],[\"就直接返回true了\",{\"1\":{\"94\":1}}],[\"就发明了\",{\"1\":{\"61\":1}}],[\"就是你吃完饭就快些离开释放位子\",{\"1\":{\"226\":1}}],[\"就是普通的根据index取数组里面的元素\",{\"1\":{\"175\":1}}],[\"就是我们今天要讲的cas\",{\"1\":{\"149\":1}}],[\"就是ab和bc的交集\",{\"1\":{\"112\":1}}],[\"就是a或b都可以匹配\",{\"1\":{\"112\":1}}],[\"就是除了a和b之外所有的字符\",{\"1\":{\"112\":1}}],[\"就是匹配的数字在1到9\",{\"1\":{\"112\":1}}],[\"就是反码\",{\"1\":{\"62\":1}}],[\"就是符号位加上数字的二进制表示\",{\"1\":{\"61\":1}}],[\"就是掌握真理\",{\"1\":{\"59\":1}}],[\"问题就出现在带符号位的负数身上\",{\"1\":{\"61\":1}}],[\"没区别\",{\"1\":{\"399\":2}}],[\"没有加锁\",{\"1\":{\"316\":1}}],[\"没有客户了\",{\"1\":{\"257\":3}}],[\"没有返回\",{\"0\":{\"52\":1}}],[\"没错\",{\"1\":{\"62\":1}}],[\"没问题\",{\"1\":{\"61\":1}}],[\"好的\",{\"1\":{\"62\":1}}],[\"好吧\",{\"1\":{\"61\":1,\"78\":1}}],[\"好了\",{\"1\":{\"45\":1,\"61\":1,\"62\":1,\"63\":1}}],[\"我想在这里先介绍几个重要的相关概念\",{\"1\":{\"369\":1}}],[\"我们再创建accesskey\",{\"1\":{\"431\":1}}],[\"我们再来看下ieee\",{\"1\":{\"65\":1}}],[\"我们除了可以使用getstate\",{\"1\":{\"380\":1}}],[\"我们需要创建用户用于对bucket的写操作\",{\"1\":{\"430\":1}}],[\"我们需要了解线程有哪些状态\",{\"1\":{\"374\":1}}],[\"我们需要手动的加锁和释放锁\",{\"1\":{\"247\":1}}],[\"我们sleep5秒之后就会退出\",{\"1\":{\"352\":1}}],[\"我们每隔一秒的打印递增数字\",{\"1\":{\"352\":1}}],[\"我们是可以在catch语句中自行决定被中断的逻辑\",{\"1\":{\"346\":1}}],[\"我们创建并启动了一个线程t1\",{\"1\":{\"379\":1}}],[\"我们创建线程t1\",{\"1\":{\"378\":1}}],[\"我们创建线程waitthread并启动\",{\"1\":{\"347\":1}}],[\"我们创建了一个线程t\",{\"1\":{\"346\":1}}],[\"我们创建一个名为mylist的类作为示例来说明mocktio的用法\",{\"1\":{\"101\":1}}],[\"我们使用sleep来模拟现实中的停顿或者费时操作\",{\"1\":{\"345\":1}}],[\"我们使用mockstatic方法创建了一个mockedstatic对象\",{\"1\":{\"103\":1}}],[\"我们在catch块中使用thread\",{\"1\":{\"346\":1}}],[\"我们在main线程调用t\",{\"1\":{\"345\":1}}],[\"我们在线程t中去修改person实例\",{\"1\":{\"345\":1}}],[\"我们在需要用到mocktio测试的class上面添加以下注解\",{\"1\":{\"100\":1}}],[\"我们会在调用iterator\",{\"1\":{\"174\":1}}],[\"我们会有对某些字符多次匹配的需求\",{\"1\":{\"114\":1}}],[\"我们引入了锁的机制\",{\"1\":{\"149\":1}}],[\"我们分析就使用arrayblockingqueue\",{\"1\":{\"143\":1}}],[\"我们从不关心比赛发生在字符串的哪个位置\",{\"1\":{\"118\":1}}],[\"我们只关心是否在特定输入字符串中的某个位置找到匹配项\",{\"1\":{\"118\":1}}],[\"我们今天主要说的是java中的正则\",{\"1\":{\"110\":1}}],[\"我们经常会遇到需要模拟静态方法的情况\",{\"1\":{\"103\":1}}],[\"我们已经演示了如何在mocktio中使用captor了\",{\"1\":{\"102\":1}}],[\"我们可以使用==或者equals方法\",{\"1\":{\"92\":1}}],[\"我们直接查看immutablecollections\",{\"1\":{\"76\":1}}],[\"我们快速算下0\",{\"1\":{\"65\":1}}],[\"我们来看看它的二进制存储是什么样的\",{\"1\":{\"65\":1}}],[\"我们来看看1\",{\"1\":{\"61\":1}}],[\"我们知道readwritelock可以实现读写分离\",{\"1\":{\"262\":1}}],[\"我们知道多线程执行中有线程优先级这个东西\",{\"1\":{\"213\":1}}],[\"我们知道它是将列表参数放到一个新的数组里面传递给不可变list里面的\",{\"1\":{\"77\":1}}],[\"我们知道\",{\"1\":{\"65\":1}}],[\"我们知道二进制表示整数的时候\",{\"1\":{\"65\":1}}],[\"我们讲了数值二进制的几种编码\",{\"1\":{\"63\":1}}],[\"我的职业生涯\",{\"0\":{\"35\":1}}],[\"0l\",{\"1\":{\"269\":2}}],[\"06\",{\"1\":{\"234\":1,\"241\":1,\"270\":1,\"329\":4}}],[\"052087\",{\"1\":{\"226\":1}}],[\"051744\",{\"1\":{\"226\":1}}],[\"04t11\",{\"1\":{\"359\":3}}],[\"04\",{\"1\":{\"270\":1}}],[\"046996\",{\"1\":{\"226\":1}}],[\"045113\",{\"1\":{\"226\":1}}],[\"044608\",{\"1\":{\"226\":1}}],[\"040466\",{\"1\":{\"226\":1}}],[\"03\",{\"1\":{\"359\":2}}],[\"037233\",{\"1\":{\"226\":1}}],[\"034642\",{\"1\":{\"226\":1}}],[\"034547\",{\"1\":{\"226\":1}}],[\"030496\",{\"1\":{\"226\":1}}],[\"01\",{\"1\":{\"359\":1}}],[\"01t10\",{\"1\":{\"329\":2}}],[\"015756\",{\"1\":{\"226\":1}}],[\"010155\",{\"1\":{\"226\":1}}],[\"0x0000000800c033f8\",{\"1\":{\"212\":1}}],[\"0x0000000800c031f0\",{\"1\":{\"212\":1}}],[\"08\",{\"1\":{\"180\":8,\"186\":7,\"194\":4,\"234\":1,\"241\":1,\"269\":8,\"270\":11,\"347\":8,\"350\":2}}],[\"08t15\",{\"1\":{\"142\":16}}],[\"079031\",{\"1\":{\"269\":1}}],[\"079035\",{\"1\":{\"269\":1}}],[\"079033\",{\"1\":{\"269\":1}}],[\"079117\",{\"1\":{\"269\":1}}],[\"07t10\",{\"1\":{\"241\":10}}],[\"07t08\",{\"1\":{\"234\":6}}],[\"07\",{\"1\":{\"162\":1,\"226\":2,\"234\":1,\"241\":1,\"350\":2}}],[\"099898\",{\"1\":{\"347\":1}}],[\"096438\",{\"1\":{\"347\":1}}],[\"09t09\",{\"1\":{\"226\":24}}],[\"09\",{\"1\":{\"142\":32,\"226\":24,\"234\":6,\"241\":11,\"329\":2,\"359\":3}}],[\"020934\",{\"1\":{\"186\":1}}],[\"020000000000000004\",{\"1\":{\"96\":1}}],[\"02\",{\"1\":{\"96\":1}}],[\"0撘配filter会检索整个stream\",{\"1\":{\"94\":1}}],[\"000\",{\"1\":{\"247\":1}}],[\"00000000000000000000001\",{\"1\":{\"65\":1}}],[\"00000000000000000000000\",{\"1\":{\"65\":3}}],[\"00000000\",{\"1\":{\"63\":4,\"65\":2}}],[\"00000001\",{\"1\":{\"61\":3,\"62\":3,\"63\":1}}],[\"00000010\",{\"1\":{\"61\":1,\"62\":2}}],[\"00\",{\"1\":{\"180\":2,\"270\":1}}],[\"001\",{\"1\":{\"65\":1}}],[\"0则不存在了\",{\"1\":{\"63\":1}}],[\"0虽说数值是一样的\",{\"1\":{\"62\":1}}],[\"0\",{\"1\":{\"62\":2,\"63\":1,\"65\":14,\"76\":4,\"88\":2,\"94\":3,\"96\":10,\"102\":1,\"103\":1,\"110\":1,\"111\":6,\"112\":4,\"113\":2,\"116\":1,\"117\":1,\"142\":10,\"143\":5,\"174\":3,\"180\":4,\"186\":1,\"211\":2,\"212\":3,\"213\":1,\"226\":4,\"234\":3,\"241\":11,\"247\":2,\"248\":1,\"269\":6,\"329\":1,\"335\":2,\"343\":1,\"351\":4,\"352\":2,\"360\":4,\"377\":1}}],[\"0表示正数\",{\"1\":{\"61\":1}}],[\"0为正\",{\"1\":{\"60\":1}}],[\"概念介绍\",{\"0\":{\"60\":1}}],[\"展开介绍下整数及浮点数在java虚拟机的表示\",{\"1\":{\"59\":1}}],[\"这篇文章就讲如何高效的使用macos\",{\"1\":{\"424\":1}}],[\"这时线程就会暂停执行\",{\"1\":{\"374\":1}}],[\"这时转账的线程被终止\",{\"1\":{\"345\":1}}],[\"这两个方法并不是在thread类中的\",{\"1\":{\"347\":1}}],[\"这导致12行的setaddress没能执行\",{\"1\":{\"345\":1}}],[\"这是因为notifythread线程sleep了3秒\",{\"1\":{\"347\":1}}],[\"这是因为在java中\",{\"1\":{\"346\":1}}],[\"这是一种使处理器时间可用于应用程序的其他线程或可能在计算机系统上运行的其他应用程序的有效方法\",{\"1\":{\"344\":1}}],[\"这是从java\",{\"1\":{\"336\":1}}],[\"这段代码其实是分为三步执行\",{\"1\":{\"321\":1}}],[\"这比循环去获取或者释放的方式更加的高效\",{\"1\":{\"257\":1}}],[\"这主要得益于方法lockinterruptibly\",{\"1\":{\"249\":1}}],[\"这提供了更好的灵活性\",{\"1\":{\"247\":1}}],[\"这种情况就是阻塞\",{\"1\":{\"373\":1}}],[\"这种是线程不安全的\",{\"1\":{\"320\":1}}],[\"这种是线程安全的\",{\"1\":{\"318\":1,\"319\":1,\"321\":1}}],[\"这种会有问题的\",{\"1\":{\"317\":1}}],[\"这种单例模式是线程安全的\",{\"1\":{\"316\":1}}],[\"这种乐观的锁非常类似无锁的操作\",{\"1\":{\"263\":1}}],[\"这种灵活性就大大减少了与锁相关的活跃性问题了\",{\"1\":{\"150\":1}}],[\"这种方式不需要锁\",{\"1\":{\"149\":1}}],[\"这种机制也直接说明了\",{\"1\":{\"65\":1}}],[\"这根本就难不倒正则\",{\"1\":{\"114\":1}}],[\"这边给出一个简单的示例\",{\"1\":{\"103\":1}}],[\"这里加不加\",{\"1\":{\"399\":2}}],[\"这里用while模拟t1拥有锁的时间\",{\"1\":{\"377\":1}}],[\"这里会有抛出illegalmonitorstateexception的异常\",{\"1\":{\"248\":1}}],[\"这里我们选择markdown\",{\"1\":{\"433\":1}}],[\"这里我们赋予aliyunossfullaccess\",{\"1\":{\"431\":1}}],[\"这里我们采用的就是第二种\",{\"1\":{\"428\":1}}],[\"这里我们来简单的介绍下线程的使用\",{\"1\":{\"340\":1}}],[\"这里我们创建线程t1和线程t2\",{\"1\":{\"351\":1}}],[\"这里我们创建五个线程来模拟五个用户去银行办理业务\",{\"1\":{\"257\":1}}],[\"这里我们创建两个countdownlatch\",{\"1\":{\"180\":1}}],[\"这里我们就展开讲讲锁的优化思路\",{\"1\":{\"225\":1}}],[\"这里我们就深耕细节\",{\"1\":{\"59\":1}}],[\"这里列举一个关于装水取水的例子\",{\"1\":{\"168\":1}}],[\"这里以\",{\"1\":{\"135\":1}}],[\"这里写一个正则表达式的程序用于测试\",{\"1\":{\"110\":1}}],[\"这里面列出项目中常用插件\",{\"1\":{\"420\":1}}],[\"这里面介绍在springboot项目中如何忽略null字段\",{\"1\":{\"85\":1}}],[\"这里面整理收集一些在java开发过程中我们需要注意的一些点或者说是技巧\",{\"1\":{\"83\":1}}],[\"这个状态其实包含就绪\",{\"1\":{\"374\":1}}],[\"这个方法被废弃\",{\"1\":{\"345\":1}}],[\"这个方法是用来拿到变量的内存地址\",{\"1\":{\"136\":1}}],[\"这个方法是stream接口的默认方法\",{\"1\":{\"78\":1}}],[\"这个逻辑存在于native方法start0中\",{\"1\":{\"341\":1}}],[\"这个在后面会讲到\",{\"1\":{\"110\":1}}],[\"这个时候我们就可以使用captor的getallvalues方法\",{\"1\":{\"102\":1}}],[\"这个时候mocktio库就派上用场了\",{\"1\":{\"98\":1}}],[\"这个类继承自abstractimmutablelist\",{\"1\":{\"76\":1}}],[\"这也是上述原列表的修改没有反映到新的列表上的原因\",{\"1\":{\"77\":1}}],[\"这一点很重要\",{\"1\":{\"347\":1}}],[\"这一标准最早在1985年提出\",{\"1\":{\"65\":1}}],[\"这一次加减法是没啥子问题\",{\"1\":{\"62\":1}}],[\"这就导致了person这个实例只是更新了username\",{\"1\":{\"345\":1}}],[\"这就导致了浮点数精度不准确的问题\",{\"1\":{\"65\":1}}],[\"这就是活锁\",{\"1\":{\"214\":2}}],[\"这就是饥饿\",{\"1\":{\"213\":1}}],[\"这就是新列表不可变的秘密所在\",{\"1\":{\"77\":1}}],[\"这就尴尬了\",{\"1\":{\"61\":1}}],[\"这样其他线程就可以拿到锁来唤醒此线程了🤪\",{\"1\":{\"347\":1}}],[\"这样这个资源在多个线程之间跳动而又得不到执行\",{\"1\":{\"214\":1}}],[\"这样如果优先级高的线程一直抢占优先级低线程的资源\",{\"1\":{\"213\":1}}],[\"这样一直争执下去等待对方还而又得不到解决\",{\"1\":{\"211\":1}}],[\"这样就能够很快便利的选择相应的文件或者目录\",{\"1\":{\"426\":1}}],[\"这样就可以在项目目录下使用gh打开所在的github\",{\"1\":{\"419\":1}}],[\"这样就可以保证写操作不会影响读了\",{\"1\":{\"175\":1}}],[\"这样就可以避免空指针异常\",{\"1\":{\"92\":1}}],[\"这样就进一步的提高读取的性能了\",{\"1\":{\"173\":1}}],[\"这样在测试中我们就可以使用mocktio的注解了\",{\"1\":{\"100\":1}}],[\"这样8位的数值范围就是\",{\"1\":{\"63\":1}}],[\"这样补码中0的表示就只有一种\",{\"1\":{\"63\":1}}],[\"这诞生了原码\",{\"1\":{\"60\":1}}],[\"这些重载方法允许程序员指定等待时间\",{\"1\":{\"350\":1}}],[\"这些方法的调用之前必须获得目标对象的一个锁\",{\"1\":{\"347\":1}}],[\"这些线程则一直处理阻塞的假死状态\",{\"1\":{\"211\":1}}],[\"这些问题统称为并发的liveness问题\",{\"1\":{\"210\":1}}],[\"这些字符有着特殊的含义\",{\"1\":{\"111\":1}}],[\"这些注解可以帮助我们在测试中创建模拟对象\",{\"1\":{\"99\":1}}],[\"这些接口中的每一个都是通用且抽象的\",{\"1\":{\"44\":1}}],[\"这些基本上满足了开发日常的需要\",{\"1\":{\"44\":1}}],[\"数值\",{\"1\":{\"65\":1}}],[\"数值都是1点几了\",{\"1\":{\"65\":1}}],[\"数值有大小之分\",{\"1\":{\"64\":1}}],[\"数值有了在计算机中的表示方法\",{\"1\":{\"61\":1}}],[\"数值的表示总算尘埃落定\",{\"1\":{\"63\":1}}],[\"数值也不例外\",{\"1\":{\"60\":1}}],[\"数有正负之分\",{\"1\":{\"60\":1}}],[\"数乃万物之理\",{\"1\":{\"59\":1}}],[\"数字是咋个存储的\",{\"0\":{\"59\":1}}],[\"xyz123\",{\"1\":{\"119\":2}}],[\"x++\",{\"1\":{\"114\":1}}],[\"x+\",{\"1\":{\"114\":2}}],[\"x0b\",{\"1\":{\"113\":1}}],[\"x\",{\"1\":{\"53\":2,\"114\":23}}],[\"++i\",{\"1\":{\"180\":1}}],[\"++takeindex\",{\"1\":{\"143\":1}}],[\"++putindex\",{\"1\":{\"143\":1}}],[\"+做完全相同的事情\",{\"1\":{\"114\":1}}],[\"+0\",{\"1\":{\"62\":1}}],[\"+0和\",{\"1\":{\"62\":1}}],[\"+\",{\"1\":{\"51\":3,\"61\":4,\"62\":4,\"63\":2,\"65\":1,\"110\":2,\"111\":1,\"114\":5,\"130\":1,\"136\":1,\"137\":2,\"142\":13,\"175\":1,\"180\":6,\"186\":14,\"194\":8,\"211\":6,\"213\":2,\"257\":9,\"269\":3,\"270\":6,\"329\":2,\"335\":8,\"343\":1,\"346\":2,\"347\":6,\"350\":2,\"351\":2,\"352\":1,\"359\":2,\"426\":6}}],[\"既然java\",{\"1\":{\"49\":1}}],[\"以确保它确实具有预期的效果\",{\"1\":{\"351\":1}}],[\"以上程序的输出结果\",{\"1\":{\"347\":1}}],[\"以上就是关于函数接口实例的创建了\",{\"1\":{\"49\":1}}],[\"以下我们使用一个示例来说明\",{\"1\":{\"351\":1}}],[\"以下我们用一个事例来说明以上两个方法\",{\"1\":{\"347\":1}}],[\"以下给出一个例子来加以说明\",{\"1\":{\"345\":1}}],[\"以下是thread类内置的优先级常量\",{\"1\":{\"348\":1}}],[\"以下是一个例子\",{\"1\":{\"343\":1}}],[\"以下是groupcount的源码\",{\"1\":{\"116\":1}}],[\"以通知应用程序对象的回收情况\",{\"1\":{\"309\":1}}],[\"以避免线程导致自身阻塞\",{\"1\":{\"248\":1}}],[\"以便其他线程无法进入此synchronized方法\",{\"1\":{\"377\":1}}],[\"以便通过将这些对象与任意lock实现组合使用\",{\"1\":{\"167\":1}}],[\"以便以后通过反向引用调用\",{\"1\":{\"117\":1}}],[\"以反斜杠\",{\"1\":{\"113\":1}}],[\"以gradle构建工具为例\",{\"1\":{\"99\":1}}],[\"以及四种元注解\",{\"1\":{\"37\":1}}],[\"而当t2启动时尝试进入synchronized的代码块\",{\"1\":{\"377\":1}}],[\"而当fair为true时\",{\"1\":{\"257\":1}}],[\"而main线程和线程t1可能是并行执行\",{\"1\":{\"376\":1}}],[\"而并行同一时刻可以有多个任务在同时执行\",{\"1\":{\"371\":1}}],[\"而异步方法通常会在另外一个线程中真实地执行\",{\"1\":{\"370\":1}}],[\"而java也主要占领着服务端市场\",{\"1\":{\"369\":1}}],[\"而锁被释放\",{\"1\":{\"347\":1}}],[\"而之后线程t的中断状态为true\",{\"1\":{\"346\":1}}],[\"而address没能得到更新\",{\"1\":{\"345\":1}}],[\"而threadlocalmap可以理解为一个map\",{\"1\":{\"336\":1}}],[\"而重入锁提供另外一种可能\",{\"1\":{\"249\":1}}],[\"而活锁是拿到资源却又相互释放不执行\",{\"1\":{\"214\":1}}],[\"而又相互等对方释放锁\",{\"1\":{\"211\":1}}],[\"而起跑的顺序是\",{\"1\":{\"186\":1}}],[\"而是要尝试重新获得waitnotifythread\",{\"1\":{\"347\":1}}],[\"而是归属于object类\",{\"1\":{\"347\":1}}],[\"而是给线程发送一个通知\",{\"1\":{\"346\":1}}],[\"而是把线程归还到线程池中\",{\"1\":{\"269\":1}}],[\"而是对原有的数据进行\",{\"1\":{\"175\":1}}],[\"而是被告知失败的结果\",{\"1\":{\"150\":1}}],[\"而关于copyonwritearraylist是怎么做到如此的\",{\"1\":{\"173\":1}}],[\"而\",{\"1\":{\"112\":1}}],[\"而^表示否定关系的\",{\"1\":{\"112\":1}}],[\"而强制将元字符视为普通字符的方法有以下两种\",{\"1\":{\"111\":1}}],[\"而如果我就是想把元字符当成普通字符来匹配又该如何是好呢\",{\"1\":{\"111\":1}}],[\"而double的tostring按double的实际能表达的精度对尾数进行了截断\",{\"1\":{\"96\":1}}],[\"而count\",{\"1\":{\"94\":1}}],[\"而不是使用double或者float\",{\"1\":{\"96\":1}}],[\"而不是count\",{\"1\":{\"94\":1}}],[\"而不是实例\",{\"1\":{\"91\":1}}],[\"而不是原列表的引用\",{\"1\":{\"77\":1}}],[\"而在main线程中睡眠了1秒钟\",{\"1\":{\"378\":1}}],[\"而在main线程中\",{\"1\":{\"352\":1}}],[\"而在jdk\",{\"1\":{\"246\":1}}],[\"而在java的世界中能让人色变的可能就是这exception了\",{\"1\":{\"41\":1}}],[\"而在take方法中\",{\"1\":{\"143\":1}}],[\"而在分析list\",{\"1\":{\"77\":1}}],[\"而在unmodifiablelist中维护了一个参数传递过来的list引用\",{\"1\":{\"77\":1}}],[\"而对于unmodifiablelist则不然\",{\"1\":{\"77\":1}}],[\"而计算机底层无法精确存储那个无限循环二进制数的\",{\"1\":{\"65\":1}}],[\"而且线程的优先级调度和底层操作系统有密切的关系\",{\"1\":{\"348\":1}}],[\"而且由于notifythread还没有创建未占据锁\",{\"1\":{\"347\":1}}],[\"而且只能是2个线程\",{\"1\":{\"192\":1}}],[\"而且这些更新失败的线程并不会等待被挂起\",{\"1\":{\"150\":1}}],[\"而且想要verify方法参数内容的时候\",{\"1\":{\"102\":1}}],[\"而且补码中的10000000还可以表示最低数\",{\"1\":{\"63\":1}}],[\"而且0的编码表示还存在两种\",{\"1\":{\"62\":1}}],[\"而无需显式地编写构造函数的调用\",{\"1\":{\"49\":1}}],[\"类的objectfieldoffset方法是一个本地方法\",{\"1\":{\"136\":1}}],[\"类的部分源码\",{\"1\":{\"136\":1}}],[\"类的实例方法引用\",{\"1\":{\"48\":1}}],[\"类常用方法\",{\"1\":{\"135\":1}}],[\"类级别\",{\"1\":{\"85\":1}}],[\"类型\",{\"1\":{\"65\":1}}],[\"类似于waiting\",{\"1\":{\"374\":1}}],[\"类似于数据库的连接池\",{\"1\":{\"269\":1}}],[\"类似于电商中的拼团\",{\"1\":{\"186\":1}}],[\"类似于\",{\"1\":{\"45\":1}}],[\"静态方法查询当前线程也就是线程t的中断状态\",{\"1\":{\"346\":1}}],[\"静态方法属于类而不是实例\",{\"1\":{\"91\":1}}],[\"静态方法的调用\",{\"0\":{\"91\":1}}],[\"静态方法名的方式引用静态方法\",{\"1\":{\"48\":1}}],[\"静态方法引用\",{\"1\":{\"48\":1}}],[\"是想让程序可以正常退出\",{\"1\":{\"378\":1}}],[\"是指在程序运行的时候在后台提供一种通用服务的线程\",{\"1\":{\"352\":1}}],[\"是指一个操作是不可中断的\",{\"1\":{\"134\":1}}],[\"是终止线程还是另做其他都是可以的\",{\"1\":{\"346\":1}}],[\"是没有释放锁的\",{\"1\":{\"344\":1}}],[\"是件有趣且好玩的事情\",{\"1\":{\"314\":1}}],[\"是因为引用也有轻重缓急\",{\"1\":{\"305\":1}}],[\"是因为同一个线程是可以连续获得同一把锁\",{\"1\":{\"248\":1}}],[\"是index递增\",{\"1\":{\"269\":1}}],[\"是按照fifo队列的规则来选的线程\",{\"1\":{\"257\":1}}],[\"是已经支持原子化的cas指令的\",{\"1\":{\"150\":1}}],[\"是一种比较并交换的算法\",{\"1\":{\"150\":1}}],[\"是一种简化构造函数调用的方法\",{\"1\":{\"49\":1}}],[\"是group\",{\"1\":{\"116\":1}}],[\"是unchecked的异常\",{\"1\":{\"110\":1}}],[\"是解释模式并对输入字符串执行匹配操作的引擎\",{\"1\":{\"110\":1}}],[\"是不可修改的\",{\"1\":{\"78\":1}}],[\"是lambda表达式的一种简写形式\",{\"1\":{\"48\":1}}],[\"是java\",{\"1\":{\"47\":1}}],[\"663\",{\"1\":{\"205\":1}}],[\"66260\",{\"1\":{\"205\":1}}],[\"6152\",{\"1\":{\"205\":1}}],[\"6f\",{\"1\":{\"65\":1}}],[\"6的数值\",{\"1\":{\"65\":1}}],[\"64460\",{\"1\":{\"212\":1}}],[\"64017\",{\"1\":{\"212\":1}}],[\"64016\",{\"1\":{\"212\":2}}],[\"64\",{\"1\":{\"64\":1,\"65\":1}}],[\"64位有符号整数\",{\"1\":{\"64\":1}}],[\"60l\",{\"1\":{\"269\":1}}],[\"60000001f\",{\"1\":{\"65\":1}}],[\"60000003f\",{\"1\":{\"65\":1}}],[\"60\",{\"1\":{\"51\":1}}],[\"6\",{\"1\":{\"47\":1,\"65\":1,\"101\":1,\"111\":2,\"112\":4,\"241\":1,\"269\":1,\"270\":1,\"351\":2,\"399\":1}}],[\"917732\",{\"1\":{\"234\":1}}],[\"944046\",{\"1\":{\"234\":1}}],[\"929474\",{\"1\":{\"234\":1}}],[\"952462\",{\"1\":{\"194\":1}}],[\"952205\",{\"1\":{\"194\":1}}],[\"9094\",{\"1\":{\"88\":3}}],[\"9中引入的list\",{\"1\":{\"74\":1}}],[\"9\",{\"1\":{\"47\":1,\"111\":1,\"112\":3,\"113\":3,\"234\":1,\"241\":1,\"351\":2}}],[\"50\",{\"1\":{\"359\":1}}],[\"5005\",{\"1\":{\"88\":6}}],[\"53\",{\"1\":{\"359\":1}}],[\"538647\",{\"1\":{\"270\":1}}],[\"535428\",{\"1\":{\"270\":1}}],[\"534709\",{\"1\":{\"270\":1}}],[\"530656\",{\"1\":{\"270\":1}}],[\"531318\",{\"1\":{\"241\":1}}],[\"531316\",{\"1\":{\"241\":1}}],[\"531389\",{\"1\":{\"241\":1}}],[\"540083\",{\"1\":{\"270\":1}}],[\"549605\",{\"1\":{\"241\":1}}],[\"5引入了线程池实现了线程的复用\",{\"1\":{\"268\":1}}],[\"5引入了重入锁与使用synchronized具有相同的基本行为\",{\"1\":{\"246\":1}}],[\"5s\",{\"1\":{\"257\":1}}],[\"5800758\",{\"1\":{\"313\":1}}],[\"58\",{\"1\":{\"226\":1}}],[\"573060\",{\"1\":{\"359\":1}}],[\"575345\",{\"1\":{\"226\":1}}],[\"575102\",{\"1\":{\"226\":1}}],[\"574313\",{\"1\":{\"226\":1}}],[\"574430\",{\"1\":{\"226\":1}}],[\"57\",{\"1\":{\"226\":2}}],[\"561578\",{\"1\":{\"329\":1}}],[\"560455\",{\"1\":{\"329\":1}}],[\"567889\",{\"1\":{\"226\":1}}],[\"569301\",{\"1\":{\"226\":1}}],[\"569007\",{\"1\":{\"226\":1}}],[\"569063\",{\"1\":{\"226\":1}}],[\"569583\",{\"1\":{\"226\":1}}],[\"569294\",{\"1\":{\"226\":1}}],[\"56\",{\"1\":{\"226\":2,\"270\":1,\"359\":1}}],[\"517288\",{\"1\":{\"350\":1}}],[\"515364\",{\"1\":{\"350\":1}}],[\"51\",{\"1\":{\"270\":1}}],[\"511\",{\"1\":{\"205\":1}}],[\"514\",{\"1\":{\"205\":1}}],[\"559628\",{\"1\":{\"359\":1}}],[\"552026\",{\"1\":{\"270\":1}}],[\"553636\",{\"1\":{\"241\":1}}],[\"558119\",{\"1\":{\"226\":1}}],[\"551386\",{\"1\":{\"226\":1}}],[\"5561\",{\"1\":{\"205\":1}}],[\"55\",{\"1\":{\"186\":7,\"226\":1}}],[\"598635\",{\"1\":{\"186\":1}}],[\"59\",{\"1\":{\"180\":6,\"226\":2}}],[\"5+里面闭锁的一个实现\",{\"1\":{\"179\":1}}],[\"5之后\",{\"1\":{\"150\":1}}],[\"5f\",{\"1\":{\"65\":1}}],[\"52281\",{\"1\":{\"205\":1}}],[\"52\",{\"1\":{\"65\":1,\"270\":1}}],[\"5\",{\"1\":{\"47\":2,\"65\":1,\"112\":3,\"127\":3,\"180\":2,\"257\":1,\"269\":1,\"348\":1,\"351\":2,\"352\":1,\"379\":1,\"380\":1,\"399\":1}}],[\"43\",{\"1\":{\"241\":5}}],[\"49\",{\"1\":{\"226\":1}}],[\"497\",{\"1\":{\"205\":1}}],[\"481307\",{\"1\":{\"347\":1}}],[\"48\",{\"1\":{\"226\":1}}],[\"488\",{\"1\":{\"205\":1}}],[\"448698\",{\"1\":{\"241\":1}}],[\"442590\",{\"1\":{\"241\":1}}],[\"44\",{\"1\":{\"226\":1}}],[\"461708\",{\"1\":{\"347\":1}}],[\"468331\",{\"1\":{\"347\":1}}],[\"46\",{\"1\":{\"226\":2}}],[\"456399\",{\"1\":{\"347\":1}}],[\"457287\",{\"1\":{\"241\":1}}],[\"453418\",{\"1\":{\"241\":1}}],[\"45\",{\"1\":{\"226\":2,\"347\":1}}],[\"414989\",{\"1\":{\"186\":1}}],[\"414909\",{\"1\":{\"186\":1}}],[\"414811\",{\"1\":{\"186\":1}}],[\"41\",{\"1\":{\"180\":2}}],[\"403454\",{\"1\":{\"194\":1}}],[\"403456\",{\"1\":{\"194\":1}}],[\"403166\",{\"1\":{\"186\":1}}],[\"402894\",{\"1\":{\"186\":1}}],[\"40\",{\"1\":{\"180\":6,\"347\":2}}],[\"426840\",{\"1\":{\"241\":1}}],[\"42\",{\"1\":{\"137\":2,\"241\":5,\"347\":1}}],[\"47\",{\"1\":{\"88\":1,\"226\":1,\"427\":4}}],[\"4称为指数\",{\"1\":{\"65\":1}}],[\"4\",{\"1\":{\"47\":1,\"103\":1,\"112\":6,\"117\":1,\"142\":1,\"180\":1,\"226\":4,\"234\":3,\"257\":2,\"269\":4,\"270\":1,\"351\":2,\"352\":1,\"399\":1}}],[\"=123\",{\"1\":{\"119\":1}}],[\"=u\",{\"1\":{\"119\":1}}],[\"=$\",{\"1\":{\"111\":1}}],[\"===================================================\",{\"1\":{\"212\":1}}],[\"==\",{\"1\":{\"65\":1,\"77\":2,\"92\":2,\"110\":1,\"143\":6,\"234\":1,\"269\":3,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":2,\"351\":1}}],[\"=>\",{\"1\":{\"61\":3}}],[\"=\",{\"1\":{\"47\":1,\"48\":1,\"51\":3,\"54\":1,\"61\":3,\"62\":7,\"63\":4,\"76\":4,\"77\":3,\"78\":4,\"91\":1,\"92\":4,\"94\":2,\"95\":1,\"96\":3,\"100\":2,\"101\":8,\"102\":1,\"103\":2,\"110\":9,\"113\":2,\"116\":1,\"119\":1,\"136\":2,\"137\":8,\"142\":4,\"143\":16,\"171\":2,\"174\":2,\"175\":5,\"180\":4,\"186\":6,\"194\":3,\"211\":4,\"213\":3,\"234\":16,\"241\":8,\"247\":6,\"248\":4,\"257\":8,\"269\":27,\"270\":1,\"306\":1,\"316\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":2,\"335\":2,\"336\":15,\"342\":1,\"343\":2,\"344\":1,\"345\":6,\"346\":2,\"347\":2,\"348\":3,\"350\":1,\"351\":3,\"352\":8,\"359\":2,\"360\":7,\"375\":1,\"376\":1,\"377\":2,\"378\":1,\"379\":1,\"380\":1,\"399\":2}}],[\"对头\",{\"1\":{\"192\":1}}],[\"对复制后的列表b进行相应的写入的操作\",{\"1\":{\"175\":1}}],[\"对锁的激烈竞争导致的线程等待很大程度上会影响性能\",{\"1\":{\"149\":1}}],[\"对精度有要求的计算时\",{\"1\":{\"96\":1}}],[\"对比于count\",{\"1\":{\"94\":1}}],[\"对比于整数的表示\",{\"1\":{\"65\":1}}],[\"对比上述结果\",{\"1\":{\"77\":1}}],[\"对于synchronized来说\",{\"1\":{\"249\":1}}],[\"对于判断当前线程是否持有锁\",{\"1\":{\"248\":1}}],[\"对于写而言则较之复杂些\",{\"1\":{\"175\":1}}],[\"对于copyonwritearraylist来说\",{\"1\":{\"175\":1}}],[\"对于失败后的处理\",{\"1\":{\"150\":1}}],[\"对于枚举判断相等\",{\"1\":{\"92\":2}}],[\"对于指数部分\",{\"1\":{\"65\":1}}],[\"对于金额这种对精度有要求的计算\",{\"1\":{\"65\":1}}],[\"对于二进制小数点的部分\",{\"1\":{\"65\":1}}],[\"对于负数则在原码的基础上\",{\"1\":{\"62\":1}}],[\"对\",{\"1\":{\"62\":1}}],[\"对一个整数列表进行排序可以使用lambda表达式如下\",{\"1\":{\"47\":1}}],[\"对么参考\",{\"1\":{\"13\":1}}],[\"例如java\",{\"1\":{\"351\":1}}],[\"例如表达式\",{\"1\":{\"117\":1}}],[\"例如service可能依赖repository等等\",{\"1\":{\"98\":1}}],[\"例如supplier\",{\"1\":{\"49\":1}}],[\"例如\",{\"1\":{\"47\":1,\"48\":1,\"100\":1,\"116\":1,\"118\":1,\"321\":1}}],[\"8才开始有的\",{\"1\":{\"336\":1}}],[\"8提供了withinitial的静态方法来创建和初始化threadlocal\",{\"1\":{\"335\":1}}],[\"8提供了四种类型的方法引用\",{\"1\":{\"48\":1}}],[\"805705\",{\"1\":{\"234\":1}}],[\"800623\",{\"1\":{\"234\":1}}],[\"833\",{\"1\":{\"212\":2,\"329\":1}}],[\"88127\",{\"1\":{\"212\":1}}],[\"8中引入的stream\",{\"1\":{\"94\":1}}],[\"8中提供了getordefault\",{\"1\":{\"93\":1}}],[\"8引入的collectors\",{\"1\":{\"78\":1}}],[\"8引入lambda表达式时的设计哲学有关\",{\"1\":{\"56\":1}}],[\"8开启了java函数式编程的新世界\",{\"1\":{\"78\":1}}],[\"8\",{\"1\":{\"64\":1,\"65\":1,\"112\":3,\"241\":1,\"269\":1,\"351\":2}}],[\"8自带了些开箱即用的函数式接口\",{\"1\":{\"49\":1}}],[\"8最显著的函数式编程特性之一\",{\"1\":{\"47\":1}}],[\"8终于引入了对函数式编程的支持\",{\"1\":{\"43\":1}}],[\"函数接口的创建\",{\"0\":{\"46\":1}}],[\"函数接口的实例可以通过lambda表达式\",{\"1\":{\"45\":1}}],[\"函数接口只有一个抽象方法\",{\"1\":{\"45\":1}}],[\"函数式接口是允许有default\",{\"1\":{\"45\":1}}],[\"函数式编程是一种编程范式\",{\"1\":{\"43\":1}}],[\"函数式编程\",{\"0\":{\"43\":1,\"44\":1}}],[\"一致性\",{\"0\":{\"403\":1}}],[\"一直都没能结束\",{\"1\":{\"359\":1}}],[\"一种是继承thread类\",{\"1\":{\"341\":1}}],[\"一种是new\",{\"1\":{\"75\":1}}],[\"一旦临界区资源被占用\",{\"1\":{\"372\":1}}],[\"一旦开始方法调用就会立即返回\",{\"1\":{\"370\":1}}],[\"一旦一个弱引用对象被垃圾回收器回收\",{\"1\":{\"308\":1}}],[\"一旦返回0\",{\"1\":{\"186\":1}}],[\"一探究竟线程池\",{\"0\":{\"268\":1}}],[\"一开始客户1和客户2得到了办理的机会\",{\"1\":{\"257\":1}}],[\"一手交货\",{\"1\":{\"194\":1}}],[\"一手交钱\",{\"1\":{\"194\":1}}],[\"一般来说\",{\"1\":{\"345\":1,\"351\":1}}],[\"一般用于调度或者测试\",{\"1\":{\"180\":1}}],[\"一般在测试项目中\",{\"1\":{\"100\":1}}],[\"一次复制\",{\"1\":{\"175\":1}}],[\"一文看懂timezone\",{\"0\":{\"126\":1}}],[\"一文了解spring的事务\",{\"1\":{\"400\":1}}],[\"一文了解ddd\",{\"1\":{\"9\":1}}],[\"一文了解cqrs\",{\"1\":{\"8\":1}}],[\"一个人先进去使用并关门上锁\",{\"1\":{\"372\":1}}],[\"一个是创建bucket\",{\"1\":{\"429\":1}}],[\"一个是以本地文件的形式上传到nginx\",{\"1\":{\"428\":1}}],[\"一个是守护线程t\",{\"1\":{\"352\":1}}],[\"一个是main\",{\"1\":{\"350\":1}}],[\"一个持有虚引用的对象\",{\"1\":{\"309\":1}}],[\"一个节点代表一个线程\",{\"1\":{\"264\":1}}],[\"一个线程连续两次获得同一把锁\",{\"1\":{\"248\":1}}],[\"一个线程一直占着一个资源不放而导致其他线程得不到执行\",{\"1\":{\"213\":1}}],[\"一个浮点数由3部分组成\",{\"1\":{\"65\":1}}],[\"一个接口是函数式的需要满足特定的条件\",{\"1\":{\"45\":1}}],[\"那内存的可见性呢\",{\"1\":{\"151\":1}}],[\"那具体到java中\",{\"1\":{\"63\":1}}],[\"那关于0的补码表示呢\",{\"1\":{\"63\":1}}],[\"那使用补码再来看看上面的1\",{\"1\":{\"63\":1}}],[\"那来验证下上面的两个运算\",{\"1\":{\"62\":1}}],[\"那让它算下\",{\"1\":{\"61\":1}}],[\"那就是线程中断\",{\"1\":{\"346\":1}}],[\"那就是在获取锁的过程中线程可以被中断\",{\"1\":{\"249\":1}}],[\"那就是匹配了\",{\"1\":{\"111\":1}}],[\"那就是出现在0这个特殊数值上\",{\"1\":{\"62\":1}}],[\"那就是加上了\",{\"1\":{\"45\":1}}],[\"那就把最高位存放符号位呗\",{\"1\":{\"60\":1}}],[\"那我们就去瞅瞅呗\",{\"1\":{\"49\":1}}],[\"那编译报错\",{\"1\":{\"45\":1,\"92\":1}}],[\"那么线程a处于timed\",{\"1\":{\"379\":1}}],[\"那么在第四行输出之前\",{\"1\":{\"376\":1}}],[\"那么在jdk有更好的终止线程的方式吗\",{\"1\":{\"346\":1}}],[\"那么其他所有阻塞在这个临界区上的线程都不能工作\",{\"1\":{\"373\":1}}],[\"那么其他所有需要这个资源的线程就必须在这个临界区中进行等待\",{\"1\":{\"373\":1}}],[\"那么对java的并行计算的研究也就显得非常的必要\",{\"1\":{\"369\":1}}],[\"那么对应的\",{\"1\":{\"65\":1}}],[\"那么设置并返回threadlocal的初始值\",{\"1\":{\"336\":1}}],[\"那么当堆空间不足时\",{\"1\":{\"307\":1}}],[\"那么后续的所有子任务都会停止调度\",{\"1\":{\"270\":1}}],[\"那么输出结果如下\",{\"1\":{\"359\":1}}],[\"那么输出结果\",{\"1\":{\"270\":1}}],[\"那么立即执行\",{\"1\":{\"269\":1}}],[\"那么也会造成写线程的长时间阻塞引发饥饿的问题\",{\"1\":{\"262\":1}}],[\"那么也必须释放相同次数的锁\",{\"1\":{\"248\":1}}],[\"那么此次的输出结果\",{\"1\":{\"241\":1}}],[\"那么java中都有哪些类似的元字符呢\",{\"1\":{\"111\":1}}],[\"那么会有那些对象呢\",{\"1\":{\"110\":1}}],[\"那么使用\",{\"1\":{\"100\":1}}],[\"那么返回defaultvalue\",{\"1\":{\"93\":1}}],[\"那么可以使用collectors\",{\"1\":{\"78\":1}}],[\"那么就会造成其他很多人没办法就餐\",{\"1\":{\"226\":1}}],[\"那么就可以对数值进行算术运算了\",{\"1\":{\"61\":1}}],[\"那么就算没有\",{\"1\":{\"45\":1}}],[\"那么原码能够表示该整数类型数值的范围就是\",{\"1\":{\"61\":1}}],[\"那么作为一个函数接口\",{\"1\":{\"45\":1}}],[\"那么编译器会发出警告信息\",{\"1\":{\"37\":1}}],[\"什么是事务\",{\"0\":{\"401\":1}}],[\"什么是线程\",{\"0\":{\"367\":1,\"368\":1}}],[\"什么是线程池\",{\"0\":{\"269\":1}}],[\"什么是timezone\",{\"1\":{\"126\":1}}],[\"什么是正则表达式\",{\"0\":{\"110\":1}}],[\"什么是补码\",{\"0\":{\"63\":1},\"1\":{\"63\":1}}],[\"什么是反码\",{\"0\":{\"62\":1}}],[\"什么是原码\",{\"0\":{\"61\":1}}],[\"什么是函数接口\",{\"0\":{\"45\":1}}],[\"什么是设计模式\",{\"0\":{\"10\":1},\"1\":{\"10\":1}}],[\"易于理解和维护\",{\"1\":{\"43\":1}}],[\"使得乐观锁完全不会阻塞写线程\",{\"1\":{\"263\":1}}],[\"使得它们很容易适应几乎任何lambda表达式\",{\"1\":{\"44\":1}}],[\"使用条件cache\",{\"0\":{\"393\":1}}],[\"使用cache注解\",{\"0\":{\"387\":1}}],[\"使用这种方法很少是合适的\",{\"1\":{\"351\":1}}],[\"使用isinterrupted\",{\"1\":{\"346\":1}}],[\"使用重入锁保护临界区资源i\",{\"1\":{\"247\":1}}],[\"使用fork\",{\"1\":{\"202\":1}}],[\"使用\",{\"0\":{\"135\":1,\"142\":1,\"162\":1,\"168\":1,\"174\":1,\"193\":1,\"199\":1,\"234\":1,\"241\":1,\"263\":1},\"1\":{\"119\":4}}],[\"使用以下命令行编译和运行\",{\"1\":{\"110\":1}}],[\"使用mockito的when方法设置方法调用\",{\"1\":{\"102\":1}}],[\"使用argumentcaptor的getvalue方法获取捕获的参数值\",{\"1\":{\"102\":1}}],[\"使用argumentcaptor\",{\"1\":{\"102\":1}}],[\"使用anymatch\",{\"1\":{\"94\":2}}],[\"使用步骤如下\",{\"1\":{\"102\":1}}],[\"使用equals\",{\"1\":{\"92\":1}}],[\"使用==\",{\"1\":{\"92\":1}}],[\"使用docker部署项目\",{\"1\":{\"88\":1}}],[\"使用补码\",{\"0\":{\"67\":1}}],[\"使用实例对象\",{\"1\":{\"48\":1}}],[\"使用类名\",{\"1\":{\"48\":3}}],[\"使代码更加简洁\",{\"1\":{\"43\":1}}],[\"使我们可以在稍后某个时刻非常方便的使用这些数据\",{\"1\":{\"36\":1}}],[\"它支持多种oss的上传\",{\"1\":{\"432\":1}}],[\"它处于terminated状态\",{\"1\":{\"380\":1}}],[\"它强调没有一个线程可以妨碍其他线程执行\",{\"1\":{\"373\":1}}],[\"它既满足原子性要求\",{\"1\":{\"360\":1}}],[\"它会进入此状态\",{\"1\":{\"377\":1}}],[\"它会进入阻塞状态直到线程2也调用了exchange\",{\"1\":{\"194\":1}}],[\"它会完成这个程序应该要完成的业务操作\",{\"1\":{\"352\":1}}],[\"它可能有助于重现由于竞争条件而导致的错误\",{\"1\":{\"351\":1}}],[\"它可以认为是系统的工作线程\",{\"1\":{\"352\":1}}],[\"它可以确保系统中一个类只产生一个实例\",{\"1\":{\"314\":1}}],[\"它可以指定多个线程同时访问某个资源\",{\"1\":{\"257\":1}}],[\"它可以在两个线程之间交换数据\",{\"1\":{\"192\":1}}],[\"它可以决定是否重试\",{\"1\":{\"150\":1}}],[\"它并不会使线程立即退出\",{\"1\":{\"346\":1}}],[\"它只会在当前线程中串行地执行run\",{\"1\":{\"342\":1}}],[\"它是一种对象创建模式\",{\"1\":{\"314\":1}}],[\"它是浮点数的主要存储方案\",{\"1\":{\"65\":1}}],[\"它管理着线程以为接收提交线程的任务\",{\"1\":{\"269\":1}}],[\"它保证没有饥饿发生\",{\"1\":{\"264\":1}}],[\"它不会进行等待而是立即返回\",{\"1\":{\"257\":1}}],[\"它也可能很有用\",{\"1\":{\"351\":1}}],[\"它也可以实现线程间的计数等待\",{\"1\":{\"185\":1}}],[\"它也被编译器当成函数式接口\",{\"1\":{\"45\":1}}],[\"它\",{\"1\":{\"149\":1}}],[\"它就会立即返回null\",{\"1\":{\"143\":1}}],[\"它就会立即返回false\",{\"1\":{\"143\":1}}],[\"它匹配一些字符\",{\"1\":{\"119\":1}}],[\"它里面涵盖了正则的所有要求\",{\"1\":{\"110\":1}}],[\"它的状态图如下\",{\"1\":{\"374\":1}}],[\"它的使用应该与详细的分析和基准测试相结合\",{\"1\":{\"351\":1}}],[\"它的有效范国在1到10之间\",{\"1\":{\"348\":1}}],[\"它的作用在于跟踪垃圾回收过程\",{\"1\":{\"309\":1}}],[\"它的作用是在测试中启用mockito注解的支持\",{\"1\":{\"100\":1}}],[\"它的返回值是线程的到达顺序\",{\"1\":{\"186\":1}}],[\"它的形式为cas\",{\"1\":{\"150\":1}}],[\"它的实现有如下这几种\",{\"1\":{\"143\":1}}],[\"它的风格算是跟perl走得最为接近\",{\"1\":{\"110\":1}}],[\"它用于捕获和验证方法调用时传递的参数值\",{\"1\":{\"102\":1}}],[\"它提供了各种类型的线程池\",{\"1\":{\"269\":1}}],[\"它提供了丰富的功能去满足这些字符多次匹配的需求\",{\"1\":{\"114\":1}}],[\"它提供了一种更便捷的方式来处理集合数据\",{\"1\":{\"78\":1}}],[\"它提供了统一的字节序视图\",{\"1\":{\"65\":1}}],[\"它随着旧的列表改变而改变\",{\"1\":{\"77\":1}}],[\"它接收的参数是可变长度的元素\",{\"1\":{\"76\":1}}],[\"它们都拥有之前由对方线程持有的对象\",{\"1\":{\"193\":1}}],[\"它们各自拥有一个对象\",{\"1\":{\"193\":1}}],[\"它们并行地执行工作\",{\"1\":{\"186\":1}}],[\"它们是通过将要分组的字符放在一组括号内来创建的\",{\"1\":{\"115\":1}}],[\"它们可用于搜索\",{\"1\":{\"110\":1}}],[\"它们分别是function\",{\"1\":{\"50\":1}}],[\"它们允许您以更简洁的方式传递匿名函数\",{\"1\":{\"47\":1}}],[\"它允许您将构造函数本身作为lambda表达式传递\",{\"1\":{\"49\":1}}],[\"它允许您直接引用现有方法或构造函数作为lambda表达式\",{\"1\":{\"48\":1}}],[\"它跟其他普通接口有什么优势或者区别呢\",{\"1\":{\"45\":1}}],[\"它将计算视为数学函数的计算\",{\"1\":{\"43\":1}}],[\"它为我们在代码中添加信息提供了一种形式化的方法\",{\"1\":{\"36\":1}}],[\"千呼万唤始出来\",{\"1\":{\"43\":1}}],[\"||\",{\"1\":{\"77\":2,\"90\":1,\"269\":5}}],[\"|\",{\"1\":{\"37\":1,\"111\":1,\"419\":3}}],[\"关于微服务\",{\"0\":{\"417\":1},\"1\":{\"417\":1}}],[\"关于cache的一切\",{\"0\":{\"385\":1}}],[\"关于setdaemon可以参考\",{\"1\":{\"378\":1}}],[\"关于synchronized与reentrantlock的比较\",{\"1\":{\"205\":1}}],[\"关于notify与notifyall方法的区别\",{\"1\":{\"347\":1}}],[\"关于正则\",{\"1\":{\"110\":1}}],[\"关于如何使用\",{\"1\":{\"103\":1}}],[\"关于如何编写flutter\",{\"1\":{\"3\":1}}],[\"关于函数接口需要注意以下几点\",{\"1\":{\"45\":1}}],[\"关闭不当的编译器警告信息\",{\"1\":{\"37\":1}}],[\"标准注解\",{\"1\":{\"37\":1}}],[\"jit线程可以理解为守护线程\",{\"1\":{\"352\":1}}],[\"j++\",{\"1\":{\"247\":1}}],[\"j\",{\"1\":{\"247\":2}}],[\"jcmd\",{\"1\":{\"212\":1}}],[\"jps\",{\"1\":{\"212\":3}}],[\"jpa\",{\"0\":{\"464\":1},\"1\":{\"86\":1}}],[\"jetbrains\",{\"1\":{\"212\":1}}],[\"join还有些带超时参数的重载方法\",{\"1\":{\"350\":1}}],[\"jointhread\",{\"1\":{\"350\":1}}],[\"join方法允许一个线程等待另一个线程的完成\",{\"1\":{\"350\":1}}],[\"join方法\",{\"0\":{\"350\":1}}],[\"join模式可以进行并行计算以提高效率\",{\"1\":{\"202\":1}}],[\"join是一种基于分治的算法\",{\"1\":{\"202\":1}}],[\"join\",{\"0\":{\"198\":1},\"1\":{\"247\":2,\"248\":1,\"350\":2,\"360\":1,\"378\":1,\"379\":1}}],[\"junit\",{\"1\":{\"127\":3}}],[\"jdk有10个优先级\",{\"1\":{\"348\":1}}],[\"jdk提供了两个非常重要的线程等待wait\",{\"1\":{\"347\":1}}],[\"jdk提供了相应的方法\",{\"1\":{\"248\":1}}],[\"jdk的线程池\",{\"0\":{\"271\":1}}],[\"jdk的包java\",{\"1\":{\"269\":1}}],[\"jdk\",{\"1\":{\"212\":1}}],[\"jdk还提供了组数的查询\",{\"1\":{\"116\":1}}],[\"jdwp=transport=dt\",{\"1\":{\"88\":2}}],[\"jvm的一部分\",{\"1\":{\"376\":1}}],[\"jvm内存模型\",{\"0\":{\"297\":1}}],[\"jvm垃圾收集器\",{\"0\":{\"296\":1},\"1\":{\"296\":1}}],[\"jvm中锁的实现与优化\",{\"0\":{\"219\":1}}],[\"jvm\",{\"0\":{\"459\":1},\"1\":{\"88\":2,\"136\":1}}],[\"jackson\",{\"0\":{\"85\":1}}],[\"javac\",{\"1\":{\"110\":1}}],[\"java是有一个叫java\",{\"1\":{\"110\":1}}],[\"java是面向对象的\",{\"1\":{\"110\":1}}],[\"java新特性\",{\"0\":{\"97\":1}}],[\"java小技巧\",{\"0\":{\"83\":1}}],[\"java提供了各种各样的方法来创建list\",{\"1\":{\"74\":1}}],[\"java虚拟机规定了所有数值类型的大端字节序\",{\"1\":{\"65\":1}}],[\"java本身是平台无关的\",{\"1\":{\"65\":1}}],[\"java中线程的生命周期由jvm控制\",{\"1\":{\"374\":1}}],[\"java中的内存模型\",{\"1\":{\"297\":1}}],[\"java中的timezone\",{\"1\":{\"126\":1}}],[\"java中有没有可以让多个任务同时这个临界资源呢\",{\"1\":{\"256\":1}}],[\"java中提供的copyonwritearraylist做的更狠\",{\"1\":{\"173\":1}}],[\"java中float和double两种类型的表示如下\",{\"1\":{\"65\":1}}],[\"java中integer和long类型也提供了输出二进制补码的支持\",{\"1\":{\"64\":1}}],[\"java中是不存在无符号整数的\",{\"1\":{\"64\":1}}],[\"java函数式接口\",{\"0\":{\"50\":1}}],[\"java\",{\"0\":{\"86\":1,\"286\":1,\"456\":1},\"1\":{\"43\":1,\"48\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"77\":1,\"78\":4,\"88\":1,\"91\":1,\"94\":1,\"97\":1,\"110\":4,\"162\":1,\"212\":13,\"268\":1,\"326\":1,\"329\":5,\"335\":1,\"343\":1,\"347\":1,\"354\":1}}],[\"java内置了三种标准注解\",{\"1\":{\"37\":1}}],[\"jsoninclude\",{\"1\":{\"85\":2}}],[\"json\",{\"1\":{\"14\":4}}],[\"在upic的ouput\",{\"1\":{\"433\":1}}],[\"在upic上配置aliyun\",{\"1\":{\"433\":1}}],[\"在unmodifiablelist的方法中\",{\"1\":{\"77\":1}}],[\"在后面配置upic的时候会用到\",{\"1\":{\"431\":1}}],[\"在oss中创建bucket\",{\"0\":{\"430\":1}}],[\"在使用springboot项目时\",{\"1\":{\"421\":1}}],[\"在用户的profile中添加下列函数\",{\"1\":{\"419\":1}}],[\"在构建方法里面启动线程\",{\"0\":{\"354\":1}}],[\"在线程t中\",{\"1\":{\"352\":1}}],[\"在线程池中\",{\"1\":{\"269\":1}}],[\"在设计并发控制结构\",{\"1\":{\"351\":1}}],[\"在绝大多数时间里\",{\"1\":{\"348\":1}}],[\"在各个平台上表现不一\",{\"1\":{\"348\":1}}],[\"在2秒之后\",{\"1\":{\"347\":1}}],[\"在真实的场景下这个问题可能会更严重\",{\"1\":{\"345\":1}}],[\"在修改完username\",{\"1\":{\"345\":1}}],[\"在上一篇博客我们讲到什么是线程\",{\"1\":{\"340\":1}}],[\"在上述示例中\",{\"1\":{\"103\":1}}],[\"在springboot中使用cache的话\",{\"1\":{\"386\":1}}],[\"在set时\",{\"1\":{\"336\":1}}],[\"在src目录下面\",{\"1\":{\"110\":1}}],[\"在系统gc时\",{\"1\":{\"308\":1}}],[\"在这个例子中\",{\"1\":{\"347\":1}}],[\"在这种情况下\",{\"1\":{\"308\":1}}],[\"在这种情況下\",{\"1\":{\"248\":1}}],[\"在这之外instant\",{\"1\":{\"103\":1}}],[\"在退出临界区时\",{\"1\":{\"247\":1}}],[\"在写入时线程不能读取\",{\"1\":{\"244\":1}}],[\"在实际的应用中\",{\"1\":{\"225\":1}}],[\"在多线程环境中\",{\"1\":{\"376\":1}}],[\"在多长时间内\",{\"1\":{\"269\":1}}],[\"在多核处理器时代\",{\"1\":{\"198\":1}}],[\"在多个线程一起执行的时候\",{\"1\":{\"134\":1}}],[\"在裁判员统计到在场的所有3位运动员还未到齐之前\",{\"1\":{\"186\":1}}],[\"在macos配置upic的权限\",{\"1\":{\"433\":1}}],[\"在macos使用upic上传本地文件到oss\",{\"1\":{\"428\":1}}],[\"在main线程中\",{\"1\":{\"347\":1}}],[\"在main线程中startsignal\",{\"1\":{\"180\":1}}],[\"在mockito\",{\"1\":{\"103\":1}}],[\"在jdk\",{\"1\":{\"150\":1}}],[\"在java世界中\",{\"1\":{\"421\":1}}],[\"在java中线程中断是一种重要的线程协作机制\",{\"1\":{\"346\":1}}],[\"在java中提供了4个级别的引用\",{\"1\":{\"305\":1}}],[\"在java中\",{\"1\":{\"116\":1}}],[\"在java中常见的创建list有两种方式\",{\"1\":{\"75\":1}}],[\"在java9中引入了一些有用的static方法\",{\"1\":{\"76\":1}}],[\"在java虚拟机中\",{\"1\":{\"64\":1}}],[\"在java\",{\"1\":{\"44\":1}}],[\"在硬件层面上\",{\"1\":{\"150\":1}}],[\"在高并发时\",{\"1\":{\"149\":1}}],[\"在put方法中\",{\"1\":{\"143\":1}}],[\"在内存中可见\",{\"1\":{\"136\":1}}],[\"在表达式\",{\"1\":{\"116\":1}}],[\"在字符串文字中使用转义构造\",{\"1\":{\"113\":1}}],[\"在t\",{\"1\":{\"346\":2}}],[\"在try块的结束处\",{\"1\":{\"103\":1}}],[\"在tw的这五年\",{\"0\":{\"33\":1}}],[\"在稍后的版本\",{\"1\":{\"103\":1}}],[\"在controller中会多次调用userservice的create方法\",{\"1\":{\"102\":1}}],[\"在copyof方法中\",{\"1\":{\"77\":1}}],[\"在一定程度上提高测试的可读性和可维护性\",{\"1\":{\"99\":1}}],[\"在build\",{\"1\":{\"99\":1}}],[\"在精确计算或值比较的场景中可能会导致业务逻辑异常\",{\"1\":{\"96\":1}}],[\"在检查java流中是否存在时\",{\"1\":{\"94\":1}}],[\"在编写测试时\",{\"1\":{\"103\":1}}],[\"在编写java代码\",{\"1\":{\"98\":1}}],[\"在编写代码就可以通过变换表达式的位置或者提取方法来优化性能\",{\"1\":{\"90\":1}}],[\"在编译时greeting\",{\"1\":{\"91\":1}}],[\"在编程中\",{\"1\":{\"65\":1}}],[\"在idea上面点击server\",{\"1\":{\"88\":1}}],[\"在ieee\",{\"1\":{\"65\":1}}],[\"在加减运算的时候就出现了幺蛾子\",{\"1\":{\"61\":1}}],[\"在科蓝的这两年\",{\"0\":{\"34\":1}}],[\"装修的心理历程\",{\"0\":{\"32\":1}}],[\"未来的展望\",{\"0\":{\"31\":1}}],[\"顺利的工作\",{\"0\":{\"30\":1}}],[\"幸福的婚姻\",{\"0\":{\"29\":1}}],[\"学习terraform\",{\"0\":{\"27\":1},\"1\":{\"27\":1}}],[\"参考资料\",{\"0\":{\"72\":1,\"277\":1,\"384\":1}}],[\"参考\",{\"0\":{\"21\":1,\"40\":1,\"58\":1,\"81\":1,\"124\":1,\"133\":1,\"140\":1,\"148\":1,\"159\":1,\"166\":1,\"172\":1,\"178\":1,\"184\":1,\"191\":1,\"197\":1,\"203\":1,\"209\":1,\"217\":1,\"232\":1,\"238\":1,\"245\":1,\"255\":1,\"261\":1,\"267\":1,\"292\":1,\"304\":1,\"312\":1,\"324\":1,\"333\":1,\"339\":1,\"357\":1,\"366\":1},\"1\":{\"113\":1,\"347\":1}}],[\"$i\",{\"1\":{\"419\":2}}],[\"$url\",{\"1\":{\"419\":1}}],[\"$\",{\"1\":{\"15\":1,\"118\":1,\"419\":1}}],[\"$home\",{\"1\":{\"13\":1}}],[\">2\",{\"1\":{\"321\":1}}],[\">3\",{\"1\":{\"321\":1}}],[\">=\",{\"1\":{\"53\":1}}],[\">\",{\"1\":{\"15\":1,\"45\":1,\"47\":2,\"51\":3,\"52\":1,\"53\":1,\"54\":1,\"77\":1,\"94\":6,\"101\":3,\"111\":1,\"186\":1,\"194\":2,\"211\":2,\"213\":2,\"234\":1,\"241\":4,\"248\":1,\"335\":2,\"336\":1,\"344\":1,\"345\":1,\"346\":1,\"347\":2,\"350\":1,\"352\":1,\"359\":1,\"375\":1,\"376\":1,\"378\":1,\"379\":1,\"380\":1,\"399\":2}}],[\">>\",{\"1\":{\"15\":1}}],[\"~\",{\"1\":{\"15\":1,\"61\":2,\"63\":1,\"427\":1}}],[\"eventhandle\",{\"1\":{\"399\":1}}],[\"event\",{\"1\":{\"399\":7}}],[\"eventlistener\",{\"1\":{\"399\":3}}],[\"eat\",{\"1\":{\"226\":1}}],[\"eating\",{\"1\":{\"226\":10}}],[\"essay\",{\"0\":{\"452\":1}}],[\"es\",{\"1\":{\"175\":6}}],[\"escape\",{\"1\":{\"113\":1}}],[\"e表示要比较的值\",{\"1\":{\"150\":1}}],[\"e可以放置在表达式内的任何位置\",{\"1\":{\"111\":1}}],[\"err\",{\"1\":{\"110\":1}}],[\"error\",{\"1\":{\"92\":1}}],[\"employees\",{\"1\":{\"94\":2}}],[\"empty\",{\"1\":{\"76\":1,\"100\":1}}],[\"equals\",{\"1\":{\"92\":2}}],[\"enum\",{\"1\":{\"374\":1}}],[\"enqueue\",{\"1\":{\"143\":3}}],[\"end\",{\"1\":{\"110\":1,\"116\":1,\"118\":4,\"226\":2,\"352\":2,\"359\":2}}],[\"ending\",{\"1\":{\"110\":1,\"111\":7,\"117\":1}}],[\"entry\",{\"1\":{\"336\":1}}],[\"enter\",{\"1\":{\"110\":1,\"111\":14,\"117\":4}}],[\"entity\",{\"1\":{\"86\":1}}],[\"environment\",{\"1\":{\"100\":2}}],[\"enablecaching\",{\"1\":{\"386\":1}}],[\"enablecaching显示的开启cache\",{\"1\":{\"386\":1}}],[\"enable\",{\"0\":{\"100\":1}}],[\"enabled\",{\"1\":{\"92\":4}}],[\"else\",{\"1\":{\"77\":1,\"143\":1,\"146\":1,\"257\":1,\"336\":2}}],[\"elementat\",{\"1\":{\"175\":2}}],[\"elementdequeued\",{\"1\":{\"143\":1}}],[\"elements\",{\"1\":{\"76\":6}}],[\"element\",{\"1\":{\"75\":1,\"76\":2,\"146\":1}}],[\"e>\",{\"1\":{\"76\":2,\"77\":2}}],[\"e1\",{\"1\":{\"76\":2}}],[\"e\",{\"1\":{\"75\":2,\"76\":9,\"88\":1,\"94\":4,\"111\":4,\"112\":1,\"142\":4,\"143\":18,\"146\":7,\"150\":1,\"175\":6,\"180\":2,\"186\":4,\"194\":2,\"211\":4,\"234\":2,\"241\":4,\"257\":2,\"269\":2,\"270\":2,\"329\":2,\"336\":3,\"342\":2,\"343\":2,\"344\":2,\"345\":2,\"346\":1,\"347\":3,\"350\":2,\"352\":1,\"378\":1,\"379\":2,\"380\":2}}],[\"extension\",{\"1\":{\"433\":1}}],[\"extensions\",{\"1\":{\"433\":2}}],[\"extendwith\",{\"1\":{\"100\":3}}],[\"extends\",{\"1\":{\"76\":2,\"77\":3,\"101\":1,\"336\":4,\"342\":1,\"351\":1}}],[\"execute\",{\"1\":{\"194\":2,\"399\":1}}],[\"executorservice\",{\"1\":{\"269\":9}}],[\"executors\",{\"1\":{\"186\":1,\"194\":1,\"269\":1,\"270\":1}}],[\"executor\",{\"1\":{\"186\":5,\"194\":4,\"269\":2}}],[\"exchange\",{\"1\":{\"194\":1}}],[\"exchanger<>\",{\"1\":{\"194\":1}}],[\"exchanger<string>\",{\"1\":{\"194\":1}}],[\"exchangertest\",{\"1\":{\"194\":1}}],[\"exchanger\",{\"1\":{\"193\":1,\"194\":2}}],[\"exchanger是在两个任务之间交换对象的栅栏\",{\"1\":{\"193\":1}}],[\"exchanger就是为此而生的\",{\"1\":{\"192\":1}}],[\"except\",{\"1\":{\"112\":2}}],[\"exception\",{\"1\":{\"56\":1,\"180\":1,\"329\":3,\"347\":2}}],[\"exactly\",{\"1\":{\"114\":1}}],[\"exit\",{\"1\":{\"110\":1,\"377\":1}}],[\"existed\",{\"1\":{\"100\":1}}],[\"expressions\",{\"1\":{\"47\":1}}],[\"echo\",{\"1\":{\"15\":1,\"419\":1}}],[\"either\",{\"1\":{\"14\":1}}],[\"nthreads\",{\"1\":{\"269\":4}}],[\"n表示新值\",{\"1\":{\"150\":1}}],[\"n\",{\"1\":{\"110\":2,\"113\":1,\"114\":12,\"150\":1,\"234\":1,\"241\":2,\"248\":6,\"345\":1}}],[\"nio\",{\"0\":{\"108\":1}}],[\"nc\",{\"1\":{\"88\":1}}],[\"num\",{\"1\":{\"257\":4}}],[\"numbers\",{\"1\":{\"47\":2,\"72\":1}}],[\"nullpointerexception\",{\"1\":{\"101\":2,\"269\":1}}],[\"null的instanceof操作符\",{\"0\":{\"95\":1}}],[\"null\",{\"0\":{\"85\":1},\"1\":{\"85\":2,\"91\":1,\"92\":1,\"93\":1,\"95\":2,\"101\":1,\"110\":1,\"137\":1,\"143\":3,\"186\":1,\"269\":3,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":2,\"336\":4,\"343\":2}}],[\"nullcheck\",{\"1\":{\"76\":1,\"77\":1}}],[\"native\",{\"1\":{\"347\":1}}],[\"nanos\",{\"1\":{\"379\":1}}],[\"nan\",{\"1\":{\"65\":1}}],[\"names\",{\"1\":{\"48\":2}}],[\"name\",{\"1\":{\"24\":1,\"54\":2,\"85\":1,\"88\":1,\"100\":1,\"186\":6}}],[\"n就是指数了\",{\"1\":{\"65\":1}}],[\"nextthreadnum\",{\"1\":{\"343\":1}}],[\"nextint\",{\"1\":{\"186\":1,\"194\":1,\"241\":2}}],[\"need\",{\"1\":{\"211\":4}}],[\"negation\",{\"1\":{\"112\":1}}],[\"nenter\",{\"1\":{\"110\":1}}],[\"near\",{\"1\":{\"110\":1}}],[\"newscheduledthreadpool\",{\"1\":{\"269\":3,\"270\":1}}],[\"newsinglethreadscheduledexecutor\",{\"1\":{\"269\":3}}],[\"newsinglethreadexecutor\",{\"1\":{\"269\":3}}],[\"newval\",{\"1\":{\"241\":3}}],[\"newcachedthreadpool\",{\"1\":{\"194\":1,\"269\":3}}],[\"newcondition\",{\"1\":{\"143\":2,\"171\":1}}],[\"newfixedthreadpool\",{\"1\":{\"186\":1,\"269\":4}}],[\"new\",{\"0\":{\"375\":1},\"1\":{\"75\":3,\"76\":5,\"77\":4,\"78\":1,\"96\":2,\"102\":2,\"110\":2,\"142\":7,\"143\":3,\"146\":1,\"171\":1,\"174\":1,\"175\":1,\"180\":6,\"186\":9,\"194\":2,\"211\":6,\"213\":3,\"234\":2,\"241\":10,\"247\":4,\"248\":3,\"257\":6,\"269\":14,\"270\":2,\"306\":1,\"316\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":2,\"327\":1,\"329\":4,\"335\":2,\"336\":2,\"342\":1,\"343\":2,\"344\":2,\"345\":3,\"346\":1,\"347\":4,\"350\":2,\"351\":2,\"352\":2,\"359\":1,\"360\":4,\"374\":2,\"375\":3,\"376\":1,\"377\":4,\"378\":2,\"379\":1,\"380\":2,\"399\":10}}],[\"new的方式引用类的构造方法\",{\"1\":{\"48\":1}}],[\"never\",{\"1\":{\"14\":1}}],[\"norm\",{\"1\":{\"348\":1}}],[\"nosuchfieldexception\",{\"1\":{\"137\":1}}],[\"now\",{\"1\":{\"103\":3,\"142\":4,\"180\":4,\"186\":3,\"194\":2,\"234\":1,\"241\":2,\"269\":1,\"270\":3,\"329\":2,\"347\":4,\"350\":2,\"359\":2}}],[\"no\",{\"1\":{\"86\":1,\"110\":2,\"111\":2,\"117\":1,\"399\":5}}],[\"nonfairsync\",{\"1\":{\"257\":2}}],[\"non\",{\"0\":{\"373\":1},\"1\":{\"85\":2,\"86\":2,\"113\":3,\"118\":1}}],[\"none\",{\"1\":{\"14\":1}}],[\"notify与notifyall的区别\",{\"0\":{\"355\":1}}],[\"notify与notifyall\",{\"1\":{\"347\":1}}],[\"notifythread拿到waitnotifythread\",{\"1\":{\"347\":1}}],[\"notifythread线程被创建运行\",{\"1\":{\"347\":1}}],[\"notifythread\",{\"1\":{\"347\":2}}],[\"notify\",{\"1\":{\"347\":10}}],[\"notify和notifyall方法调用不会释放锁\",{\"1\":{\"347\":1}}],[\"notify和notifyall\",{\"1\":{\"167\":1}}],[\"note\",{\"1\":{\"247\":1,\"348\":1}}],[\"notempty\",{\"1\":{\"143\":4}}],[\"notfull\",{\"1\":{\"143\":4}}],[\"not\",{\"1\":{\"13\":1,\"93\":1,\"100\":1,\"112\":1,\"113\":1,\"114\":2,\"347\":1}}],[\"upic\",{\"1\":{\"433\":1}}],[\"upic是用于上传文件到oss服务器的macos客户端\",{\"1\":{\"432\":1}}],[\"upic配置aliyun上传文件\",{\"0\":{\"428\":1}}],[\"url\",{\"1\":{\"419\":1,\"433\":1}}],[\"url=https\",{\"1\":{\"419\":1}}],[\"u则表示u前面必须不是q\",{\"1\":{\"119\":1}}],[\"u表示u前面为q\",{\"1\":{\"119\":1}}],[\"usercontroller\",{\"1\":{\"102\":1}}],[\"users\",{\"1\":{\"102\":2}}],[\"userservice\",{\"1\":{\"102\":4,\"103\":1}}],[\"user\",{\"1\":{\"102\":3}}],[\"username\",{\"1\":{\"14\":4,\"345\":2,\"399\":6}}],[\"uoe\",{\"1\":{\"76\":6}}],[\"uname\",{\"1\":{\"427\":1}}],[\"unaryoperator<e>\",{\"1\":{\"76\":1}}],[\"unless\",{\"0\":{\"395\":1}}],[\"unlock\",{\"1\":{\"143\":4,\"241\":2,\"247\":1,\"248\":3}}],[\"unpark可以在park之前调用\",{\"1\":{\"234\":1}}],[\"unpark\",{\"1\":{\"234\":2}}],[\"unknown\",{\"1\":{\"212\":2}}],[\"unit\",{\"1\":{\"146\":2,\"180\":1,\"186\":1,\"257\":1,\"269\":3}}],[\"union\",{\"1\":{\"112\":1}}],[\"unsafefield\",{\"1\":{\"137\":3}}],[\"unsafemain\",{\"1\":{\"137\":1}}],[\"unsafe类似于c中的指针\",{\"1\":{\"137\":1}}],[\"unsafe类\",{\"0\":{\"137\":1}}],[\"unsafe\",{\"1\":{\"136\":3,\"137\":7,\"152\":1}}],[\"unsupportedoperationexception\",{\"1\":{\"75\":2,\"76\":1,\"78\":2}}],[\"unclosed\",{\"1\":{\"110\":1}}],[\"unchecked\",{\"1\":{\"76\":2,\"78\":1,\"143\":1,\"336\":1}}],[\"unmodifiablerandomaccesslist是继承自unmodifiablelist的\",{\"1\":{\"77\":1}}],[\"unmodifiablerandomaccesslist<>\",{\"1\":{\"77\":1}}],[\"unmodifiablerandomaccesslist\",{\"1\":{\"77\":1}}],[\"unmodifiablelist是一样的\",{\"1\":{\"78\":1}}],[\"unmodifiablelist中的add和remove等可以修改列表的方法\",{\"1\":{\"77\":1}}],[\"unmodifiablelist<>\",{\"1\":{\"77\":1}}],[\"unmodifiablelist\",{\"1\":{\"74\":1,\"77\":2,\"78\":2}}],[\"util\",{\"0\":{\"286\":1},\"1\":{\"44\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":1,\"54\":2,\"110\":3,\"135\":1,\"247\":1,\"269\":1,\"351\":1}}],[\"u\",{\"1\":{\"14\":2,\"15\":1,\"119\":1,\"136\":2}}],[\"other\",{\"0\":{\"453\":1}}],[\"owner\",{\"1\":{\"347\":1}}],[\"owned\",{\"1\":{\"213\":2}}],[\"only\",{\"1\":{\"399\":2}}],[\"on\",{\"1\":{\"399\":3}}],[\"onaccountevent\",{\"1\":{\"399\":4}}],[\"once\",{\"1\":{\"114\":1}}],[\"one\",{\"1\":{\"86\":1,\"90\":2,\"114\":1,\"399\":3}}],[\"open\",{\"1\":{\"419\":1}}],[\"operand\",{\"1\":{\"90\":2}}],[\"operator\",{\"1\":{\"76\":1}}],[\"operatevalue\",{\"1\":{\"51\":4}}],[\"optional\",{\"1\":{\"100\":1}}],[\"options=\",{\"1\":{\"88\":1}}],[\"oldlist\",{\"1\":{\"78\":1}}],[\"objectfieldoffset\",{\"1\":{\"136\":1}}],[\"object\",{\"1\":{\"76\":1,\"93\":2,\"95\":3,\"143\":4,\"175\":6,\"211\":4,\"212\":4,\"213\":2,\"306\":3,\"378\":1}}],[\"objects\",{\"1\":{\"45\":1,\"76\":1,\"94\":1,\"143\":2,\"336\":1}}],[\"ok\",{\"1\":{\"62\":1}}],[\"out\",{\"1\":{\"48\":1,\"51\":2,\"52\":1,\"53\":1,\"54\":1,\"77\":2,\"78\":1,\"91\":1,\"110\":1,\"116\":1,\"137\":2,\"142\":4,\"174\":2,\"180\":4,\"186\":4,\"194\":2,\"211\":6,\"213\":2,\"234\":2,\"241\":2,\"247\":1,\"248\":3,\"257\":3,\"269\":1,\"270\":3,\"327\":2,\"329\":2,\"335\":4,\"342\":2,\"343\":2,\"344\":2,\"345\":1,\"346\":5,\"347\":6,\"350\":2,\"351\":1,\"352\":2,\"359\":2,\"360\":1,\"375\":2,\"376\":1,\"377\":1,\"378\":3,\"379\":1,\"380\":1}}],[\"output\",{\"1\":{\"14\":3,\"433\":1}}],[\"override注解\",{\"1\":{\"45\":1}}],[\"override\",{\"1\":{\"37\":2,\"45\":1,\"76\":6,\"101\":2,\"142\":2,\"180\":1,\"186\":1,\"247\":1,\"248\":1,\"257\":1,\"269\":1,\"270\":1,\"335\":1,\"336\":1,\"342\":1,\"343\":2,\"351\":1,\"377\":1}}],[\"oss这边的配置完成之后\",{\"1\":{\"431\":1}}],[\"oss创建bucket\",{\"1\":{\"430\":1}}],[\"oss以url远程访问\",{\"1\":{\"428\":1}}],[\"oss\",{\"0\":{\"23\":1},\"1\":{\"25\":1,\"433\":2}}],[\"oss图片迁移实战\",{\"0\":{\"22\":1}}],[\"offer\",{\"1\":{\"143\":1,\"146\":3}}],[\"of是将列表参数放到一个新的数组而不是引用传递到不可变list\",{\"1\":{\"77\":1}}],[\"of方法时\",{\"1\":{\"77\":1}}],[\"of处理的\",{\"1\":{\"77\":1}}],[\"of创建出来的列表是不可变的\",{\"1\":{\"76\":1}}],[\"of的强不可变性\",{\"0\":{\"76\":1}}],[\"ofyaml\",{\"1\":{\"14\":1}}],[\"ofjson\",{\"1\":{\"14\":1}}],[\"of\",{\"1\":{\"14\":1,\"75\":1,\"76\":3,\"77\":2,\"78\":3,\"118\":6,\"174\":1}}],[\"origin\",{\"1\":{\"419\":1}}],[\"org\",{\"1\":{\"54\":1,\"99\":2,\"103\":1,\"212\":1,\"386\":1}}],[\"or\",{\"1\":{\"14\":2,\"92\":2,\"112\":5,\"113\":1,\"114\":3,\"379\":1}}],[\"blog\",{\"1\":{\"433\":2}}],[\"blockrunnable\",{\"1\":{\"377\":4}}],[\"blocking\",{\"0\":{\"373\":2}}],[\"blockingqueue<runnable>\",{\"1\":{\"269\":1}}],[\"blockingqueue<string>\",{\"1\":{\"142\":1}}],[\"blockingqueue的使用场景\",{\"0\":{\"147\":1},\"1\":{\"147\":1}}],[\"blockingqueue方法的总结\",{\"0\":{\"146\":1}}],[\"blockingqueue是一个接口\",{\"1\":{\"143\":1}}],[\"blockingqueuemain\",{\"1\":{\"142\":1}}],[\"blockingqueue\",{\"0\":{\"141\":1},\"1\":{\"143\":1}}],[\"blocked\",{\"0\":{\"377\":1},\"1\":{\"347\":1,\"374\":2}}],[\"block\",{\"1\":{\"142\":1}}],[\"brew\",{\"1\":{\"433\":1}}],[\"brokenbarrierexception\",{\"1\":{\"186\":3}}],[\"b同学抢了a同学的书\",{\"1\":{\"211\":1}}],[\"base\",{\"0\":{\"455\":1,\"461\":1},\"1\":{\"212\":2,\"329\":1}}],[\"barriercommand\",{\"1\":{\"186\":1}}],[\"barrieraction\",{\"1\":{\"186\":3}}],[\"barrier\",{\"1\":{\"186\":3}}],[\"baeldung\",{\"1\":{\"127\":2,\"326\":1,\"354\":1,\"385\":1}}],[\"bvpvyvxjkm8zstspti0l\",{\"1\":{\"160\":1}}],[\"bc\",{\"1\":{\"112\":1}}],[\"bigdecimal是要慢些的\",{\"1\":{\"96\":1}}],[\"bigdecimal\",{\"1\":{\"96\":9}}],[\"bit\",{\"1\":{\"64\":1}}],[\"bytes的直接内存\",{\"1\":{\"137\":1}}],[\"byte\",{\"1\":{\"64\":1}}],[\"b\",{\"1\":{\"47\":2,\"78\":3,\"112\":3,\"116\":4,\"118\":2}}],[\"build\",{\"1\":{\"399\":2,\"427\":1}}],[\"builder\",{\"1\":{\"399\":2}}],[\"buildteam\",{\"1\":{\"100\":1}}],[\"buildcreateteamrequest\",{\"1\":{\"100\":1}}],[\"bucket\",{\"1\":{\"24\":1}}],[\"but\",{\"1\":{\"14\":1,\"93\":1,\"114\":1,\"118\":1}}],[\"boundary\",{\"1\":{\"118\":3}}],[\"boot\",{\"1\":{\"99\":2,\"386\":2}}],[\"bookrequest\",{\"1\":{\"399\":4}}],[\"book\",{\"1\":{\"77\":6,\"399\":3}}],[\"bookservice\",{\"1\":{\"399\":6}}],[\"books\",{\"1\":{\"77\":4,\"399\":2}}],[\"boolean的短路评估\",{\"0\":{\"90\":1}}],[\"boolean\",{\"1\":{\"53\":1,\"76\":1,\"92\":4,\"101\":2,\"110\":1,\"143\":2,\"146\":1,\"175\":1,\"180\":1,\"251\":1,\"257\":4,\"346\":2,\"359\":1}}],[\"boolvar\",{\"1\":{\"14\":2}}],[\"boolvarp\",{\"1\":{\"14\":1}}],[\"bob\",{\"1\":{\"48\":1}}],[\"body\",{\"1\":{\"47\":1}}],[\"both\",{\"1\":{\"14\":1}}],[\"beijing\",{\"1\":{\"345\":1,\"433\":1}}],[\"beginning\",{\"1\":{\"118\":2}}],[\"better\",{\"1\":{\"95\":1}}],[\"before原则\",{\"0\":{\"301\":1}}],[\"before\",{\"1\":{\"95\":1,\"346\":2,\"347\":7,\"378\":2}}],[\"be\",{\"1\":{\"14\":1,\"86\":1}}],[\"38596\",{\"1\":{\"360\":1}}],[\"384057\",{\"1\":{\"142\":1}}],[\"384014\",{\"1\":{\"142\":1}}],[\"3秒之后客户1办理完释放了窗口\",{\"1\":{\"257\":1}}],[\"3s\",{\"1\":{\"257\":1}}],[\"36\",{\"1\":{\"234\":1,\"347\":2}}],[\"366770\",{\"1\":{\"142\":1}}],[\"366780\",{\"1\":{\"142\":1}}],[\"366806\",{\"1\":{\"142\":1}}],[\"33\",{\"1\":{\"234\":1,\"347\":1}}],[\"35\",{\"1\":{\"212\":1,\"226\":1}}],[\"34\",{\"1\":{\"226\":1,\"347\":4}}],[\"3484\",{\"1\":{\"205\":1}}],[\"345\",{\"1\":{\"112\":1}}],[\"3位运动员准备就绪的顺序是\",{\"1\":{\"186\":1}}],[\"3个线程\",{\"1\":{\"186\":1}}],[\"31\",{\"1\":{\"186\":5,\"269\":1,\"329\":1,\"347\":1}}],[\"3号选手\",{\"1\":{\"186\":3}}],[\"391239\",{\"1\":{\"142\":1}}],[\"391177\",{\"1\":{\"142\":1}}],[\"391151\",{\"1\":{\"142\":1}}],[\"391116\",{\"1\":{\"142\":1}}],[\"391060\",{\"1\":{\"142\":1}}],[\"391050\",{\"1\":{\"142\":1}}],[\"390977\",{\"1\":{\"142\":1}}],[\"390930\",{\"1\":{\"142\":1}}],[\"390923\",{\"1\":{\"142\":1}}],[\"390858\",{\"1\":{\"142\":1}}],[\"390801\",{\"1\":{\"142\":1}}],[\"32767这个数用科学计数法可以写成\",{\"1\":{\"65\":1}}],[\"32\",{\"1\":{\"64\":1,\"65\":1,\"234\":1,\"347\":4}}],[\"32位\",{\"1\":{\"64\":1}}],[\"3000\",{\"1\":{\"345\":1}}],[\"30\",{\"1\":{\"51\":2,\"194\":4,\"269\":1}}],[\"3\",{\"1\":{\"14\":1,\"47\":2,\"65\":2,\"78\":1,\"103\":1,\"111\":7,\"112\":3,\"180\":1,\"186\":5,\"226\":4,\"234\":1,\"241\":2,\"257\":3,\"269\":3,\"270\":1,\"347\":1,\"351\":2,\"352\":1,\"359\":1,\"399\":1,\"427\":1}}],[\"281678\",{\"1\":{\"270\":1}}],[\"28\",{\"1\":{\"269\":1}}],[\"267234\",{\"1\":{\"270\":1}}],[\"26\",{\"1\":{\"234\":3,\"270\":3}}],[\"263\",{\"1\":{\"64\":2}}],[\"25t11\",{\"1\":{\"270\":11}}],[\"25\",{\"1\":{\"234\":3,\"270\":8,\"350\":2}}],[\"24\",{\"1\":{\"226\":1}}],[\"296934\",{\"1\":{\"270\":1}}],[\"29\",{\"1\":{\"186\":1,\"269\":1,\"270\":2}}],[\"2号选手\",{\"1\":{\"186\":3}}],[\"2d\",{\"1\":{\"96\":2}}],[\"2ms\",{\"1\":{\"94\":1}}],[\"216820\",{\"1\":{\"359\":1}}],[\"21\",{\"1\":{\"241\":1}}],[\"21264\",{\"1\":{\"205\":1}}],[\"21000001\",{\"1\":{\"65\":1}}],[\"215\",{\"1\":{\"64\":2}}],[\"2−m\",{\"1\":{\"65\":1}}],[\"2−4\",{\"1\":{\"65\":1}}],[\"2−3\",{\"1\":{\"65\":1}}],[\"2−2\",{\"1\":{\"65\":1}}],[\"2n就容易得知\",{\"1\":{\"65\":1}}],[\"2n\",{\"1\":{\"65\":1}}],[\"23t17\",{\"1\":{\"269\":8}}],[\"2392\",{\"1\":{\"212\":1}}],[\"2324\",{\"1\":{\"117\":1}}],[\"2323\",{\"1\":{\"117\":2}}],[\"23\",{\"1\":{\"65\":2,\"162\":1,\"226\":1,\"269\":8}}],[\"231\",{\"1\":{\"64\":2,\"186\":1}}],[\"222\",{\"1\":{\"427\":4}}],[\"22562\",{\"1\":{\"205\":1}}],[\"22\",{\"1\":{\"65\":1,\"142\":16,\"270\":1}}],[\"279348\",{\"1\":{\"270\":1}}],[\"274503\",{\"1\":{\"270\":1}}],[\"27\",{\"1\":{\"186\":1,\"269\":4}}],[\"2767称为尾数\",{\"1\":{\"65\":1}}],[\"2767×104\",{\"1\":{\"65\":1}}],[\"27−1\",{\"1\":{\"61\":1}}],[\"27+1\",{\"1\":{\"61\":1}}],[\"2000000\",{\"1\":{\"247\":1}}],[\"2018\",{\"1\":{\"162\":1}}],[\"20230724150319578\",{\"1\":{\"433\":1}}],[\"2023\",{\"1\":{\"142\":16,\"180\":8,\"186\":7,\"194\":4,\"226\":24,\"234\":6,\"241\":10,\"269\":8,\"270\":11,\"329\":2,\"347\":8,\"350\":2,\"359\":3}}],[\"2022回忆之旅\",{\"0\":{\"28\":1}}],[\"20ms\",{\"1\":{\"94\":1}}],[\"20\",{\"1\":{\"51\":2,\"212\":1,\"241\":1}}],[\"2\",{\"1\":{\"14\":1,\"47\":1,\"61\":2,\"62\":1,\"65\":1,\"76\":1,\"101\":1,\"102\":1,\"112\":2,\"142\":5,\"180\":1,\"186\":3,\"194\":2,\"212\":2,\"226\":4,\"234\":2,\"241\":2,\"248\":1,\"257\":3,\"269\":3,\"270\":2,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":1,\"329\":4,\"346\":1,\"347\":1,\"351\":3,\"352\":1,\"399\":1,\"427\":1}}],[\"scp\",{\"1\":{\"427\":1}}],[\"scheduleatfixedrate\",{\"1\":{\"270\":1}}],[\"schedulewithfixeddelay\",{\"1\":{\"270\":2}}],[\"scheduledthreadpool\",{\"1\":{\"270\":1}}],[\"scheduledthreadpoolexecutor\",{\"1\":{\"269\":2}}],[\"scheduledexecutorservice\",{\"1\":{\"269\":4,\"270\":3}}],[\"ssh\",{\"1\":{\"427\":5}}],[\"sso是个啥玩意\",{\"0\":{\"416\":1},\"1\":{\"416\":1}}],[\"s>\",{\"1\":{\"336\":1}}],[\"slf4j\",{\"0\":{\"284\":1}}],[\"sleepthread\",{\"1\":{\"344\":1}}],[\"sleep方法会导致当前线程暂停执行一段指定的时间\",{\"1\":{\"344\":1}}],[\"sleep\",{\"1\":{\"180\":1,\"186\":1,\"194\":1,\"211\":2,\"234\":1,\"241\":2,\"257\":1,\"269\":1,\"270\":2,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":1,\"329\":2,\"335\":1,\"342\":1,\"343\":1,\"344\":1,\"345\":2,\"346\":1,\"347\":2,\"350\":1,\"352\":2,\"359\":1,\"377\":1,\"378\":1,\"379\":3,\"380\":2}}],[\"shift\",{\"1\":{\"426\":1}}],[\"shutdown\",{\"1\":{\"186\":1,\"194\":1,\"269\":1,\"270\":1}}],[\"should\",{\"1\":{\"100\":1,\"102\":1,\"103\":1}}],[\"short\",{\"1\":{\"64\":2}}],[\"synchronous\",{\"0\":{\"370\":1}}],[\"synchronousqueue<runnable>\",{\"1\":{\"269\":1}}],[\"synchronized通过monitor计数器实现\",{\"1\":{\"328\":1}}],[\"synchronizedtest\",{\"1\":{\"327\":2,\"329\":5}}],[\"synchronized加在了要保护的代码块上\",{\"1\":{\"319\":1}}],[\"synchronized和reentrantlock如何选择\",{\"0\":{\"253\":1}}],[\"synchronized\",{\"1\":{\"136\":1,\"175\":1,\"211\":4,\"213\":2,\"226\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":1,\"326\":1,\"327\":2,\"329\":2,\"347\":2,\"377\":1,\"378\":1}}],[\"sync\",{\"1\":{\"180\":2,\"257\":2}}],[\"system\",{\"1\":{\"48\":1,\"51\":2,\"52\":1,\"53\":1,\"54\":1,\"77\":2,\"78\":1,\"91\":1,\"110\":4,\"116\":1,\"137\":2,\"142\":4,\"174\":2,\"180\":4,\"186\":4,\"194\":2,\"211\":6,\"213\":2,\"234\":2,\"241\":2,\"247\":1,\"248\":3,\"257\":3,\"269\":1,\"270\":3,\"327\":2,\"329\":2,\"335\":4,\"342\":2,\"343\":2,\"344\":2,\"345\":1,\"346\":5,\"347\":6,\"350\":2,\"351\":1,\"352\":2,\"359\":2,\"360\":1,\"375\":2,\"376\":1,\"377\":2,\"378\":3,\"379\":1,\"380\":1}}],[\"swape\",{\"1\":{\"150\":1}}],[\"swap\",{\"1\":{\"136\":1}}],[\"switch\",{\"1\":{\"76\":1}}],[\"singleton\",{\"1\":{\"316\":5,\"317\":5,\"318\":5,\"319\":6,\"320\":6,\"321\":7}}],[\"signal\",{\"1\":{\"143\":2}}],[\"simple\",{\"1\":{\"112\":1}}],[\"size\",{\"1\":{\"78\":1,\"101\":2}}],[\"salaris有231个优先级\",{\"1\":{\"348\":1}}],[\"saved\",{\"1\":{\"399\":11}}],[\"save\",{\"1\":{\"100\":1,\"103\":3,\"399\":6,\"433\":1}}],[\"safevarargs\",{\"1\":{\"76\":1}}],[\"snapshot\",{\"1\":{\"88\":1}}],[\"sun\",{\"1\":{\"212\":1}}],[\"submit\",{\"1\":{\"186\":3,\"269\":1}}],[\"subtraction\",{\"1\":{\"112\":2}}],[\"successed就代表远程的5005接口是可以连通的\",{\"1\":{\"88\":1}}],[\"suspend=n\",{\"1\":{\"88\":2}}],[\"suppliedthreadlocal\",{\"1\":{\"336\":1}}],[\"suppliedthreadlocal<t>\",{\"1\":{\"336\":1}}],[\"suppliedthreadlocal<>\",{\"1\":{\"336\":1}}],[\"supplier<\",{\"1\":{\"336\":3}}],[\"supplier<string>\",{\"1\":{\"54\":1}}],[\"supplierdemo\",{\"1\":{\"54\":1}}],[\"supplier\",{\"0\":{\"54\":1},\"1\":{\"54\":3,\"336\":7}}],[\"suppresswarnings\",{\"1\":{\"37\":2,\"76\":3,\"78\":1,\"143\":1,\"336\":1}}],[\"super\",{\"1\":{\"45\":1,\"76\":1,\"186\":1,\"351\":1}}],[\"space\",{\"1\":{\"426\":1}}],[\"spy和\",{\"1\":{\"99\":1}}],[\"spring事务与applicationeventpublisher\",{\"0\":{\"399\":1}}],[\"spring中多数据源的配置\",{\"1\":{\"397\":1}}],[\"spring\",{\"0\":{\"396\":1,\"462\":1},\"1\":{\"99\":1,\"385\":1,\"386\":1}}],[\"springboot配置和java代码都可以实现全局忽略null的功能\",{\"1\":{\"85\":1}}],[\"springboot中默认序列化json的框架就是jackson了\",{\"1\":{\"85\":1}}],[\"springboot\",{\"0\":{\"84\":1}}],[\"springframework\",{\"1\":{\"54\":1,\"99\":1,\"386\":1}}],[\"spf13\",{\"1\":{\"13\":2}}],[\"srcfunc\",{\"1\":{\"51\":2}}],[\"stop\",{\"1\":{\"345\":2,\"380\":1}}],[\"stopthread\",{\"1\":{\"345\":1}}],[\"stop方法太过于暴力\",{\"1\":{\"345\":1}}],[\"stream中检查存在性\",{\"0\":{\"94\":1}}],[\"stream中的list\",{\"0\":{\"78\":1}}],[\"stream\",{\"1\":{\"78\":3,\"94\":3}}],[\"string表达式加反斜杠\",{\"0\":{\"122\":1}}],[\"string正则加反斜杠\",{\"1\":{\"113\":1}}],[\"stringlist\",{\"1\":{\"78\":6}}],[\"stringutils\",{\"1\":{\"54\":2}}],[\"string\",{\"1\":{\"51\":1,\"52\":2,\"53\":1,\"54\":4,\"78\":3,\"85\":2,\"91\":1,\"92\":1,\"96\":1,\"101\":5,\"110\":6,\"111\":7,\"113\":1,\"116\":1,\"117\":2,\"137\":1,\"142\":1,\"174\":1,\"180\":1,\"186\":3,\"194\":2,\"211\":1,\"213\":1,\"234\":1,\"241\":2,\"247\":1,\"248\":1,\"257\":1,\"269\":1,\"270\":1,\"327\":1,\"329\":1,\"335\":2,\"342\":1,\"343\":1,\"344\":1,\"345\":1,\"346\":1,\"347\":1,\"350\":1,\"351\":4,\"352\":1,\"359\":1,\"360\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1}}],[\"stringvarp\",{\"1\":{\"14\":4}}],[\"stampedlock是不可重入锁\",{\"1\":{\"266\":1}}],[\"stampedlock提供了乐观读锁\",{\"1\":{\"266\":1}}],[\"stampedlock提供了一种乐观的读策略\",{\"1\":{\"263\":1}}],[\"stampedlock的内部实现是基于clh锁的\",{\"1\":{\"264\":1}}],[\"stampedlock\",{\"0\":{\"262\":1},\"1\":{\"262\":1}}],[\"starvationlock\",{\"1\":{\"213\":1}}],[\"starts\",{\"1\":{\"180\":1}}],[\"startsignal的计数量为1\",{\"1\":{\"180\":1}}],[\"startsignal\",{\"1\":{\"180\":3}}],[\"start\",{\"1\":{\"110\":1,\"116\":1,\"142\":13,\"180\":5,\"211\":2,\"213\":2,\"226\":2,\"234\":2,\"241\":4,\"247\":2,\"248\":1,\"257\":1,\"327\":1,\"329\":4,\"335\":1,\"342\":1,\"343\":1,\"344\":1,\"345\":1,\"346\":1,\"347\":2,\"350\":1,\"351\":2,\"352\":1,\"359\":4,\"360\":1,\"376\":1,\"377\":2,\"378\":1,\"379\":1,\"380\":1,\"399\":2}}],[\"starting\",{\"1\":{\"110\":1,\"111\":7,\"117\":1}}],[\"starter\",{\"1\":{\"99\":1,\"386\":1}}],[\"stack\",{\"1\":{\"212\":1}}],[\"state\",{\"1\":{\"347\":6,\"374\":1}}],[\"status\",{\"1\":{\"92\":4}}],[\"static\",{\"1\":{\"51\":3,\"52\":2,\"53\":2,\"54\":2,\"76\":4,\"77\":3,\"91\":2,\"110\":3,\"136\":2,\"137\":1,\"142\":4,\"174\":1,\"175\":1,\"180\":4,\"186\":3,\"194\":3,\"211\":3,\"213\":2,\"234\":2,\"241\":5,\"247\":3,\"248\":2,\"257\":2,\"269\":12,\"270\":2,\"316\":2,\"317\":2,\"318\":2,\"319\":2,\"320\":2,\"321\":2,\"327\":3,\"329\":3,\"335\":1,\"336\":2,\"342\":1,\"343\":1,\"344\":1,\"345\":1,\"346\":2,\"347\":1,\"348\":3,\"350\":1,\"351\":1,\"352\":1,\"359\":2,\"360\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1}}],[\"standard\",{\"0\":{\"89\":1},\"1\":{\"72\":1}}],[\"softreference类实现\",{\"1\":{\"307\":1}}],[\"socket\",{\"1\":{\"88\":2}}],[\"sort\",{\"1\":{\"47\":1,\"76\":1}}],[\"source\",{\"1\":{\"14\":3,\"212\":2}}],[\"semaphore分析\",{\"0\":{\"258\":1}}],[\"semaphore的hasqueuedthreads方法查询是否有线程正在等待获取许可\",{\"1\":{\"257\":1}}],[\"semaphoretest\",{\"1\":{\"257\":1}}],[\"semaphore中主要的方法有\",{\"1\":{\"257\":1}}],[\"semaphore\",{\"1\":{\"257\":4}}],[\"semaphore有以下两个构造函数\",{\"1\":{\"257\":1}}],[\"semaphore使用\",{\"0\":{\"257\":1}}],[\"security\",{\"0\":{\"466\":1}}],[\"second\",{\"1\":{\"433\":1}}],[\"secondssleep\",{\"1\":{\"234\":3}}],[\"seconds\",{\"1\":{\"180\":1,\"211\":2,\"234\":5,\"241\":2,\"269\":2,\"270\":3,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":1,\"329\":2,\"335\":1,\"342\":1,\"343\":1,\"346\":1,\"347\":2,\"350\":1,\"352\":2,\"359\":1,\"378\":1,\"379\":2,\"380\":2}}],[\"secret\",{\"1\":{\"24\":1,\"431\":1}}],[\"senior\",{\"1\":{\"162\":1}}],[\"search\",{\"1\":{\"110\":1,\"111\":7,\"117\":2}}],[\"server=y\",{\"1\":{\"88\":2}}],[\"se5中的重要的语言变化之一\",{\"1\":{\"36\":1}}],[\"setdaemon\",{\"1\":{\"352\":1,\"378\":1}}],[\"setusername\",{\"1\":{\"345\":1}}],[\"setinitialvalue\",{\"1\":{\"336\":2}}],[\"setaddress\",{\"1\":{\"345\":1}}],[\"setarray\",{\"1\":{\"175\":1}}],[\"setaccessible\",{\"1\":{\"137\":1}}],[\"settitle\",{\"1\":{\"77\":1}}],[\"set\",{\"1\":{\"14\":2,\"76\":1,\"167\":1,\"335\":1,\"336\":3}}],[\"sdk\",{\"0\":{\"23\":1}}],[\"s\",{\"1\":{\"14\":1,\"52\":2,\"110\":1,\"113\":3,\"234\":1,\"241\":2,\"248\":3,\"257\":1,\"269\":1,\"345\":2}}],[\"v的值更新为n\",{\"1\":{\"150\":1}}],[\"volatiletest\",{\"1\":{\"359\":1,\"360\":5}}],[\"volatile和native方法来保证原子操作\",{\"1\":{\"136\":1}}],[\"volatile\",{\"1\":{\"130\":1,\"136\":1,\"175\":1,\"321\":1,\"360\":1}}],[\"void\",{\"1\":{\"45\":1,\"51\":1,\"52\":2,\"53\":1,\"54\":1,\"75\":1,\"76\":3,\"91\":2,\"100\":1,\"102\":2,\"103\":1,\"110\":1,\"137\":1,\"142\":3,\"143\":2,\"174\":1,\"180\":4,\"186\":2,\"194\":2,\"211\":1,\"213\":1,\"226\":1,\"234\":2,\"241\":4,\"247\":2,\"248\":2,\"257\":6,\"269\":2,\"270\":2,\"327\":3,\"329\":3,\"335\":1,\"336\":2,\"342\":2,\"343\":3,\"344\":1,\"345\":1,\"346\":2,\"347\":3,\"350\":1,\"351\":2,\"352\":1,\"359\":1,\"360\":3,\"377\":2,\"378\":1,\"379\":1,\"380\":1,\"399\":4}}],[\"verify\",{\"1\":{\"102\":1}}],[\"version\",{\"1\":{\"99\":1,\"103\":1}}],[\"verbose\",{\"1\":{\"14\":3}}],[\"vz\",{\"1\":{\"88\":1}}],[\"varhandle\",{\"0\":{\"129\":1}}],[\"var\",{\"1\":{\"76\":1,\"77\":3,\"78\":4,\"100\":2,\"101\":6,\"103\":1,\"110\":7,\"113\":2,\"116\":1,\"137\":2,\"142\":1,\"174\":2,\"186\":1,\"194\":2,\"211\":2,\"213\":2,\"234\":1,\"241\":2,\"247\":3,\"248\":2,\"257\":1,\"269\":1,\"270\":1,\"335\":2,\"342\":1,\"343\":1,\"344\":1,\"345\":2,\"346\":2,\"347\":2,\"350\":1,\"351\":2,\"352\":1,\"360\":2,\"375\":1,\"376\":1,\"377\":2,\"378\":1,\"379\":1,\"399\":2}}],[\"varargs\",{\"1\":{\"76\":1}}],[\"varlable\",{\"1\":{\"37\":1}}],[\"val\",{\"1\":{\"51\":4}}],[\"value是set方法的参数\",{\"1\":{\"336\":1}}],[\"valueof\",{\"1\":{\"96\":3}}],[\"valueof方法\",{\"1\":{\"96\":1}}],[\"value=flag∗m∗2n\",{\"1\":{\"65\":1}}],[\"value\",{\"1\":{\"51\":7,\"52\":2,\"53\":2,\"54\":3,\"93\":1,\"96\":1,\"136\":3,\"137\":4,\"142\":13,\"241\":3,\"269\":1,\"336\":8}}],[\"v\",{\"1\":{\"14\":1,\"93\":1,\"150\":1}}],[\"viper\",{\"0\":{\"17\":1,\"18\":1,\"24\":1},\"1\":{\"13\":1}}],[\"root\",{\"1\":{\"427\":5}}],[\"rootcmd\",{\"1\":{\"14\":9}}],[\"rsa\",{\"1\":{\"427\":3}}],[\"random\",{\"1\":{\"186\":1,\"194\":1,\"241\":2,\"257\":1}}],[\"randomalphabetic\",{\"1\":{\"101\":1}}],[\"randomaccess\",{\"1\":{\"76\":1,\"77\":1}}],[\"range\",{\"1\":{\"112\":1}}],[\"right\",{\"1\":{\"90\":2}}],[\"running\",{\"1\":{\"359\":3,\"374\":1}}],[\"runner\",{\"1\":{\"186\":5}}],[\"runnable\",{\"0\":{\"376\":1},\"1\":{\"142\":2,\"180\":1,\"186\":2,\"247\":1,\"248\":1,\"257\":3,\"269\":1,\"270\":1,\"343\":2,\"374\":2,\"376\":1,\"377\":1}}],[\"runwith\",{\"1\":{\"100\":1}}],[\"run\",{\"1\":{\"88\":1,\"142\":2,\"180\":1,\"186\":1,\"212\":4,\"247\":1,\"248\":1,\"257\":1,\"269\":1,\"270\":1,\"329\":1,\"342\":1,\"343\":3,\"351\":1,\"375\":1,\"377\":1}}],[\"runtimeexception\",{\"1\":{\"211\":2,\"234\":1,\"241\":2,\"269\":1,\"270\":1,\"329\":3,\"344\":1,\"345\":1,\"347\":2,\"350\":1,\"352\":1,\"378\":1,\"380\":1,\"399\":3}}],[\"runtime\",{\"1\":{\"37\":1}}],[\"rbctl\",{\"1\":{\"15\":2}}],[\"r\",{\"1\":{\"14\":1,\"113\":1,\"427\":1}}],[\"redis\",{\"0\":{\"441\":1}}],[\"rebase\",{\"1\":{\"419\":1}}],[\"ref\",{\"1\":{\"307\":1,\"308\":1}}],[\"references\",{\"1\":{\"48\":1,\"49\":1}}],[\"rejectedexecutionhandler\",{\"1\":{\"269\":1}}],[\"release\",{\"1\":{\"257\":4}}],[\"reluctant\",{\"1\":{\"114\":1}}],[\"reenterlock\",{\"1\":{\"247\":5,\"248\":4}}],[\"reentrantreadwritelock\",{\"1\":{\"241\":1}}],[\"reentrantlock类来实现\",{\"1\":{\"247\":1}}],[\"reentrantlock\",{\"1\":{\"143\":6,\"171\":1,\"241\":1,\"247\":1,\"248\":2,\"251\":1}}],[\"receiveddata\",{\"1\":{\"194\":2}}],[\"recommend2\",{\"1\":{\"96\":1}}],[\"recommend1\",{\"1\":{\"96\":1}}],[\"record降临lombok还有必要吗\",{\"0\":{\"295\":1}}],[\"record\",{\"1\":{\"86\":1}}],[\"record类不能用作jpa实体\",{\"0\":{\"86\":1}}],[\"register\",{\"1\":{\"336\":1}}],[\"region\",{\"1\":{\"14\":3}}],[\"regextestharness\",{\"1\":{\"110\":3}}],[\"regex表示要编译的表达式\",{\"1\":{\"110\":1}}],[\"regex\",{\"1\":{\"110\":11,\"111\":7,\"117\":2}}],[\"regex包的\",{\"1\":{\"110\":1}}],[\"requested\",{\"1\":{\"100\":1}}],[\"requirenonnull\",{\"1\":{\"45\":1,\"76\":1,\"143\":2,\"336\":1}}],[\"requiredargsconstructor\",{\"1\":{\"399\":1}}],[\"required\",{\"1\":{\"14\":3}}],[\"response\",{\"1\":{\"100\":1}}],[\"result\",{\"1\":{\"94\":2,\"100\":2,\"336\":2}}],[\"replaceall\",{\"1\":{\"76\":1}}],[\"repository的行为\",{\"1\":{\"98\":1}}],[\"repo\",{\"1\":{\"13\":1}}],[\"removeall\",{\"1\":{\"77\":1}}],[\"removeif\",{\"1\":{\"77\":1}}],[\"remove\",{\"1\":{\"75\":1,\"76\":1,\"77\":1,\"146\":1}}],[\"remote\",{\"1\":{\"24\":1,\"25\":1,\"419\":1}}],[\"retainall方法皆是抛出异常\",{\"1\":{\"77\":1}}],[\"return\",{\"1\":{\"45\":1,\"51\":2,\"53\":1,\"54\":1,\"76\":6,\"77\":5,\"78\":1,\"100\":1,\"101\":2,\"103\":1,\"110\":2,\"116\":1,\"143\":5,\"146\":1,\"175\":4,\"269\":5,\"316\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":1,\"335\":1,\"336\":6}}],[\"retention\",{\"1\":{\"37\":2}}],[\"readlock\",{\"1\":{\"241\":1}}],[\"readline\",{\"1\":{\"110\":2}}],[\"readwritelock在没有写入的时候\",{\"1\":{\"244\":1}}],[\"readwritelock只允许一个线程写入\",{\"1\":{\"244\":1}}],[\"readwritelock可以提高读取效率\",{\"1\":{\"244\":1}}],[\"readwritelockmain\",{\"1\":{\"241\":1}}],[\"readwritelock这个锁是读写不能同时进行\",{\"1\":{\"173\":1}}],[\"ready\",{\"1\":{\"180\":2,\"374\":1}}],[\"read\",{\"1\":{\"14\":1,\"241\":10}}],[\"window上面有7个优先级且不固定\",{\"1\":{\"348\":1}}],[\"withinitial\",{\"1\":{\"335\":1,\"336\":2}}],[\"with\",{\"0\":{\"85\":1},\"1\":{\"14\":1,\"86\":1,\"100\":1,\"399\":1}}],[\"web\",{\"1\":{\"427\":2}}],[\"web项目的时候\",{\"1\":{\"98\":1}}],[\"weakreference类实现\",{\"1\":{\"308\":1}}],[\"writelock\",{\"1\":{\"241\":1}}],[\"write\",{\"1\":{\"241\":8}}],[\"wait方法会释放锁\",{\"1\":{\"347\":1}}],[\"waitthread线程接着运行\",{\"1\":{\"347\":1}}],[\"waitthread还必须要等待这个锁\",{\"1\":{\"347\":1}}],[\"waitthread接收到notifythread线程的唤醒\",{\"1\":{\"347\":1}}],[\"waitthread\",{\"1\":{\"347\":10}}],[\"waitnotifythread\",{\"1\":{\"347\":7}}],[\"waiting状态\",{\"1\":{\"379\":2}}],[\"waitingstate\",{\"1\":{\"378\":3}}],[\"waiting\",{\"0\":{\"378\":1,\"379\":1},\"1\":{\"180\":2,\"212\":2,\"347\":1,\"374\":4,\"378\":1,\"379\":1}}],[\"wait\",{\"1\":{\"167\":2,\"346\":1,\"347\":11,\"378\":5,\"379\":2}}],[\"www\",{\"1\":{\"127\":2,\"160\":1,\"313\":1,\"326\":1,\"354\":1,\"385\":1}}],[\"workqueue\",{\"1\":{\"269\":5}}],[\"worker\",{\"1\":{\"180\":6}}],[\"workers\",{\"1\":{\"180\":6}}],[\"works\",{\"1\":{\"180\":4}}],[\"work\",{\"0\":{\"454\":1},\"1\":{\"180\":9}}],[\"working\",{\"1\":{\"14\":1}}],[\"word\",{\"1\":{\"113\":2,\"118\":2}}],[\"w\",{\"1\":{\"113\":3}}],[\"whitespace\",{\"1\":{\"113\":2}}],[\"while\",{\"1\":{\"110\":2,\"143\":2,\"213\":1,\"264\":1,\"329\":1,\"352\":1,\"359\":1,\"377\":1}}],[\"when\",{\"1\":{\"100\":3,\"101\":6,\"103\":1}}],[\"15\",{\"1\":{\"270\":2}}],[\"15t20\",{\"1\":{\"180\":8}}],[\"1秒\",{\"1\":{\"269\":1}}],[\"19\",{\"1\":{\"241\":3}}],[\"1964\",{\"1\":{\"13\":1}}],[\"13\",{\"1\":{\"226\":11}}],[\"132\",{\"1\":{\"186\":1}}],[\"1374\",{\"1\":{\"205\":1}}],[\"137113\",{\"1\":{\"180\":1}}],[\"137106\",{\"1\":{\"180\":1}}],[\"137129\",{\"1\":{\"180\":1}}],[\"137088\",{\"1\":{\"180\":1}}],[\"137085\",{\"1\":{\"180\":1}}],[\"137092\",{\"1\":{\"180\":1}}],[\"1号选手\",{\"1\":{\"186\":3}}],[\"14t20\",{\"1\":{\"350\":2}}],[\"14t21\",{\"1\":{\"347\":8}}],[\"14\",{\"1\":{\"226\":2,\"270\":1}}],[\"147\",{\"1\":{\"205\":1}}],[\"145089\",{\"1\":{\"180\":1}}],[\"144588\",{\"1\":{\"180\":1}}],[\"1在表达式中调用该捕获组\",{\"1\":{\"117\":1}}],[\"1d\",{\"1\":{\"96\":2}}],[\"1l\",{\"1\":{\"77\":1}}],[\"1可以不存\",{\"1\":{\"65\":1}}],[\"11s\",{\"1\":{\"257\":1}}],[\"111\",{\"1\":{\"88\":1}}],[\"11111111111111111111111\",{\"1\":{\"65\":1}}],[\"11111111111111111111111111110110\",{\"1\":{\"64\":1}}],[\"11111111\",{\"1\":{\"62\":1,\"63\":1,\"65\":3}}],[\"11111110\",{\"1\":{\"62\":1,\"65\":1}}],[\"11\",{\"1\":{\"65\":1}}],[\"11f\",{\"1\":{\"65\":1}}],[\"1f\",{\"1\":{\"65\":1,\"96\":1}}],[\"16t21\",{\"1\":{\"194\":4}}],[\"16t17\",{\"1\":{\"186\":7}}],[\"16之后\",{\"1\":{\"78\":1}}],[\"16中stream引入的tolist\",{\"1\":{\"78\":1}}],[\"16\",{\"1\":{\"64\":1,\"194\":4}}],[\"16位\",{\"1\":{\"64\":1}}],[\"1211\",{\"1\":{\"205\":1}}],[\"123\",{\"1\":{\"119\":5,\"427\":4}}],[\"123abc\",{\"1\":{\"119\":1}}],[\"12\",{\"1\":{\"88\":1,\"226\":13,\"241\":2}}],[\"125\",{\"1\":{\"65\":1}}],[\"128\",{\"1\":{\"63\":2,\"64\":1}}],[\"127\",{\"1\":{\"61\":2,\"63\":1,\"64\":1}}],[\"1的计算\",{\"1\":{\"63\":1}}],[\"1的计算过程\",{\"1\":{\"61\":1}}],[\"1都能算错🙄\",{\"1\":{\"61\":1}}],[\"1为负\",{\"1\":{\"60\":1}}],[\"1827\",{\"1\":{\"205\":1}}],[\"18\",{\"1\":{\"53\":1,\"88\":1,\"212\":2}}],[\"1795207\",{\"1\":{\"313\":1}}],[\"17\",{\"1\":{\"53\":1}}],[\"105\",{\"1\":{\"427\":4}}],[\"105052\",{\"1\":{\"269\":1}}],[\"104650\",{\"1\":{\"347\":1}}],[\"104777\",{\"1\":{\"269\":1}}],[\"104577\",{\"1\":{\"269\":1}}],[\"104030\",{\"1\":{\"269\":1}}],[\"100387\",{\"1\":{\"347\":1}}],[\"100\",{\"1\":{\"205\":2}}],[\"1000l\",{\"1\":{\"257\":1}}],[\"1000\",{\"1\":{\"194\":1,\"205\":1,\"247\":1,\"344\":1,\"345\":1,\"377\":1}}],[\"10000\",{\"1\":{\"186\":1,\"205\":1,\"360\":2}}],[\"100000\",{\"1\":{\"205\":1}}],[\"100000000\",{\"1\":{\"205\":2}}],[\"10000000000000000000000\",{\"1\":{\"65\":1}}],[\"100000001490116119384765625\",{\"1\":{\"96\":1}}],[\"10000000\",{\"1\":{\"62\":2}}],[\"10000001\",{\"1\":{\"61\":1}}],[\"10000010\",{\"1\":{\"61\":1}}],[\"1024\",{\"1\":{\"137\":1}}],[\"10k\",{\"1\":{\"94\":1}}],[\"10中引入的collectors\",{\"1\":{\"78\":1}}],[\"1010\",{\"1\":{\"64\":1}}],[\"10\",{\"1\":{\"51\":1,\"64\":2,\"205\":1,\"241\":1,\"257\":1,\"347\":1,\"348\":1,\"351\":1,\"360\":1}}],[\"1\",{\"1\":{\"14\":1,\"15\":1,\"47\":2,\"61\":6,\"62\":8,\"63\":6,\"64\":3,\"65\":4,\"76\":2,\"88\":1,\"96\":2,\"101\":3,\"102\":1,\"110\":2,\"112\":2,\"116\":1,\"117\":3,\"142\":4,\"150\":1,\"174\":2,\"175\":1,\"180\":3,\"186\":15,\"194\":6,\"211\":4,\"212\":4,\"226\":4,\"234\":4,\"241\":2,\"248\":1,\"257\":4,\"269\":15,\"270\":13,\"335\":1,\"342\":1,\"343\":1,\"348\":1,\"350\":1,\"351\":3,\"352\":2,\"378\":1,\"379\":1,\"380\":1,\"399\":1,\"419\":1,\"427\":1}}],[\"playgame\",{\"1\":{\"226\":1}}],[\"plugins\",{\"0\":{\"3\":1},\"1\":{\"3\":1}}],[\"p9\",{\"1\":{\"168\":1}}],[\"p8\",{\"1\":{\"168\":1}}],[\"p7\",{\"1\":{\"168\":1}}],[\"p6\",{\"1\":{\"168\":1}}],[\"p5\",{\"1\":{\"168\":1}}],[\"p4\",{\"1\":{\"168\":1}}],[\"p3\",{\"1\":{\"168\":1}}],[\"p2\",{\"1\":{\"168\":1}}],[\"p19\",{\"1\":{\"168\":1}}],[\"p18\",{\"1\":{\"168\":1}}],[\"p17\",{\"1\":{\"168\":1}}],[\"p16\",{\"1\":{\"168\":1}}],[\"p15\",{\"1\":{\"168\":1}}],[\"p14\",{\"1\":{\"168\":1}}],[\"p13\",{\"1\":{\"168\":1}}],[\"p12\",{\"1\":{\"168\":1}}],[\"p11\",{\"1\":{\"168\":1}}],[\"p10\",{\"1\":{\"168\":1}}],[\"p1\",{\"1\":{\"168\":1}}],[\"p0\",{\"1\":{\"168\":1}}],[\"peek\",{\"1\":{\"146\":1}}],[\"period是下一人任务相对于上一个任务的开始时间来的\",{\"1\":{\"270\":1}}],[\"period是下一人任务相对于上一个任务的结束时间来的\",{\"1\":{\"270\":1}}],[\"permits\",{\"1\":{\"257\":8}}],[\"perl\",{\"1\":{\"110\":1}}],[\"person\",{\"1\":{\"85\":1,\"226\":1,\"345\":6}}],[\"persistentflags\",{\"1\":{\"14\":1}}],[\"persistent\",{\"1\":{\"14\":1}}],[\"pull\",{\"1\":{\"419\":1}}],[\"publishevent\",{\"1\":{\"399\":1}}],[\"publisher\",{\"1\":{\"399\":1}}],[\"public\",{\"1\":{\"45\":1,\"51\":2,\"52\":2,\"53\":2,\"54\":2,\"75\":2,\"76\":6,\"77\":1,\"85\":2,\"91\":3,\"101\":3,\"102\":1,\"103\":1,\"110\":4,\"116\":4,\"137\":2,\"142\":4,\"143\":5,\"146\":1,\"174\":2,\"175\":2,\"180\":8,\"186\":10,\"194\":2,\"211\":2,\"213\":2,\"234\":2,\"241\":3,\"247\":5,\"248\":4,\"251\":1,\"257\":12,\"269\":15,\"270\":3,\"316\":2,\"317\":2,\"318\":2,\"319\":2,\"320\":2,\"321\":2,\"327\":2,\"329\":2,\"335\":2,\"336\":3,\"342\":3,\"343\":5,\"344\":2,\"345\":2,\"346\":5,\"347\":4,\"348\":3,\"350\":2,\"351\":3,\"352\":2,\"359\":2,\"360\":2,\"374\":1,\"377\":3,\"378\":2,\"379\":2,\"380\":2,\"386\":1,\"399\":5}}],[\"putindex\",{\"1\":{\"143\":2}}],[\"putint\",{\"1\":{\"137\":1}}],[\"put\",{\"1\":{\"142\":11,\"143\":1,\"146\":1}}],[\"php和awk\",{\"1\":{\"110\":1}}],[\"python\",{\"1\":{\"110\":1}}],[\"pool\",{\"1\":{\"186\":10,\"194\":4,\"269\":8,\"270\":7}}],[\"poll\",{\"1\":{\"143\":1,\"146\":2}}],[\"possessive\",{\"1\":{\"114\":1}}],[\"postmapping\",{\"1\":{\"102\":1}}],[\"point\",{\"1\":{\"72\":1}}],[\"preference\",{\"1\":{\"433\":1}}],[\"pred\",{\"1\":{\"264\":1}}],[\"predicate<integer>\",{\"1\":{\"53\":1}}],[\"predicatevalue\",{\"1\":{\"53\":2}}],[\"predicatedemo\",{\"1\":{\"53\":1}}],[\"predicate\",{\"0\":{\"53\":1},\"1\":{\"53\":3}}],[\"predicate和supplier\",{\"1\":{\"50\":1}}],[\"previous\",{\"1\":{\"118\":1}}],[\"protocol\",{\"0\":{\"445\":1}}],[\"protected\",{\"1\":{\"335\":1,\"336\":1}}],[\"product\",{\"1\":{\"194\":3}}],[\"producer3\",{\"1\":{\"142\":2}}],[\"producer2\",{\"1\":{\"142\":2}}],[\"producer1\",{\"1\":{\"142\":2}}],[\"producer0\",{\"1\":{\"142\":2}}],[\"producer\",{\"1\":{\"142\":3}}],[\"properties\",{\"1\":{\"100\":2}}],[\"provided\",{\"1\":{\"14\":1,\"93\":1}}],[\"priority\",{\"1\":{\"348\":3}}],[\"printf\",{\"1\":{\"234\":1,\"241\":2,\"248\":3,\"345\":1}}],[\"printstacktrace\",{\"1\":{\"142\":2,\"180\":1,\"186\":2,\"194\":1,\"257\":1,\"342\":1,\"343\":1,\"379\":1}}],[\"printvalue\",{\"1\":{\"52\":2}}],[\"println\",{\"1\":{\"48\":1,\"51\":2,\"52\":1,\"53\":1,\"54\":1,\"77\":2,\"78\":1,\"91\":1,\"110\":2,\"116\":1,\"137\":2,\"142\":4,\"174\":2,\"180\":4,\"186\":4,\"194\":2,\"211\":6,\"213\":2,\"234\":1,\"247\":1,\"257\":3,\"269\":1,\"270\":3,\"327\":2,\"329\":2,\"335\":4,\"342\":2,\"343\":2,\"344\":2,\"346\":5,\"347\":6,\"350\":2,\"351\":1,\"352\":2,\"359\":2,\"360\":1,\"375\":2,\"376\":1,\"377\":1,\"378\":3,\"379\":1,\"380\":1}}],[\"private\",{\"1\":{\"51\":2,\"52\":1,\"53\":1,\"54\":1,\"85\":2,\"100\":3,\"102\":1,\"136\":3,\"143\":4,\"175\":1,\"180\":1,\"186\":1,\"194\":1,\"211\":2,\"213\":1,\"234\":1,\"241\":1,\"269\":1,\"316\":2,\"317\":2,\"318\":2,\"319\":2,\"320\":2,\"321\":2,\"336\":2,\"359\":1,\"399\":1}}],[\"pageup\",{\"1\":{\"426\":1}}],[\"pagedown\",{\"1\":{\"426\":1}}],[\"pass2\",{\"1\":{\"399\":1}}],[\"pass\",{\"1\":{\"399\":1}}],[\"password\",{\"1\":{\"14\":4,\"399\":2}}],[\"parent\",{\"1\":{\"327\":2}}],[\"parentmethod\",{\"1\":{\"327\":2}}],[\"parentpattern\",{\"1\":{\"116\":1}}],[\"parkuntil\",{\"1\":{\"379\":1}}],[\"parknanos\",{\"1\":{\"379\":1}}],[\"park\",{\"1\":{\"234\":1,\"378\":1}}],[\"parties\",{\"1\":{\"186\":8}}],[\"parallelism\",{\"0\":{\"371\":1}}],[\"parallel\",{\"1\":{\"127\":2}}],[\"parameterized\",{\"1\":{\"127\":2}}],[\"parameter\",{\"0\":{\"394\":1,\"395\":1},\"1\":{\"37\":1,\"47\":1}}],[\"patternsyntaxexception\",{\"1\":{\"110\":2}}],[\"pattern\",{\"0\":{\"444\":1},\"1\":{\"110\":15,\"113\":4,\"116\":1}}],[\"path\",{\"1\":{\"24\":1}}],[\"package\",{\"1\":{\"37\":1,\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"110\":1}}],[\"pw\",{\"1\":{\"14\":1}}],[\"p\",{\"1\":{\"13\":1,\"14\":1,\"88\":2,\"112\":5,\"313\":1}}],[\"two\",{\"1\":{\"399\":3}}],[\"tutorial\",{\"1\":{\"385\":1}}],[\"t9\",{\"1\":{\"168\":1}}],[\"t8\",{\"1\":{\"168\":1}}],[\"t7\",{\"1\":{\"168\":1}}],[\"t6\",{\"1\":{\"168\":1}}],[\"t5\",{\"1\":{\"168\":1}}],[\"t4\",{\"1\":{\"168\":1}}],[\"t3\",{\"1\":{\"168\":1}}],[\"t2\",{\"1\":{\"168\":1,\"247\":3,\"351\":13,\"377\":3}}],[\"t19\",{\"1\":{\"168\":1}}],[\"t18\",{\"1\":{\"168\":1}}],[\"t17\",{\"1\":{\"168\":1}}],[\"t16\",{\"1\":{\"168\":1}}],[\"t15\",{\"1\":{\"168\":1}}],[\"t14\",{\"1\":{\"168\":1}}],[\"t13\",{\"1\":{\"168\":1}}],[\"t12\",{\"1\":{\"168\":1}}],[\"t11\",{\"1\":{\"168\":1}}],[\"t10\",{\"1\":{\"168\":1}}],[\"t1\",{\"1\":{\"168\":1,\"247\":3,\"248\":3,\"351\":14,\"376\":3,\"377\":2,\"378\":4,\"379\":3,\"380\":5}}],[\"t0\",{\"1\":{\"168\":1}}],[\"task\",{\"1\":{\"269\":3,\"270\":2}}],[\"taskworker\",{\"1\":{\"180\":2}}],[\"takeindex\",{\"1\":{\"143\":3}}],[\"take\",{\"1\":{\"142\":11,\"143\":1,\"146\":1}}],[\"target\",{\"1\":{\"37\":2,\"343\":4}}],[\"tcl\",{\"1\":{\"110\":1}}],[\"timedwaitingstate\",{\"1\":{\"379\":1}}],[\"timed\",{\"0\":{\"379\":1},\"1\":{\"374\":2,\"379\":1}}],[\"timeunit\",{\"1\":{\"180\":2,\"186\":1,\"211\":2,\"234\":1,\"241\":2,\"257\":1,\"269\":5,\"270\":3,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":1,\"329\":2,\"335\":1,\"342\":1,\"343\":1,\"346\":1,\"347\":2,\"350\":1,\"352\":2,\"359\":1,\"378\":1,\"379\":2,\"380\":2}}],[\"timeoutexception\",{\"1\":{\"186\":1}}],[\"timeout\",{\"1\":{\"180\":1,\"186\":1,\"257\":1,\"379\":2}}],[\"time\",{\"1\":{\"142\":20,\"146\":2,\"180\":6,\"194\":6,\"226\":20,\"234\":7,\"241\":12,\"257\":3,\"269\":9,\"270\":14,\"329\":4,\"359\":5}}],[\"timezone的由来\",{\"1\":{\"126\":1}}],[\"timestamp\",{\"1\":{\"103\":2}}],[\"times\",{\"1\":{\"102\":1,\"114\":5}}],[\"title=kotlin\",{\"1\":{\"77\":2}}],[\"tips\",{\"1\":{\"77\":1,\"78\":1,\"92\":1,\"94\":1,\"102\":1,\"103\":1,\"111\":1,\"270\":1,\"344\":1,\"347\":1,\"351\":1,\"433\":1}}],[\"tidy\",{\"1\":{\"13\":1}}],[\"tmp\",{\"1\":{\"76\":3,\"427\":1}}],[\"threadlifecycle\",{\"1\":{\"377\":1}}],[\"threadlocals\",{\"1\":{\"336\":2}}],[\"threadlocalmap的key是threadlocal当前对象\",{\"1\":{\"336\":1}}],[\"threadlocalmap\",{\"1\":{\"336\":6}}],[\"threadlocal<t>\",{\"1\":{\"336\":1}}],[\"threadlocal<s>\",{\"1\":{\"336\":1}}],[\"threadlocal<>\",{\"1\":{\"335\":1}}],[\"threadlocal的get方法\",{\"1\":{\"336\":1}}],[\"threadlocal的set方法\",{\"1\":{\"336\":1}}],[\"threadlocal的初始化\",{\"1\":{\"336\":1}}],[\"threadlocal的分析\",{\"0\":{\"336\":1}}],[\"threadlocal的使用\",{\"0\":{\"335\":1}}],[\"threadlocal\",{\"1\":{\"335\":8,\"336\":1}}],[\"threadlocaltest\",{\"1\":{\"335\":1}}],[\"thread默认的run\",{\"1\":{\"343\":1}}],[\"thread本身是实现了runnable接口的\",{\"1\":{\"341\":1}}],[\"threadfactory\",{\"0\":{\"274\":1},\"1\":{\"269\":6}}],[\"threadpoolexecutor\",{\"1\":{\"269\":4}}],[\"threads\",{\"1\":{\"212\":1,\"360\":4}}],[\"thread2\",{\"1\":{\"211\":2,\"213\":2}}],[\"thread1\",{\"1\":{\"211\":2,\"213\":2}}],[\"thread\",{\"0\":{\"460\":1},\"1\":{\"142\":23,\"180\":7,\"186\":18,\"194\":7,\"211\":12,\"212\":11,\"213\":5,\"226\":20,\"234\":6,\"241\":4,\"247\":2,\"248\":3,\"257\":2,\"269\":9,\"270\":10,\"327\":1,\"329\":7,\"335\":7,\"336\":8,\"342\":3,\"343\":6,\"344\":5,\"345\":3,\"346\":6,\"347\":4,\"350\":5,\"351\":2,\"352\":3,\"354\":1,\"359\":6,\"360\":7,\"374\":1,\"375\":3,\"376\":1,\"377\":3,\"378\":2,\"379\":4,\"380\":2,\"399\":3}}],[\"through\",{\"1\":{\"112\":7}}],[\"throws\",{\"1\":{\"137\":1,\"142\":1,\"143\":2,\"174\":1,\"180\":3,\"186\":3,\"226\":1,\"247\":1,\"248\":1,\"270\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":1,\"329\":1,\"335\":1,\"342\":1,\"344\":1,\"345\":1,\"346\":1,\"347\":2,\"350\":1,\"352\":1,\"359\":1,\"360\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1}}],[\"throw\",{\"1\":{\"75\":2,\"76\":7,\"143\":1,\"146\":1,\"180\":1,\"186\":1,\"211\":2,\"234\":1,\"241\":2,\"269\":3,\"270\":1,\"329\":4,\"344\":1,\"345\":1,\"347\":2,\"350\":1,\"352\":1,\"378\":1,\"380\":1,\"399\":3}}],[\"than\",{\"1\":{\"114\":1}}],[\"their\",{\"1\":{\"180\":4}}],[\"theunsafe\",{\"1\":{\"137\":1}}],[\"thencallrealmethod\",{\"1\":{\"101\":1}}],[\"thenthrow和dothrow的区别\",{\"1\":{\"107\":1}}],[\"thenthrow和dothrow\",{\"0\":{\"107\":1}}],[\"thenthrow\",{\"1\":{\"101\":2}}],[\"thenreturn\",{\"1\":{\"100\":3,\"101\":2,\"103\":1}}],[\"the\",{\"1\":{\"88\":1,\"90\":4,\"93\":4,\"110\":1,\"111\":7,\"117\":1,\"118\":11,\"142\":10,\"180\":12,\"212\":1,\"399\":1}}],[\"them\",{\"1\":{\"14\":1}}],[\"thing\",{\"1\":{\"88\":1}}],[\"thinking\",{\"1\":{\"77\":1}}],[\"this\",{\"1\":{\"78\":1,\"143\":7,\"180\":1,\"186\":5,\"269\":7,\"336\":7,\"343\":1}}],[\"tr\",{\"1\":{\"419\":1}}],[\"transactional\",{\"1\":{\"399\":8}}],[\"transaction与eventlistener\",{\"0\":{\"398\":1}}],[\"transient\",{\"1\":{\"175\":2}}],[\"transform\",{\"1\":{\"65\":1}}],[\"tryacquire\",{\"1\":{\"257\":3}}],[\"trylock\",{\"1\":{\"250\":1}}],[\"try\",{\"1\":{\"103\":1,\"142\":2,\"143\":4,\"180\":1,\"186\":1,\"194\":1,\"211\":2,\"234\":1,\"241\":2,\"247\":1,\"248\":1,\"257\":1,\"269\":1,\"270\":1,\"329\":1,\"342\":1,\"343\":1,\"344\":1,\"345\":1,\"346\":1,\"347\":2,\"350\":1,\"352\":1,\"378\":1,\"379\":1,\"380\":1}}],[\"true\",{\"1\":{\"65\":1,\"90\":1,\"92\":2,\"110\":3,\"137\":1,\"143\":1,\"146\":1,\"175\":1,\"213\":1,\"248\":2,\"329\":1,\"346\":1,\"352\":2,\"359\":1,\"377\":1,\"378\":1}}],[\"terraform\",{\"0\":{\"450\":1}}],[\"terminatedstate\",{\"1\":{\"380\":1}}],[\"terminated\",{\"0\":{\"380\":1},\"1\":{\"347\":2,\"374\":2}}],[\"terminatingthreadlocal这个特殊的threadlocal\",{\"1\":{\"336\":1}}],[\"terminatingthreadlocal<\",{\"1\":{\"336\":1}}],[\"terminatingthreadlocal\",{\"1\":{\"336\":2}}],[\"terminator\",{\"1\":{\"118\":1}}],[\"terminators\",{\"1\":{\"113\":1}}],[\"tencent\",{\"1\":{\"313\":1}}],[\"text\",{\"1\":{\"110\":1,\"111\":7,\"117\":1}}],[\"tests\",{\"1\":{\"127\":2}}],[\"test中就已经包含了mocktio\",{\"1\":{\"99\":1}}],[\"testimplementation\",{\"1\":{\"99\":2,\"103\":1}}],[\"test\",{\"1\":{\"53\":1,\"99\":1,\"100\":1,\"102\":1,\"103\":2,\"127\":1}}],[\"teamappservice\",{\"1\":{\"100\":3}}],[\"teamappservicetest\",{\"1\":{\"100\":1}}],[\"teamproperties\",{\"1\":{\"100\":1}}],[\"teamrepository\",{\"1\":{\"100\":4}}],[\"teamcmd\",{\"1\":{\"13\":1}}],[\"team\",{\"1\":{\"13\":1,\"100\":3}}],[\"t>\",{\"1\":{\"45\":1,\"77\":1,\"336\":2}}],[\"t\",{\"1\":{\"45\":6,\"51\":2,\"90\":2,\"113\":1,\"336\":20,\"344\":3,\"345\":3,\"346\":7,\"350\":5,\"352\":3,\"427\":1}}],[\"type\",{\"1\":{\"37\":1}}],[\"tonanos\",{\"1\":{\"269\":1}}],[\"tostring\",{\"1\":{\"174\":1}}],[\"top\",{\"1\":{\"162\":1}}],[\"tohexstring\",{\"1\":{\"137\":1}}],[\"tools\",{\"1\":{\"212\":1}}],[\"tool\",{\"0\":{\"468\":1},\"1\":{\"88\":1}}],[\"tolist方法其实返回的是new\",{\"1\":{\"78\":1}}],[\"tolist\",{\"1\":{\"78\":5}}],[\"toarray\",{\"1\":{\"77\":1,\"78\":1,\"174\":1}}],[\"toctou\",{\"1\":{\"76\":1}}],[\"tobinarystring\",{\"1\":{\"64\":2}}],[\"tounmodifiablelist\",{\"1\":{\"78\":2}}],[\"touppercase\",{\"1\":{\"52\":1,\"78\":3}}],[\"touch\",{\"1\":{\"13\":1}}],[\"together\",{\"1\":{\"14\":1}}],[\"to\",{\"1\":{\"14\":1,\"76\":1,\"88\":1,\"110\":1,\"111\":7,\"117\":2,\"142\":10,\"180\":2,\"212\":2,\"329\":2}}],[\"l\",{\"1\":{\"212\":1}}],[\"lq\",{\"1\":{\"112\":1}}],[\"len\",{\"1\":{\"175\":3}}],[\"length\",{\"1\":{\"76\":3,\"119\":1,\"143\":4,\"175\":1}}],[\"least\",{\"1\":{\"114\":2}}],[\"left\",{\"1\":{\"90\":2}}],[\"lombok一键生成代码\",{\"0\":{\"293\":1}}],[\"logback\",{\"0\":{\"288\":1}}],[\"log4j2\",{\"0\":{\"289\":1}}],[\"log4j\",{\"0\":{\"287\":1}}],[\"logging\",{\"0\":{\"283\":1,\"286\":1}}],[\"locks包中的结构\",{\"1\":{\"351\":1}}],[\"locks\",{\"1\":{\"247\":1}}],[\"locksupport\",{\"1\":{\"234\":3,\"378\":1,\"379\":2}}],[\"locksupportmain\",{\"1\":{\"234\":1}}],[\"locked\",{\"1\":{\"212\":2,\"264\":2}}],[\"lock2\",{\"1\":{\"211\":8}}],[\"lock1\",{\"1\":{\"211\":8}}],[\"lock替代了synchronized方法和语句的使用\",{\"1\":{\"167\":1}}],[\"lockinterruptibly\",{\"1\":{\"143\":2}}],[\"lock\",{\"1\":{\"143\":22,\"171\":3,\"175\":2,\"212\":3,\"213\":6,\"241\":16,\"247\":5,\"248\":18}}],[\"localdatetime\",{\"1\":{\"142\":4,\"180\":4,\"186\":3,\"194\":2,\"234\":1,\"241\":2,\"269\":1,\"270\":3,\"329\":2,\"347\":4,\"350\":2,\"359\":2}}],[\"localcmd\",{\"1\":{\"14\":1}}],[\"local\",{\"1\":{\"14\":1,\"24\":2,\"25\":1,\"37\":1}}],[\"lookbehind\",{\"1\":{\"119\":2}}],[\"lookahead\",{\"1\":{\"119\":2}}],[\"longadder\",{\"1\":{\"205\":1}}],[\"long\",{\"1\":{\"64\":1,\"136\":1,\"137\":2,\"180\":2,\"186\":1,\"257\":1,\"269\":1,\"379\":4}}],[\"lamda表达式里面的异常不能throw\",{\"0\":{\"364\":1}}],[\"lambda$main$1\",{\"1\":{\"212\":1}}],[\"lambda$main$0\",{\"1\":{\"212\":1}}],[\"lambda为什么不能抛出异常\",{\"0\":{\"56\":1}}],[\"lambdaresult\",{\"1\":{\"51\":2}}],[\"lambda\",{\"1\":{\"47\":1}}],[\"lambda表达式在java\",{\"1\":{\"56\":1}}],[\"lambda表达式的语法如下\",{\"1\":{\"47\":1}}],[\"lambda表达式\",{\"0\":{\"47\":1},\"1\":{\"47\":1}}],[\"lang\",{\"1\":{\"212\":6,\"307\":1,\"308\":1,\"329\":2,\"347\":1}}],[\"launcher\",{\"1\":{\"212\":1}}],[\"latch\",{\"1\":{\"180\":1}}],[\"latest\",{\"1\":{\"13\":1}}],[\"life\",{\"0\":{\"451\":1}}],[\"lifecycle\",{\"1\":{\"374\":1}}],[\"livelock\",{\"1\":{\"214\":1}}],[\"liveness\",{\"1\":{\"212\":5}}],[\"liveness和readiness\",{\"0\":{\"26\":1},\"1\":{\"26\":1}}],[\"literal\",{\"1\":{\"113\":1}}],[\"linkedblockingqueue<runnable>\",{\"1\":{\"269\":2}}],[\"linkedblockingqueue是基于链表实现的\",{\"1\":{\"143\":1}}],[\"linkedblockingdeque<>\",{\"1\":{\"142\":1}}],[\"line\",{\"1\":{\"113\":1,\"118\":2}}],[\"linux\",{\"1\":{\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"102\":2,\"335\":2,\"345\":2}}],[\"listed\",{\"1\":{\"212\":1}}],[\"listmock\",{\"1\":{\"101\":19}}],[\"list2\",{\"1\":{\"77\":2}}],[\"listn<\",{\"1\":{\"77\":1}}],[\"listn<>\",{\"1\":{\"76\":1}}],[\"listn\",{\"1\":{\"77\":1}}],[\"list12\",{\"1\":{\"77\":1}}],[\"list12<>\",{\"1\":{\"76\":3}}],[\"listcopy\",{\"1\":{\"77\":2}}],[\"listfromarray方法的代码\",{\"1\":{\"76\":1}}],[\"listfromarray\",{\"1\":{\"76\":2}}],[\"list的不可变性\",{\"0\":{\"74\":1}}],[\"list<\",{\"1\":{\"77\":1}}],[\"list<t>\",{\"1\":{\"77\":2,\"78\":2}}],[\"list<e>\",{\"1\":{\"76\":5,\"77\":4}}],[\"list<string>\",{\"1\":{\"48\":1}}],[\"list<integer>\",{\"1\":{\"47\":1}}],[\"list\",{\"0\":{\"76\":1},\"1\":{\"25\":2,\"47\":1,\"76\":3,\"77\":10,\"78\":6,\"174\":5}}],[\"license\",{\"1\":{\"13\":1}}],[\"a的钱被扣了\",{\"1\":{\"345\":1}}],[\"availablewindow\",{\"1\":{\"257\":4}}],[\"avoid\",{\"1\":{\"76\":1}}],[\"a想让b通过往右边礼让\",{\"1\":{\"214\":1}}],[\"a同学抢了b同学的钢笔\",{\"1\":{\"211\":1}}],[\"await\",{\"1\":{\"143\":2,\"180\":7,\"186\":5}}],[\"aqs是何方神圣\",{\"0\":{\"128\":1}}],[\"aaa\",{\"1\":{\"116\":1}}],[\"ad\",{\"1\":{\"112\":1}}],[\"added\",{\"1\":{\"101\":4}}],[\"address=\",{\"1\":{\"88\":2}}],[\"address\",{\"1\":{\"85\":1,\"137\":2,\"345\":2}}],[\"addall\",{\"1\":{\"76\":1,\"77\":1}}],[\"add\",{\"1\":{\"13\":3,\"75\":1,\"76\":1,\"77\":1,\"78\":3,\"101\":9,\"146\":2,\"174\":1,\"175\":1,\"360\":1,\"399\":3}}],[\"atomicinteger类主要利用cas\",{\"1\":{\"136\":1}}],[\"atomicinteger\",{\"1\":{\"135\":2,\"136\":2,\"205\":1,\"360\":2}}],[\"atomic下\",{\"1\":{\"135\":1}}],[\"atomic翻译成中文是原子的意思\",{\"1\":{\"134\":1}}],[\"atomic原子类\",{\"0\":{\"134\":1}}],[\"at\",{\"1\":{\"110\":2,\"111\":14,\"114\":3,\"117\":2,\"212\":6,\"329\":2}}],[\"above\",{\"1\":{\"212\":1}}],[\"aba问题\",{\"0\":{\"154\":1}}],[\"abd\",{\"1\":{\"111\":4}}],[\"abc444\",{\"1\":{\"119\":1}}],[\"abc123\",{\"1\":{\"119\":4}}],[\"abcabcabc\",{\"1\":{\"111\":1}}],[\"abc\",{\"1\":{\"110\":1,\"111\":4,\"112\":1,\"119\":5}}],[\"ab\",{\"1\":{\"110\":1,\"111\":11,\"112\":2}}],[\"abstractqueuedsynchronizer\",{\"1\":{\"128\":1}}],[\"abstractlist<string>\",{\"1\":{\"101\":1}}],[\"abstractlist类中\",{\"1\":{\"75\":1}}],[\"abstractimmutablecollection<e>\",{\"1\":{\"76\":1}}],[\"abstractimmutablelist<e>\",{\"1\":{\"76\":1}}],[\"abstract\",{\"1\":{\"76\":1}}],[\"as\",{\"1\":{\"399\":1}}],[\"async\",{\"1\":{\"399\":2}}],[\"asynchronous\",{\"0\":{\"370\":1}}],[\"assertj\",{\"0\":{\"279\":1}}],[\"assertions\",{\"1\":{\"119\":1}}],[\"assertthrows\",{\"1\":{\"101\":3}}],[\"assertthat\",{\"1\":{\"100\":1,\"101\":3,\"102\":3,\"103\":1}}],[\"aslist是不允许add和remove\",{\"1\":{\"75\":1}}],[\"aslist却没有重写add和remove方法\",{\"1\":{\"75\":1}}],[\"aslist\",{\"1\":{\"47\":1,\"48\":1,\"74\":1,\"75\":1,\"78\":1}}],[\"anystring\",{\"1\":{\"101\":4}}],[\"any\",{\"1\":{\"100\":1,\"101\":4,\"112\":1,\"113\":1,\"118\":1}}],[\"anymatch\",{\"1\":{\"94\":1}}],[\"android\",{\"0\":{\"435\":1}}],[\"and\",{\"1\":{\"76\":1,\"110\":1,\"111\":7,\"112\":6,\"117\":1,\"119\":1,\"136\":1,\"150\":1,\"248\":6,\"345\":2,\"399\":2}}],[\"andthenresult\",{\"1\":{\"51\":2}}],[\"andthen\",{\"1\":{\"45\":1,\"51\":1}}],[\"agentlib\",{\"1\":{\"88\":2}}],[\"acquireuninterruptibly\",{\"1\":{\"257\":2}}],[\"acquire\",{\"1\":{\"257\":4}}],[\"accounts\",{\"1\":{\"399\":4}}],[\"accountstatus\",{\"1\":{\"92\":2}}],[\"account2\",{\"1\":{\"399\":2}}],[\"accounteventhandler\",{\"1\":{\"399\":1}}],[\"accountevent\",{\"1\":{\"399\":7}}],[\"accountrepository\",{\"1\":{\"399\":2}}],[\"account\",{\"1\":{\"399\":6}}],[\"accept\",{\"1\":{\"45\":3,\"52\":1}}],[\"action\",{\"1\":{\"77\":3,\"226\":1}}],[\"allocatememory\",{\"1\":{\"137\":1}}],[\"allownulls\",{\"1\":{\"77\":1}}],[\"all\",{\"1\":{\"76\":1,\"86\":1,\"114\":1}}],[\"alice\",{\"1\":{\"48\":1}}],[\"aliyuncs\",{\"1\":{\"433\":1}}],[\"aliyun客户端配置\",{\"0\":{\"432\":1}}],[\"aliyun服务器的配置项主要有两个\",{\"1\":{\"429\":1}}],[\"aliyun服务器配置\",{\"0\":{\"429\":1}}],[\"aliyun\",{\"0\":{\"23\":1}}],[\"article\",{\"1\":{\"160\":1,\"313\":1}}],[\"argumentcaptor\",{\"1\":{\"102\":1}}],[\"argumentcaptor<user>\",{\"1\":{\"102\":2}}],[\"argumentcaptor就派上用场了\",{\"1\":{\"102\":1}}],[\"arguments\",{\"1\":{\"88\":1}}],[\"arg\",{\"1\":{\"86\":1}}],[\"args\",{\"1\":{\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"91\":1,\"110\":1,\"137\":1,\"142\":1,\"174\":1,\"180\":1,\"186\":1,\"194\":1,\"211\":1,\"213\":1,\"234\":1,\"241\":2,\"247\":1,\"248\":1,\"257\":1,\"269\":1,\"270\":1,\"327\":1,\"329\":1,\"335\":1,\"342\":1,\"343\":1,\"344\":1,\"345\":1,\"346\":1,\"347\":1,\"350\":1,\"351\":1,\"352\":1,\"359\":1,\"360\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1}}],[\"array\",{\"1\":{\"175\":2}}],[\"arrayblockingqueue的元素由items数组来维护\",{\"1\":{\"143\":1}}],[\"arrayblockingqueue的初始化\",{\"1\":{\"143\":1}}],[\"arrayblockingqueue\",{\"1\":{\"143\":1}}],[\"arrayblockingqueue是基于数组实现的\",{\"1\":{\"143\":1}}],[\"arraylist<thread>\",{\"1\":{\"360\":1}}],[\"arraylist<>\",{\"1\":{\"78\":1}}],[\"arraylist<book>\",{\"1\":{\"77\":1}}],[\"arraylist实现了父类abstractlist的add和remove方法\",{\"1\":{\"75\":1}}],[\"arraylist与aslist\",{\"0\":{\"75\":1}}],[\"arraylist\",{\"1\":{\"74\":1,\"75\":1,\"78\":2}}],[\"arrays\",{\"1\":{\"47\":1,\"48\":1,\"78\":1,\"174\":1,\"175\":1}}],[\"applicationeventpublisher的publishevent方法是同步的\",{\"1\":{\"399\":1}}],[\"apply\",{\"1\":{\"51\":2}}],[\"app\",{\"1\":{\"88\":2}}],[\"apache\",{\"1\":{\"13\":1}}],[\"a\",{\"1\":{\"47\":2,\"78\":3,\"86\":3,\"112\":14,\"113\":7,\"116\":4,\"118\":5,\"175\":2,\"212\":4,\"342\":1,\"343\":1}}],[\"after\",{\"1\":{\"45\":3,\"95\":1,\"234\":2,\"346\":2,\"347\":7,\"378\":1}}],[\"autostash\",{\"1\":{\"419\":1}}],[\"autoload\",{\"1\":{\"15\":1}}],[\"auto\",{\"0\":{\"15\":1}}],[\"author\",{\"1\":{\"13\":1}}],[\"am\",{\"0\":{\"1\":1}}],[\"mni\",{\"1\":{\"348\":1}}],[\"microservice\",{\"0\":{\"465\":1}}],[\"minute\",{\"1\":{\"433\":1}}],[\"millis\",{\"1\":{\"379\":4}}],[\"milliseconds\",{\"1\":{\"269\":2}}],[\"migrate\",{\"1\":{\"25\":1}}],[\"memoryaddress\",{\"1\":{\"137\":5}}],[\"meaning\",{\"1\":{\"114\":1}}],[\"method2\",{\"1\":{\"329\":2}}],[\"method1\",{\"1\":{\"329\":3}}],[\"methods\",{\"1\":{\"76\":1}}],[\"method是有实现的不是abstract的\",{\"1\":{\"45\":1}}],[\"method的\",{\"1\":{\"45\":1}}],[\"method\",{\"1\":{\"37\":1,\"48\":1,\"327\":2,\"329\":2,\"343\":1}}],[\"mylist定义的size\",{\"1\":{\"101\":1}}],[\"mylist\",{\"1\":{\"101\":7}}],[\"myclass\",{\"1\":{\"95\":2}}],[\"mypersondto\",{\"1\":{\"85\":1}}],[\"multiple\",{\"1\":{\"102\":1}}],[\"multiply\",{\"1\":{\"96\":1}}],[\"mutating\",{\"1\":{\"76\":1}}],[\"must\",{\"1\":{\"14\":1,\"86\":1}}],[\"m就是尾数\",{\"1\":{\"65\":1}}],[\"m\",{\"1\":{\"65\":2,\"112\":3,\"114\":4,\"248\":3}}],[\"markdown和ubb\",{\"1\":{\"433\":1}}],[\"markflagsmutuallyexclusive\",{\"1\":{\"14\":1}}],[\"markflagsrequiredtogether\",{\"1\":{\"14\":1}}],[\"markflagrequired\",{\"1\":{\"14\":1}}],[\"macos\",{\"0\":{\"425\":1,\"470\":1}}],[\"max\",{\"1\":{\"269\":1,\"348\":1}}],[\"maximumpoolsize\",{\"1\":{\"269\":6}}],[\"math\",{\"1\":{\"257\":1}}],[\"match\",{\"1\":{\"110\":1,\"111\":2,\"113\":1,\"117\":1,\"118\":1}}],[\"matches\",{\"1\":{\"110\":1}}],[\"matcher类提供了一些以下有用的方法\",{\"1\":{\"116\":1}}],[\"matcher\",{\"1\":{\"110\":10,\"116\":3}}],[\"matcher和patternsyntaxexception\",{\"1\":{\"110\":1}}],[\"may\",{\"1\":{\"113\":2}}],[\"map的get方法返回结果为null是有两种情况\",{\"1\":{\"93\":1}}],[\"map的get方法为null的情况\",{\"0\":{\"93\":1}}],[\"map\",{\"1\":{\"78\":3,\"93\":2,\"336\":9}}],[\"manually\",{\"1\":{\"76\":1}}],[\"main\",{\"1\":{\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"91\":2,\"110\":1,\"137\":1,\"142\":1,\"174\":1,\"180\":1,\"186\":1,\"194\":1,\"211\":1,\"213\":1,\"234\":1,\"241\":2,\"247\":1,\"248\":3,\"257\":1,\"269\":1,\"270\":5,\"327\":1,\"329\":1,\"335\":3,\"342\":2,\"343\":2,\"344\":2,\"345\":1,\"346\":3,\"347\":2,\"350\":3,\"351\":1,\"352\":3,\"359\":1,\"360\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1}}],[\"mongodb\",{\"0\":{\"440\":1}}],[\"month\",{\"1\":{\"433\":1}}],[\"mockedstatic会有自动关闭的机制来清理静态mock\",{\"1\":{\"103\":1}}],[\"mockedstatic实现了autocloseable接口\",{\"1\":{\"103\":1}}],[\"mockedstatic<instant>\",{\"1\":{\"103\":1}}],[\"mockstatic\",{\"1\":{\"103\":1}}],[\"mock对象call真实的方法\",{\"1\":{\"101\":1}}],[\"mock对象void方法抛出异常\",{\"1\":{\"101\":1}}],[\"mock对象方法多次调用\",{\"1\":{\"101\":1}}],[\"mock对象方法抛出异常\",{\"1\":{\"101\":1}}],[\"mock对象方法返回的另一种写法\",{\"1\":{\"101\":1}}],[\"mock对象方法的返回\",{\"1\":{\"101\":1}}],[\"mock\",{\"1\":{\"99\":1,\"100\":2,\"101\":6}}],[\"mocktio推出了支持静态方法mock的mocktio\",{\"1\":{\"103\":1}}],[\"mocktio之静态mock\",{\"0\":{\"103\":1}}],[\"mocktio之capture\",{\"0\":{\"102\":1}}],[\"mocktio还提供了一种使用注解的方式来创建argumentcaptor\",{\"1\":{\"102\":1}}],[\"mocktio的注解\",{\"0\":{\"100\":1}}],[\"mocktio的使用\",{\"0\":{\"98\":1}}],[\"mocktio有很多的注解可供我们使用\",{\"1\":{\"99\":1}}],[\"mockitojunitrunner\",{\"1\":{\"100\":1}}],[\"mockitoextension\",{\"1\":{\"100\":3}}],[\"mockito\",{\"1\":{\"99\":2,\"103\":2}}],[\"more\",{\"1\":{\"13\":1,\"114\":3}}],[\"modified\",{\"1\":{\"347\":1}}],[\"mod\",{\"1\":{\"13\":2}}],[\"mkdir\",{\"1\":{\"13\":1}}],[\"如那个占用资源的线程结束了并释放了资源\",{\"1\":{\"213\":1}}],[\"如何把线程的数据加以隔离\",{\"1\":{\"336\":1}}],[\"如何拒绝任务\",{\"1\":{\"269\":1}}],[\"如何解决夏令时的问题\",{\"1\":{\"126\":1}}],[\"如何编写更健壮更好的java代码\",{\"1\":{\"83\":1}}],[\"如何编写测试\",{\"1\":{\"73\":1}}],[\"如何编写flutter\",{\"0\":{\"3\":1}}],[\"如过滤\",{\"1\":{\"78\":1}}],[\"如下\",{\"1\":{\"65\":1,\"76\":1}}],[\"如图\",{\"1\":{\"65\":1}}],[\"如果在第二行加上volatile修饰符\",{\"1\":{\"359\":1}}],[\"如果在非synchronzied语句中调用这些方法\",{\"1\":{\"347\":1}}],[\"如果修改程序如下所示\",{\"1\":{\"347\":1}}],[\"如果修改上述的main方法如下\",{\"1\":{\"241\":1}}],[\"如果修改上述person类的action方法如下\",{\"1\":{\"226\":1}}],[\"如果暂时无法获得\",{\"1\":{\"347\":1}}],[\"如果target有值的话\",{\"1\":{\"343\":1}}],[\"如果找不到threadlocalmap\",{\"1\":{\"336\":1}}],[\"如果为0\",{\"1\":{\"328\":1}}],[\"如果为null\",{\"1\":{\"186\":1}}],[\"如果发现它还有虚引用\",{\"1\":{\"309\":1}}],[\"如果发现有一个满足条件\",{\"1\":{\"94\":1}}],[\"如果一个目录下面\",{\"1\":{\"419\":1}}],[\"如果一个对象只持有软引用\",{\"1\":{\"307\":1}}],[\"如果一个线程在等待锁\",{\"1\":{\"249\":1}}],[\"如果某个任务遇到异常\",{\"1\":{\"270\":1}}],[\"如果成功返回true\",{\"1\":{\"257\":1}}],[\"如果说一个线程多次获得了锁\",{\"1\":{\"248\":1}}],[\"如果没有可重入同步\",{\"1\":{\"248\":1}}],[\"如果没有满\",{\"1\":{\"143\":1}}],[\"如果是就餐高峰期\",{\"1\":{\"226\":1}}],[\"如果是junit5\",{\"1\":{\"100\":1}}],[\"如果是junit4\",{\"1\":{\"100\":1}}],[\"如果能够在代码的应用层面上进行合理的锁优化\",{\"1\":{\"225\":1}}],[\"如果两个线程之间的数据想要互换这该如何实现\",{\"1\":{\"192\":1}}],[\"如果计数达到零\",{\"1\":{\"180\":1}}],[\"如果你需要能够重置计数值的版本\",{\"1\":{\"180\":1}}],[\"如果你不小心拼写错误\",{\"1\":{\"37\":1}}],[\"如果不是空\",{\"1\":{\"143\":1}}],[\"如果当前队列为空\",{\"1\":{\"143\":1}}],[\"如果当前队列己经满了\",{\"1\":{\"143\":1}}],[\"如果blockqueue是空的\",{\"1\":{\"142\":1}}],[\"如果相同则更新成新的值\",{\"1\":{\"136\":1}}],[\"如果相应的key对应的值是null\",{\"1\":{\"93\":1}}],[\"如果想要上传文件\",{\"1\":{\"427\":1}}],[\"如果想在线程中保存些数据\",{\"1\":{\"334\":1}}],[\"如果想匹配类似于2323这种两个数字\",{\"1\":{\"117\":1}}],[\"如果想stream返回的是可修改的list\",{\"1\":{\"78\":1}}],[\"如果对象为\",{\"1\":{\"95\":1}}],[\"如果accountstatus不是一个枚举\",{\"1\":{\"92\":1}}],[\"如果accountstatus为null\",{\"1\":{\"92\":1}}],[\"如果表达式比较长的话\",{\"1\":{\"90\":1}}],[\"如果0是负数\",{\"1\":{\"63\":1}}],[\"如果0是正数\",{\"1\":{\"63\":1}}],[\"如果接口标注了\",{\"1\":{\"45\":1}}],[\"如果接口满足函数式接口的规则\",{\"1\":{\"45\":1}}],[\"如果程序使用了注解为它的元素\",{\"1\":{\"37\":1}}],[\"如果执行安装了\",{\"1\":{\"13\":1}}],[\"gupa=git\",{\"1\":{\"419\":1}}],[\"gupa\",{\"1\":{\"419\":1}}],[\"guava里面的ratelimiter\",{\"0\":{\"189\":1}}],[\"gh\",{\"1\":{\"419\":1}}],[\"gaming\",{\"1\":{\"226\":10}}],[\"g\",{\"1\":{\"118\":1,\"426\":1}}],[\"gitall\",{\"1\":{\"419\":1}}],[\"git\",{\"0\":{\"467\":1},\"1\":{\"419\":2}}],[\"github的小妙招\",{\"0\":{\"418\":1}}],[\"github\",{\"1\":{\"13\":2,\"419\":1}}],[\"given\",{\"1\":{\"100\":1}}],[\"gradle\",{\"0\":{\"469\":1}}],[\"gradle中的依赖管理\",{\"0\":{\"421\":1}}],[\"gradle中\",{\"1\":{\"99\":1}}],[\"greedy\",{\"1\":{\"114\":1}}],[\"greeting\",{\"1\":{\"91\":4}}],[\"groupcount\",{\"1\":{\"116\":2}}],[\"group\",{\"1\":{\"110\":1,\"116\":4}}],[\"groups\",{\"1\":{\"14\":1}}],[\"getstate\",{\"1\":{\"347\":2,\"375\":1,\"376\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1}}],[\"getusername\",{\"1\":{\"345\":1}}],[\"getunsafe\",{\"1\":{\"136\":1}}],[\"get方法先取得当前线程的threadlocalmap对象\",{\"1\":{\"336\":1}}],[\"getentry\",{\"1\":{\"336\":1}}],[\"getmap\",{\"1\":{\"336\":4}}],[\"getholdcount\",{\"1\":{\"248\":3}}],[\"getnumberwaiting\",{\"1\":{\"186\":2}}],[\"getname\",{\"1\":{\"102\":3,\"142\":4,\"180\":1,\"186\":4,\"194\":2,\"211\":6,\"213\":2,\"269\":1,\"270\":3,\"335\":4,\"351\":1}}],[\"getcount\",{\"1\":{\"180\":2}}],[\"getclass\",{\"1\":{\"77\":2}}],[\"getaddress\",{\"1\":{\"345\":1}}],[\"getarray\",{\"1\":{\"175\":3}}],[\"getallvalues\",{\"1\":{\"102\":3}}],[\"getinstance\",{\"1\":{\"316\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":1}}],[\"getint\",{\"1\":{\"137\":1}}],[\"getid\",{\"1\":{\"100\":1}}],[\"getdeclaredfield\",{\"1\":{\"137\":1}}],[\"getvalue\",{\"1\":{\"102\":2}}],[\"getordefault\",{\"1\":{\"54\":2}}],[\"get\",{\"1\":{\"25\":2,\"54\":1,\"101\":1,\"102\":2,\"137\":1,\"175\":1,\"211\":6,\"213\":1,\"335\":4,\"336\":2}}],[\"golang\",{\"0\":{\"448\":1}}],[\"go\",{\"1\":{\"13\":3}}],[\"cut\",{\"1\":{\"419\":2}}],[\"currentthread\",{\"1\":{\"142\":4,\"180\":1,\"186\":4,\"194\":2,\"211\":6,\"213\":2,\"269\":1,\"270\":3,\"335\":4,\"336\":3,\"379\":1}}],[\"current\",{\"1\":{\"24\":1,\"347\":1}}],[\"cyfonly\",{\"1\":{\"313\":1}}],[\"cyclic\",{\"1\":{\"186\":1}}],[\"cyclicbarriertest\",{\"1\":{\"186\":1}}],[\"cyclicbarrier中主要的方法\",{\"1\":{\"186\":1}}],[\"cyclicbarrier\",{\"1\":{\"186\":4}}],[\"cyclicbarrier类有两个构造方法\",{\"1\":{\"186\":1}}],[\"cyclicbarrier适用于这样的情况\",{\"1\":{\"186\":1}}],[\"cyclicbarrier的使用\",{\"0\":{\"186\":1}}],[\"cyclicbarrier是另外一种多线程并发控制实用工具\",{\"1\":{\"185\":1}}],[\"cmdline\",{\"1\":{\"212\":1}}],[\"crossoverjie\",{\"1\":{\"162\":1}}],[\"createmap\",{\"1\":{\"336\":3}}],[\"createusers\",{\"1\":{\"102\":2}}],[\"createteamrequest\",{\"1\":{\"100\":2}}],[\"create\",{\"1\":{\"13\":2,\"100\":1,\"102\":5}}],[\"cnblogs\",{\"1\":{\"313\":1}}],[\"cn\",{\"1\":{\"160\":1,\"433\":1}}],[\"c\",{\"1\":{\"76\":2,\"78\":3,\"112\":3,\"116\":5}}],[\"caching\",{\"0\":{\"391\":1}}],[\"cachingconfig\",{\"1\":{\"386\":1}}],[\"cache原理\",{\"0\":{\"396\":1}}],[\"cacheconfig\",{\"0\":{\"392\":1}}],[\"cacheput\",{\"0\":{\"390\":1}}],[\"cacheevict\",{\"0\":{\"389\":1}}],[\"cacheable\",{\"0\":{\"388\":1}}],[\"cache\",{\"1\":{\"385\":1,\"386\":2}}],[\"car\",{\"1\":{\"180\":3}}],[\"can\",{\"1\":{\"180\":2}}],[\"capacity\",{\"1\":{\"143\":3}}],[\"capturinggroupcount\",{\"1\":{\"116\":1}}],[\"capture\",{\"1\":{\"102\":3}}],[\"captor\",{\"1\":{\"102\":9}}],[\"catch\",{\"1\":{\"142\":2,\"180\":1,\"186\":2,\"194\":1,\"211\":2,\"234\":1,\"241\":2,\"257\":1,\"269\":1,\"270\":1,\"329\":1,\"342\":1,\"343\":1,\"344\":1,\"345\":1,\"346\":1,\"347\":2,\"350\":1,\"352\":1,\"378\":1,\"379\":1,\"380\":1}}],[\"cask\",{\"1\":{\"433\":1}}],[\"cas的原子操作只能针对一个共享变量\",{\"1\":{\"155\":1}}],[\"cas的操作是乐观的\",{\"1\":{\"150\":1}}],[\"cas包含了3个操作数\",{\"1\":{\"150\":1}}],[\"cas全称compare\",{\"1\":{\"150\":1}}],[\"cas\",{\"0\":{\"150\":1},\"1\":{\"136\":1}}],[\"cas原理\",{\"1\":{\"130\":1}}],[\"case\",{\"1\":{\"76\":3}}],[\"called\",{\"1\":{\"90\":2}}],[\"calculate\",{\"1\":{\"65\":1}}],[\"c语言是有的\",{\"1\":{\"64\":1}}],[\"change\",{\"1\":{\"399\":1}}],[\"character\",{\"1\":{\"110\":1,\"112\":1,\"113\":6}}],[\"charlie\",{\"1\":{\"48\":1}}],[\"child\",{\"1\":{\"327\":2}}],[\"childmethod\",{\"1\":{\"327\":2}}],[\"check\",{\"1\":{\"76\":1}}],[\"checked\",{\"1\":{\"56\":1}}],[\"cloud\",{\"1\":{\"313\":1}}],[\"clh锁的基本思想如下\",{\"1\":{\"264\":1}}],[\"clh锁是一种自旋锁\",{\"1\":{\"264\":1}}],[\"clh锁\",{\"0\":{\"160\":1}}],[\"clear\",{\"1\":{\"77\":1,\"101\":2}}],[\"class的锁\",{\"1\":{\"347\":1,\"377\":1}}],[\"class的锁并进入synchronized块中\",{\"1\":{\"347\":1}}],[\"class的锁并进入到synchronized块中\",{\"1\":{\"347\":1}}],[\"class上面睡眠的某一个线程\",{\"1\":{\"347\":1}}],[\"class\",{\"1\":{\"37\":1,\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"76\":1,\"77\":2,\"85\":2,\"86\":1,\"91\":2,\"100\":6,\"101\":13,\"102\":1,\"103\":1,\"110\":2,\"112\":1,\"136\":1,\"137\":2,\"142\":3,\"174\":1,\"180\":2,\"186\":2,\"194\":1,\"211\":1,\"213\":1,\"226\":1,\"234\":1,\"241\":1,\"247\":1,\"248\":1,\"257\":1,\"269\":2,\"270\":2,\"316\":1,\"317\":1,\"318\":1,\"319\":2,\"320\":2,\"321\":2,\"327\":1,\"329\":1,\"335\":1,\"336\":1,\"342\":1,\"343\":1,\"344\":1,\"345\":1,\"346\":1,\"347\":7,\"350\":1,\"351\":1,\"352\":1,\"359\":1,\"360\":1,\"377\":3,\"378\":3,\"379\":1,\"380\":1,\"386\":1,\"399\":4}}],[\"cli\",{\"0\":{\"13\":1},\"1\":{\"13\":5}}],[\"cd\",{\"1\":{\"13\":1,\"419\":1}}],[\"code\",{\"1\":{\"399\":1}}],[\"corepoolsize\",{\"1\":{\"269\":9}}],[\"core依赖\",{\"1\":{\"103\":1}}],[\"core依赖了\",{\"1\":{\"99\":1}}],[\"core\",{\"1\":{\"99\":2,\"103\":1}}],[\"countdown\",{\"1\":{\"180\":6}}],[\"countdownlatchtest\",{\"1\":{\"180\":1}}],[\"countdownlatch中的方法\",{\"1\":{\"180\":1}}],[\"countdownlatch\",{\"1\":{\"180\":5}}],[\"countdownlatch的分析\",{\"0\":{\"181\":1}}],[\"countdownlatch的构建函数接收一个整数为参数\",{\"1\":{\"180\":1}}],[\"countdownlatch的使用\",{\"0\":{\"180\":1}}],[\"countdownlatch被设计为只触发一次\",{\"1\":{\"180\":1}}],[\"countdownlatch被用来同步一个或多个线程\",{\"1\":{\"180\":1}}],[\"countdownlatch是jdk\",{\"1\":{\"179\":1}}],[\"count++\",{\"1\":{\"143\":1,\"257\":1,\"360\":1}}],[\"count\",{\"1\":{\"94\":1,\"143\":5,\"180\":5,\"186\":1,\"257\":1,\"360\":4}}],[\"collections\",{\"1\":{\"78\":1}}],[\"collection<\",{\"1\":{\"76\":1,\"77\":2}}],[\"collectors\",{\"1\":{\"78\":3}}],[\"collect\",{\"1\":{\"78\":2}}],[\"coll\",{\"1\":{\"77\":9}}],[\"copyonwritearraylist列表不应太大\",{\"1\":{\"177\":1}}],[\"copyonwritearraylist合适读多写少的场景\",{\"1\":{\"177\":1}}],[\"copyonwritearraylist<>\",{\"1\":{\"174\":1}}],[\"copyonwritearraylistmain\",{\"1\":{\"174\":1}}],[\"copyonwritearraylist\",{\"0\":{\"173\":1}}],[\"copyof只是浅拷贝\",{\"1\":{\"77\":1}}],[\"copyof\",{\"1\":{\"77\":2,\"175\":1}}],[\"copyof即使是原string列表做了修改\",{\"1\":{\"77\":1}}],[\"copyof与unmodifiablelist\",{\"0\":{\"77\":1}}],[\"copyof方法的特性\",{\"1\":{\"77\":1}}],[\"copyof方法可以看到\",{\"1\":{\"77\":1}}],[\"copyof方法\",{\"1\":{\"74\":1}}],[\"copy\",{\"1\":{\"76\":1,\"427\":1}}],[\"control\",{\"1\":{\"426\":1}}],[\"contain\",{\"1\":{\"93\":2}}],[\"concurrency\",{\"0\":{\"371\":1,\"457\":1}}],[\"concurrent中涵盖了executor的框架\",{\"1\":{\"269\":1}}],[\"concurrenthashmap\",{\"0\":{\"161\":1},\"1\":{\"162\":1}}],[\"concurrent\",{\"1\":{\"135\":1,\"351\":1}}],[\"concurent\",{\"1\":{\"247\":1}}],[\"condition通过lock对象获取\",{\"1\":{\"171\":1}}],[\"condition可以替代wait和notify\",{\"1\":{\"171\":1}}],[\"condition替代了object监视器方法的使用\",{\"1\":{\"167\":1}}],[\"condition将object监视器方法\",{\"1\":{\"167\":1}}],[\"condition\",{\"0\":{\"394\":1},\"1\":{\"143\":2,\"171\":2}}],[\"construct\",{\"1\":{\"118\":1}}],[\"constructor\",{\"1\":{\"49\":1,\"86\":2,\"354\":1}}],[\"console\",{\"1\":{\"110\":8}}],[\"consumerdemo\",{\"1\":{\"52\":1}}],[\"consumer\",{\"0\":{\"52\":1},\"1\":{\"50\":1,\"52\":3,\"142\":3}}],[\"consumer<string>\",{\"1\":{\"52\":1}}],[\"consumer<\",{\"1\":{\"45\":1}}],[\"consumer<t>\",{\"1\":{\"45\":2}}],[\"configuration\",{\"1\":{\"386\":1}}],[\"config\",{\"0\":{\"24\":1},\"1\":{\"386\":1,\"419\":1}}],[\"common\",{\"0\":{\"283\":1}}],[\"command\",{\"1\":{\"13\":2,\"426\":2}}],[\"component\",{\"1\":{\"399\":1}}],[\"compile\",{\"1\":{\"110\":5,\"113\":2,\"116\":1}}],[\"compiler\",{\"1\":{\"92\":1}}],[\"compinit\",{\"1\":{\"15\":2}}],[\"compareandsetint方法是一个native方法\",{\"1\":{\"137\":1}}],[\"compare\",{\"1\":{\"136\":1}}],[\"compareto\",{\"1\":{\"47\":1}}],[\"comparator<\",{\"1\":{\"76\":1}}],[\"completion\",{\"0\":{\"15\":1},\"1\":{\"15\":1}}],[\"com\",{\"1\":{\"13\":2,\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"110\":3,\"127\":2,\"212\":5,\"313\":2,\"326\":1,\"329\":1,\"354\":1,\"385\":1,\"433\":1}}],[\"cobra\",{\"0\":{\"12\":1,\"13\":1,\"16\":1,\"25\":1},\"1\":{\"13\":6}}],[\"命令行之神cobra\",{\"0\":{\"11\":1}}],[\"浅尝辄止ddd\",{\"0\":{\"9\":1}}],[\"深入了解cqrs\",{\"0\":{\"8\":1}}],[\"ddd\",{\"0\":{\"442\":1}}],[\"ddd在spring项目的实战\",{\"0\":{\"7\":1},\"1\":{\"7\":1}}],[\"db\",{\"0\":{\"439\":1}}],[\"dart\",{\"0\":{\"434\":1}}],[\"dart中的新特性\",{\"0\":{\"2\":1},\"1\":{\"2\":1,\"4\":1}}],[\"day\",{\"1\":{\"433\":1}}],[\"daemonthread\",{\"1\":{\"352\":1}}],[\"daemon\",{\"1\":{\"352\":1}}],[\"d之类的\",{\"1\":{\"113\":1}}],[\"diver\",{\"1\":{\"180\":7}}],[\"digit\",{\"1\":{\"113\":2}}],[\"directory\",{\"1\":{\"14\":1}}],[\"dm\",{\"1\":{\"112\":1}}],[\"d\",{\"1\":{\"78\":3,\"88\":1,\"110\":2,\"112\":3,\"113\":4,\"117\":8,\"234\":1,\"241\":2,\"248\":3,\"269\":1,\"419\":2}}],[\"domain\",{\"1\":{\"433\":1}}],[\"do\",{\"1\":{\"419\":1}}],[\"doexchangework\",{\"1\":{\"194\":3}}],[\"does\",{\"1\":{\"93\":2}}],[\"done\",{\"1\":{\"180\":11}}],[\"donesignal的计数量为5\",{\"1\":{\"180\":1}}],[\"donesignal\",{\"1\":{\"180\":3}}],[\"down\",{\"1\":{\"180\":1}}],[\"download\",{\"1\":{\"13\":1}}],[\"dothrow\",{\"1\":{\"101\":1}}],[\"doreturn和thenreturn的区别\",{\"0\":{\"106\":1},\"1\":{\"106\":1}}],[\"doreturn\",{\"1\":{\"101\":1}}],[\"docker远程debug\",{\"0\":{\"88\":1}}],[\"docker\",{\"0\":{\"87\":1,\"446\":1},\"1\":{\"88\":1}}],[\"documented\",{\"1\":{\"37\":2}}],[\"double\",{\"0\":{\"96\":1},\"1\":{\"65\":1,\"96\":1}}],[\"devops\",{\"0\":{\"447\":1}}],[\"developer\",{\"1\":{\"313\":1}}],[\"delegatedscheduledexecutorservice\",{\"1\":{\"269\":1}}],[\"dead\",{\"1\":{\"212\":1}}],[\"deadlock$$lambda$15\",{\"1\":{\"212\":1}}],[\"deadlock$$lambda$14\",{\"1\":{\"212\":1}}],[\"deadlock\",{\"1\":{\"211\":1,\"212\":6}}],[\"dequeue\",{\"1\":{\"143\":3}}],[\"def\",{\"1\":{\"112\":1}}],[\"defaultvalue\",{\"1\":{\"93\":1}}],[\"default\",{\"1\":{\"45\":1,\"76\":1,\"78\":1}}],[\"debug以debug模式运行\",{\"1\":{\"88\":1}}],[\"debug配置\",{\"1\":{\"88\":1}}],[\"debug\",{\"1\":{\"88\":1}}],[\"design\",{\"0\":{\"443\":1}}],[\"destfunc\",{\"1\":{\"51\":2}}],[\"description\",{\"1\":{\"14\":1,\"118\":1}}],[\"deprecated\",{\"1\":{\"37\":2}}],[\"dependencies\",{\"1\":{\"13\":1}}],[\"demo\",{\"1\":{\"13\":4,\"88\":2}}],[\"k8s\",{\"0\":{\"449\":1}}],[\"kafka\",{\"0\":{\"438\":1}}],[\"kafka简介\",{\"1\":{\"6\":1}}],[\"keepalivetime的时间单位\",{\"1\":{\"269\":1}}],[\"keepalivetime\",{\"1\":{\"269\":5}}],[\"keygen\",{\"1\":{\"427\":1}}],[\"key\",{\"1\":{\"24\":2,\"93\":4,\"427\":1,\"433\":1}}],[\"kotlin\",{\"0\":{\"437\":1},\"1\":{\"5\":1,\"77\":1}}],[\"kotlin中的scope\",{\"0\":{\"5\":1}}],[\"fn\",{\"1\":{\"426\":2}}],[\"f2\",{\"1\":{\"419\":1}}],[\"full\",{\"1\":{\"146\":1}}],[\"function<integer\",{\"1\":{\"51\":3}}],[\"functiondemo\",{\"1\":{\"51\":1}}],[\"function包提供的函数式接口有很多\",{\"1\":{\"50\":1}}],[\"function等\",{\"1\":{\"49\":1}}],[\"functionalinterface\",{\"1\":{\"45\":3}}],[\"functionalinterface且只有一个abstract方法\",{\"1\":{\"45\":1}}],[\"function中\",{\"1\":{\"44\":1}}],[\"function\",{\"0\":{\"5\":1,\"51\":1},\"1\":{\"51\":5,\"52\":2,\"53\":2,\"54\":2,\"419\":2}}],[\"framework\",{\"0\":{\"458\":1,\"463\":1}}],[\"freememory\",{\"1\":{\"137\":1}}],[\"from\",{\"1\":{\"14\":1,\"342\":1,\"343\":1}}],[\"f\",{\"1\":{\"112\":1,\"113\":1,\"419\":1}}],[\"firstvalue\",{\"1\":{\"336\":2}}],[\"fixedthreadpool\",{\"1\":{\"269\":1}}],[\"finish\",{\"1\":{\"226\":20,\"241\":12}}],[\"finder\",{\"1\":{\"433\":2}}],[\"find\",{\"1\":{\"110\":1}}],[\"findbyname\",{\"1\":{\"100\":1}}],[\"finalizabledelegatedexecutorservice\",{\"1\":{\"269\":1}}],[\"finally\",{\"1\":{\"143\":4,\"241\":2,\"247\":1,\"248\":1}}],[\"final\",{\"1\":{\"86\":4,\"101\":1,\"118\":1,\"136\":2,\"143\":10,\"175\":2,\"180\":2,\"186\":2,\"194\":1,\"211\":2,\"213\":1,\"247\":1,\"248\":1,\"257\":1,\"269\":1,\"316\":1,\"336\":2,\"347\":2,\"348\":3,\"399\":1}}],[\"fields\",{\"0\":{\"85\":1},\"1\":{\"86\":3}}],[\"field\",{\"1\":{\"37\":1}}],[\"following\",{\"1\":{\"399\":1}}],[\"forkjoinpool线程池可以把一个大任务分拆成小任务并行执行\",{\"1\":{\"202\":1}}],[\"fork\",{\"1\":{\"202\":1}}],[\"format中\",{\"1\":{\"433\":1}}],[\"formatted\",{\"1\":{\"269\":1}}],[\"format\",{\"1\":{\"110\":2}}],[\"forclass\",{\"1\":{\"102\":1}}],[\"forclass方法创建argumentcaptor对象\",{\"1\":{\"102\":1}}],[\"for\",{\"1\":{\"76\":1,\"112\":1,\"118\":1,\"142\":2,\"180\":3,\"212\":1,\"234\":1,\"241\":4,\"247\":1,\"257\":1,\"269\":1,\"351\":1,\"360\":5,\"419\":1}}],[\"foreachremaining\",{\"1\":{\"174\":1}}],[\"foreach\",{\"1\":{\"48\":1}}],[\"found\",{\"1\":{\"13\":1,\"110\":5,\"111\":9,\"117\":2,\"212\":1}}],[\"fairsync\",{\"1\":{\"257\":1}}],[\"fair\",{\"1\":{\"143\":2,\"251\":1,\"257\":2}}],[\"faq\",{\"0\":{\"19\":1,\"38\":1,\"55\":1,\"66\":1,\"79\":1,\"121\":1,\"131\":1,\"138\":1,\"144\":1,\"157\":1,\"164\":1,\"170\":1,\"176\":1,\"182\":1,\"188\":1,\"195\":1,\"201\":1,\"208\":1,\"215\":1,\"230\":1,\"236\":1,\"243\":1,\"252\":1,\"259\":1,\"265\":1,\"275\":1,\"290\":1,\"294\":1,\"302\":1,\"310\":1,\"323\":1,\"331\":1,\"337\":1,\"353\":1,\"363\":1,\"381\":1}}],[\"false\",{\"1\":{\"14\":3,\"53\":1,\"76\":1,\"90\":1,\"92\":3,\"101\":3,\"110\":1,\"143\":1,\"248\":1,\"346\":3,\"359\":1}}],[\"fpath\",{\"1\":{\"15\":1}}],[\"flutter\",{\"0\":{\"436\":1}}],[\"flutter中的新特性\",{\"0\":{\"4\":1}}],[\"fliter\",{\"1\":{\"94\":1}}],[\"floating\",{\"1\":{\"72\":1}}],[\"float浮点数还可以表示一些特殊的数字\",{\"1\":{\"65\":1}}],[\"float\",{\"1\":{\"65\":1}}],[\"float数值的比较和运算都有可能会出现问题\",{\"1\":{\"65\":1}}],[\"flag表示匹配规则中的标志位\",{\"1\":{\"110\":1}}],[\"flag就是符号位\",{\"1\":{\"65\":1}}],[\"flag\",{\"1\":{\"65\":1}}],[\"flags\",{\"0\":{\"14\":1},\"1\":{\"14\":10,\"110\":2}}],[\"hour\",{\"1\":{\"433\":1}}],[\"holdcount\",{\"1\":{\"248\":6}}],[\"hubei\",{\"1\":{\"345\":2}}],[\"huhx2\",{\"1\":{\"399\":1}}],[\"huhx\",{\"0\":{\"1\":1},\"1\":{\"13\":1,\"51\":1,\"52\":3,\"53\":1,\"54\":3,\"102\":3,\"110\":3,\"212\":5,\"329\":1,\"335\":5,\"345\":1,\"399\":2,\"433\":1}}],[\"html\",{\"1\":{\"313\":1,\"433\":1}}],[\"https\",{\"1\":{\"13\":1,\"127\":2,\"160\":1,\"162\":1,\"313\":2,\"326\":1,\"354\":1,\"385\":1,\"433\":1}}],[\"handle\",{\"1\":{\"399\":3}}],[\"handler\",{\"1\":{\"269\":5}}],[\"hapens\",{\"0\":{\"301\":1}}],[\"hamcrest\",{\"0\":{\"280\":1}}],[\"harness\",{\"1\":{\"110\":1}}],[\"hasqueuedthreads\",{\"1\":{\"257\":1}}],[\"hassize\",{\"1\":{\"101\":1}}],[\"has\",{\"1\":{\"86\":2,\"94\":1,\"180\":2}}],[\"have\",{\"1\":{\"86\":2}}],[\"hellorunnable\",{\"1\":{\"343\":2}}],[\"hellothread\",{\"1\":{\"342\":4}}],[\"hello\",{\"0\":{\"1\":1},\"1\":{\"91\":6,\"342\":1,\"343\":1,\"344\":2,\"346\":4}}],[\"ioexception\",{\"1\":{\"186\":1}}],[\"iterator\",{\"1\":{\"174\":3}}],[\"items\",{\"1\":{\"143\":13}}],[\"itrs\",{\"1\":{\"143\":2}}],[\"its\",{\"1\":{\"93\":1}}],[\"illegalmonitorstateexception\",{\"1\":{\"347\":1}}],[\"illegalargumentexception\",{\"1\":{\"143\":1,\"180\":1,\"186\":1,\"269\":1}}],[\"illegalaccessexception\",{\"1\":{\"137\":1}}],[\"illegal\",{\"1\":{\"113\":1}}],[\"illegalstateexception\",{\"1\":{\"101\":4,\"146\":1}}],[\"ignore\",{\"0\":{\"85\":1}}],[\"i++\",{\"1\":{\"76\":1,\"142\":2,\"234\":1,\"241\":4,\"247\":1,\"248\":1,\"257\":1,\"269\":1,\"351\":1,\"352\":1,\"360\":3}}],[\"implementation\",{\"1\":{\"386\":1}}],[\"implements\",{\"1\":{\"76\":1,\"142\":2,\"180\":1,\"186\":1,\"247\":1,\"248\":1,\"269\":1,\"270\":1,\"343\":1,\"377\":1}}],[\"implicit\",{\"1\":{\"76\":1,\"77\":1}}],[\"import\",{\"1\":{\"51\":1,\"52\":1,\"53\":1,\"54\":2,\"88\":1,\"110\":1}}],[\"immutablecollections\",{\"1\":{\"76\":5,\"77\":1}}],[\"ieee\",{\"1\":{\"72\":1}}],[\"id和accesskey\",{\"1\":{\"431\":1}}],[\"id=1\",{\"1\":{\"77\":2}}],[\"id\",{\"1\":{\"24\":1,\"100\":2,\"269\":9,\"427\":2}}],[\"isalive\",{\"1\":{\"380\":1}}],[\"isactive方法返回true\",{\"1\":{\"380\":1}}],[\"isactive\",{\"1\":{\"94\":2}}],[\"isinterrupted\",{\"1\":{\"346\":4}}],[\"isheld\",{\"1\":{\"248\":6}}],[\"isheldbycurrentthread\",{\"1\":{\"248\":4}}],[\"isfalse\",{\"1\":{\"101\":2}}],[\"isequal\",{\"1\":{\"102\":1}}],[\"isequalto\",{\"1\":{\"100\":1,\"102\":2,\"103\":1}}],[\"isenabled\",{\"1\":{\"92\":4}}],[\"isempty\",{\"1\":{\"54\":1}}],[\"isn\",{\"1\":{\"90\":2}}],[\"is\",{\"1\":{\"14\":2,\"86\":1,\"88\":1,\"90\":2,\"93\":1,\"180\":4,\"347\":1,\"352\":2}}],[\"issues\",{\"1\":{\"13\":1}}],[\"if\",{\"1\":{\"14\":2,\"77\":2,\"90\":2,\"95\":2,\"110\":2,\"118\":1,\"143\":5,\"146\":1,\"180\":1,\"186\":1,\"234\":1,\"257\":1,\"269\":2,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":2,\"336\":5,\"343\":1,\"351\":1}}],[\"incrementandget\",{\"1\":{\"360\":1}}],[\"increment\",{\"1\":{\"360\":3}}],[\"inclusive\",{\"1\":{\"112\":1}}],[\"include\",{\"1\":{\"85\":2}}],[\"inline\",{\"1\":{\"103\":1}}],[\"inline已经依赖了mocktio\",{\"1\":{\"103\":1}}],[\"inline替换之前的mocktio\",{\"1\":{\"103\":1}}],[\"inline库\",{\"1\":{\"103\":1}}],[\"injectmocks\",{\"1\":{\"99\":1,\"100\":1}}],[\"input\",{\"1\":{\"76\":5,\"110\":1,\"111\":7,\"117\":2,\"118\":3}}],[\"index\",{\"1\":{\"75\":2,\"76\":4,\"101\":1,\"110\":3,\"111\":14,\"117\":2,\"175\":4,\"269\":6}}],[\"information\",{\"1\":{\"212\":1}}],[\"infoq\",{\"1\":{\"160\":1}}],[\"info\",{\"1\":{\"63\":1,\"65\":1,\"378\":1}}],[\"int和long四种\",{\"1\":{\"64\":1}}],[\"interruptthread\",{\"1\":{\"346\":1}}],[\"interrupted\",{\"1\":{\"346\":6}}],[\"interruptedexception\",{\"1\":{\"142\":3,\"143\":2,\"174\":1,\"180\":3,\"186\":4,\"194\":1,\"211\":2,\"226\":1,\"234\":1,\"241\":2,\"247\":1,\"248\":1,\"257\":1,\"269\":1,\"270\":2,\"317\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":1,\"329\":2,\"335\":1,\"342\":2,\"343\":1,\"344\":2,\"345\":2,\"346\":2,\"347\":3,\"350\":2,\"352\":2,\"359\":1,\"360\":1,\"377\":1,\"378\":2,\"379\":2,\"380\":2}}],[\"interrupt\",{\"1\":{\"346\":9,\"379\":1}}],[\"intersection\",{\"1\":{\"112\":1}}],[\"interface\",{\"1\":{\"45\":1}}],[\"intellj配置remote\",{\"1\":{\"88\":1}}],[\"integer\",{\"1\":{\"64\":2,\"269\":1}}],[\"integer>\",{\"1\":{\"51\":3}}],[\"int\",{\"1\":{\"51\":7,\"53\":1,\"64\":1,\"75\":2,\"76\":5,\"101\":2,\"110\":1,\"116\":6,\"136\":1,\"137\":1,\"142\":2,\"143\":1,\"175\":3,\"180\":2,\"186\":5,\"234\":2,\"241\":6,\"247\":2,\"257\":9,\"269\":9,\"348\":3,\"351\":1,\"352\":1,\"360\":4,\"379\":3}}],[\"inherited\",{\"1\":{\"37\":2}}],[\"instance采用volatile关键字修饰也是很有必要的\",{\"1\":{\"321\":1}}],[\"instance\",{\"1\":{\"316\":2,\"317\":4,\"318\":4,\"319\":4,\"320\":4,\"321\":6}}],[\"instanceof运算符将返回false\",{\"1\":{\"95\":1}}],[\"instanceof\",{\"1\":{\"77\":3,\"95\":2,\"336\":1}}],[\"instantmockedstatic\",{\"1\":{\"103\":2}}],[\"instant\",{\"1\":{\"103\":6}}],[\"install\",{\"1\":{\"13\":2,\"433\":1}}],[\"inside\",{\"0\":{\"16\":1,\"18\":1}}],[\"initialvalue\",{\"1\":{\"335\":1,\"336\":2}}],[\"init\",{\"1\":{\"13\":2}}],[\"in\",{\"1\":{\"5\":1,\"14\":2,\"77\":4,\"113\":1,\"248\":2,\"329\":1,\"342\":1,\"343\":1,\"344\":2,\"346\":4,\"347\":1,\"350\":4,\"399\":1,\"419\":1}}],[\"i\",{\"0\":{\"1\":1},\"1\":{\"76\":4,\"110\":1,\"111\":7,\"117\":1,\"142\":5,\"180\":2,\"234\":11,\"241\":8,\"247\":2,\"257\":2,\"269\":3,\"351\":4,\"352\":7,\"360\":6,\"419\":1,\"427\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
